![image](https://github.com/user-attachments/assets/9deed4e8-6fa2-4773-80fb-0c05aea32b36)![image](https://github.com/user-attachments/assets/bd2f3b47-c5ee-4182-97a8-576e87c00659)### CDAH-M16L1-Acquiring a Forensic Disk Image ###

Forensic Image File and Compression Formats
A forensic image is a copy of media, like a disk or Solid-State Drive (SSD), that can be entered legally into evidence in a court of law. Forensic images are needed to verify data integrity, because the data can be compared and verified to not have been tampered with after the image was taken. A forensic image includes all Operating System (OS) data and written bits, sectors, partitions, files, folders, master boot records, bits marked for deletion, and unallocated space. A forensic image can be manipulated and read without interacting with the original drive and the drive’s contents.

﻿

Collecting forensic images of disk sources can be accomplished in many ways and with different image formats. The image file type created depends on the tools used and the specifics of the source. An image file can be a single file that contains the entire disk source or a series of multiple files that collectively represent the source. Common image file types are as follows:

Raw byte-for-byte.
Single raw file (dd): A Linux command-line file system tool.
Split raw files (affuse): Filesystem in Userspace (FUSE)–format files.
AFF (Advanced Forensic Format).
AFD (AFF multiple file).
AFM (AFF with external metadata).
EWF (Expert Witness format [EnCase]).
Split EWF (split E01 files): A file type used by forensic imaging tools, commonly used for legal evidence-based forensic images.
VM disk image.
VMDK.
VHD/VHDX.

Toolkits provide different types of image files, depending on the need. This lesson covers basic dd-based images, FTK® Imager images, and images opened for analysis with Autopsy.

![image](https://github.com/user-attachments/assets/31f85f10-8f42-4a2c-9fcc-30908380a523)


------------------

Forensic Image Compression
Forensic image compression allows organizations to save valuable disk space for both archival requirements and data transfer needs. If all images were stored in their raw format, most organizations would run out of disk space for archived evidence or be unable to transfer larger disk images across interdepartmental networks. 

﻿

The E01 (EnCase) image file format provides a backup of acquired digital evidence that includes many different data points surrounding an image, including timestamps, contents, and other distinguishing characteristics. The E01 format is regularly used because it saves space for analysts and agents who need to keep a large number of files. The format also supports many types of metadata for ease of identification. E01 documents the disk header, logical volume health information, sector health, and other metrics related to the imaging process to verify the integrity of the compression.

﻿

Many standard file compression formats besides E01 exist, but not all are verifiably lossless or approved for evidence collection by many organizations. Third-party tools, such as LZ4 in Linux, are fast and should not compromise integrity of the image, but the image files must be rehashed each time they are decompressed to verify that all the contents of the image have been retained between compressions.

![image](https://github.com/user-attachments/assets/2a71b8d4-d274-43df-adc8-86f94e70fa2d)


------------------

Creating Forensic Images for Analysis
Forensic Image Creation Techniques and Tools 
﻿

Various tools are available for creating forensic images on Windows such as FTK Imager, and most security professionals using Linux use native OS tools like the dd command. The specific tool used matters only for compatibility reasons, not legal or procedural ones. As long as a completed image can be separately hashed and verified after an image is collected, the image can be used in a forensic context. The tools used in this lesson represent examples of the many imaging solutions available.

﻿

Windows Imaging Applications
﻿

A wide variety of disk-imaging applications exists for the Windows OS. At the height of the Windows NT era, Norton Ghost was regularly used as an imaging tool but is not used often today. Lighter-weight toolkits like the FTK imager toolkit are often used because of their fully featured suites of options related to the forensic parts of the imaging process. Windows-based tools can often integrate case files, associate hashes with images, and automatically verify file integrity for decompressed images. Many investigators use these Windows-based tools because of their consistency and ease of use.

﻿

Linux dd Command
﻿

In all distributions of Linux, the dd command allows for the creation of an image of a partition or the complete clone of a disk. Because the dd command makes full copies of the disk or partition, it requires an equal amount of, or more, storage space on the target disk for the copy. This tool is especially useful for creating images of drives that have been connected externally to the Linux machine being used if a software write blocker is installed or the disk is set to read only. A potentially corrupted or infected Windows image can be copied without opening or executing the files on the disk, all from the safety of a Linux host.


---------

Maintaining Data Integrity
Methods of maintaining integrity of data on a forensic image include use of write-protecting hardware, hashing, developing a chain of custody, and documenting the investigation.

﻿

Write-Protecting Hardware
﻿

Once a device is collected for forensic imaging, the investigator should use a hardware write blocker connected to the acquired device. This ensures that the collected device cannot be written to, even if the physical switch has been damaged or compromised. Write blockers can also be updated and regularly checked to ensure functionality between uses.

﻿

Hashing
﻿

When a drive has been imaged, a hash should be created to verify the integrity of the data. If a single bit of data changes between image files, a properly hashed forensic image does not match what was initially collected, indicating evidence tampering. Common hashing standards for forensic images are the same as for individual files (MD5 of SHA1). The hash represents a “fingerprint” formed by creating a numerical value based on the bit values in the image that are then run through a hashing table.

﻿

Chain of Custody
﻿

Where feasible, it is best to implement a chain of custody during an investigation. A chain of custody is an established list of individuals who own certain parts of the forensic process. A chain of custody is standard practice for many forms of evidence, not just forensic images, and this practice creates a burden of responsibility for individuals handling the evidence in question. Sometimes an initial investigation does not require the rigor of full chain-of-custody evidence collection precautions, but understanding when to form a chain of custody can help investigators ensure the integrity of what they have collected at different points in the investigative chain. Each organization has its own operating procedures that should be followed when a chain of custody is required and should be referenced as appropriate.

﻿

Investigation Documentation
﻿

Proper documentation throughout the investigative process is key to building trust in the evidence collected. Investigators should follow their organization’s procedures for proper documentation. As forensic evidence is collected, notes should be taken for every item, relevant persons should be noted for reference, reports should be made about the process taken for the investigation, and proper organization of these notes for potential submission should be developed.


----------------

Create a Forensic Image with FTK Imager
Complete the steps in the following workflow to create a forensic image of the Documents folder on a Virtual Machine (VM) using FTK Imager. 

﻿

Workflow
﻿

1. Log in to the VM win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open FTK Imager on the desktop.

﻿

3. Select File > Create Disk Image.

﻿

4. Select Contents of a Folder from the bulleted list, and select Next. Select yes when prompted.

﻿

5. Select the Browse button, expand the trainee folder, select Documents, and select OK.

﻿

6. Select Finish.

﻿

7. Select the Add button to add a destination for the image file.

﻿

8. Enter the following as a sample for the evidence information for this image:

Case Number: 01
Evidence Number: 02
Unique Description: Test
Examiner: Trainee
Notes: N/A

9. Select Next.

﻿

10. Select Browse, and set the image destination as the desktop.

﻿

11. Select OK.

﻿

12. Enter Documents Image in the Image Filename field.

﻿

13. Select Finish.

﻿

14. Select Start.

﻿

The image is created, and the hash of the image is displayed. 

﻿

15. Close FTK Imager. 

﻿

The image was created on the desktop as a .e01 file, with a text file with the relevant evidence information for reference.

﻿

In a real-world scenario, these steps would likely be performed to collect an image of the entire disk from a physically collected drive.



------------------


Open a Forensic Image with Autopsy
Autopsy is a forensic image examination tool that allows an investigator to build a case using a given image. Complete the steps in the following workflow to open the image created in the previous workflow for analysis.

﻿

Workflow
﻿

1. Log in to the VM win-hunt using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open Autopsy on the desktop.

﻿

3. Select New Case.

﻿

4. Add the case name Sample, and browse to the Documents folder to set the base directory.

﻿

5. Select Next.

﻿

6. Enter the case number 01, and select Finish.

﻿

A sample case is created that can be used to gather forensic evidence with Autopsy. An image file can be examined for a number of different uses, and organizations often have standard practices regarding forensic image analysis.

﻿

Autopsy requires a data source to be added, and its integrity must be verified, based on the other data provided.

﻿

7. Select Specify New Host Name, enter Case Host, and select Next.

﻿

8. Select Disk Image or VM File, and select Next.

﻿

9. Select the Browse button, and select the .e01 image on the desktop.

﻿

10. Select Next on the Configure Ingest screen. 

﻿

11. Select Finish on the Add Data Source screen.

﻿

12. Once the case completes, expand the Data Sources option, expand the Case Host option, and select TestCase.E01 to view the image properties.

﻿

13. Select the Summary tab, and select the Container tab.

﻿

14. Visually compare the MD5 hash provided with the MD5.txt file on the desktop.

﻿

If the two hash values match, integrity of the image has been maintained. A difference between the two hash values indicates tampering or corruption of data. Should such a difference occur, work back through the case change log to find the point at which the hash change occurred.

![image](https://github.com/user-attachments/assets/07300ad3-cc5d-4b3f-a701-bb8db1a7095a)



----------------

Create a Forensic Image with dd
Creating an image for forensic analysis can be done in multiple ways. Complete the steps in the following workflow to create image copies that retain their validity as evidence using dd and FTK Imager.

﻿

Workflow
﻿

1. Log in to the VM lin-hunt-cent using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open a new terminal session, and run the following command to obtain a hash of the target partition to compare with copies. If prompted, use the password CyberTraining1!.

$ sudo sha512sum /dev/sda1
﻿

3. Collect a copy of the image by running the dd command:

sudo dd if=/dev/sda1 of=/opt/sda1dd bs=64k conv=noerror,sync 
﻿

In the above command, if represents the input file and of represents the output file. This command creates an image named sda1Image in the /opt/ directory.

﻿

4. Set the file to read only by running the following command:

sudo chmod 0444 /opt/sda1dd
﻿

5. Run the following command to hash the image file to ensure that the contents of the copied image are the same and verify that no errors occurred during the copying process:

sha512sum /opt/sda1dd
﻿

The hash produced should match the original hash.

﻿

6. If the hashes are different, compare the original hash by running the following command:

echo "replaceWithHashFromStep2 /opt/sda1dd" | sha512sum -c
﻿

If the comparison is successful, the following is displayed:

/opt/sda1dd: OK
﻿

If the comparison fails, the following is displayed:

/opt/sha512dd: FAILED
sha512sum: WARNING: 1 computed checksum did NOT match
﻿
![image](https://github.com/user-attachments/assets/bc8f6c0a-d12e-4d99-8c90-d98920bef56c)
![image](https://github.com/user-attachments/assets/edd4d131-3396-434a-bf96-8a6e984a6449)


---------------


Creating a Forensic Image from a Remote Source
When the disk to be imaged or the system housing the disk is not physically accessible, remote imaging methods must be used. In some cases, specifically with smaller data sizes, service agents can be used on the remote system to capture the image. The agent may be bootable media that allows collection of disk images while the OS is stopped or an active agent process running on the OS. Collection and electronic transfer of large disks may require many hours or even days. Data collection may be limited to partial acquisition instead of the entire disk or partition, such as collecting specific files or folders. 

﻿

In most cases, specialized forensic imaging kits are sent to remote locations for local administrators to use in the imaging process. These kits allow local forensic image collection, after which the image is shipped back to the investigating team for analysis. Acquiring evidence that needs to be shipped or transported also often requires an established chain of custody for added security. This practice is in place because imaging over a network connection can fail and leave incomplete or corrupted images when network conditions are unstable.


-----------

### CDAH-M16L2-Parsing a Forensic Disk Image ###

Disk Image Parsing Tools and Techniques
Forensic images may be captured in several different formats using tools designed for bit-by-bit copy. These tools create a portrayal of a physical hard disk state that is as accurate as possible for further investigation. Once the images are captured, parsing the file for valuable information is a matter of choosing the right analysis method with the chosen tool. 

﻿

Forensic Image Formats
﻿

The most common forensic image file formats are described below, though this does not encompass all file formats. Image parsing tools can typically handle standard file formats, including these.

﻿

RAW
﻿

The RAW file format is created by the Linux disk imager utility dd. The dd format provides simple bit-for-bit representations of the data imaged by the utility, without additional hash data or compression. 

﻿

E01
﻿

The E01 file format is created by the EnCase tool. When broken into multiple segments, the image metadata includes a hash for each segment and metadata entered by an examiner regarding when the image was captured. Each segment is stored as a separate file with a 640-megabyte (MB) maximum size. The header of an E01 image file provides the case information that a user inputs at the time of collection; this includes the name of the investigator, case name or number, media from which data is transcribed, the date and time of collection, and the software and Operating System (OS) versions of the collection device. E01 is the most common format in the Expert Witness Disk Image Format (EWF) family.

﻿

SMART
﻿

SMART is a file format for Linux imaging software and a legacy format in the EWF family. Image files formatted with this standard use the .s01 extension.

﻿

Advanced Forensic Format (AFF)
﻿

The Advanced Forensic Format file type is a non-proprietary extensible file format. It is designed to store disk images of any size, with or without compression, in one or many files. The image includes file metadata at the time of capture. The format definition also includes provisions for internal self-consistency checking and for certifying evidence file authenticity. Both of these features are important for the integrity of data for law enforcement functions and to recover data, even if a portion of the drive has been corrupted.


---------------

Forensic Imaging Tools
dd
﻿

The dd command-line utility is employed by administrators to copy hard drives and device files into backup locations, sometimes with data-encoding conversions during the copying process. Because the file type of the output is “raw” data, the image format RAW is synonymous with the format dd.

﻿

EnCase
﻿

EnCase is an industry-standard tool for capturing forensic images of hard disks for evidence in law enforcement investigations or threat hunts as well as Incident Response (IR) actions. It stores captured images in its proprietary E01 format.

﻿

FTK® Imager
﻿

FTK Imager is a popular, free alternative to EnCase. It can store images in the E01 or SMART format.


--------------


Image Parsing Tools
The Sleuth Kit (TSK) and Autopsy
﻿

The Sleuth Kit is a collection of command-line forensic tools and C language libraries used for disk image analysis and file recovery. Autopsy is a browser-based User Interface (UI) front-end application for The Sleuth Kit that improves the efficiency and user-friendliness of the analytical effort involved in parsing hard drive and mobile disk images. It runs as a Hypertext Transfer Protocol (HTTP) service served to the localhost interface. Functions available through these tools include listing all files on a system, cataloging file types, recovering deleted files, and performing hash-based or keyword searches on a file system. This lesson uses Autopsy during a hands-on exercise.

﻿

Foremost
﻿

Foremost is a forensic program, available in distributions such as Kali or the SANS™ Institute’s SIFT™ Workstation, used to recover deleted files from a disk or image file through analysis of headers, footers, and internal data structures. The headers and footers can be specified by a configuration file or the use of command-line switches to specify built-in file types. These built-in types look at the data structures of a given file format, allowing for a more reliable and faster recovery.


------------

Disk Image Analysis Techniques
Mounting an Image to a File System
﻿

To analyze a disk image, an analyst may either run the image through an analysis tool (such as Autopsy, for which techniques are described below) or mount the image with an application (such as OSFMount). The difference is that running an analysis represents a static analysis, which does not alter the image in any way, whereas mounting an image to a file system alters and corrupts the image unless it is mounted in read-only mode. (However, for IR and hunts, mounting the image to a file system rather than in a Virtual Machine [VM] may allow for advanced dynamic malware analysis when the mounting occurs in a sandbox environment.)

﻿

Keyword Searches
﻿

Keyword searches of a file system image may be performed using American Standard Code for Information Interchange (ASCII) strings and grep regular expressions. Searches may be performed on the full file system image or only the unallocated space. An index file may be created for faster searches. Strings that are frequently searched for can be easily configured in Autopsy for automated searching.

﻿

Temporal Analysis
﻿

A timeline of file activity can help identify areas of a file system that may contain evidence. Autopsy can create timelines that contain entries for the Modification, Access, and Change (MAC) times of both allocated and unallocated files.

﻿

Deleted Files and Unallocated Space Searches
﻿

Portions of the file system marked as unallocated space may be examined to recover the contents of deleted files if those disk sectors are not already overwritten for new files. 

﻿

File Listings
﻿

The contents of files may be viewed in RAW or hex format, or the ASCII strings can be extracted. When data is interpreted, Autopsy sanitizes it to prevent damage to the local analysis system. Autopsy does not use any client-side scripting languages. The files are sorted based on their internal signatures to identify files of a known type. Autopsy can also extract only graphic images (including thumbnails). The extension of the file is also compared to the file type to identify files whose extensions have been changed to hide them.

﻿

Metadata Analysis
﻿

Metadata structures contain the details about files and directories. Autopsy allows details of any metadata structure in the file system to be viewed. This is useful for recovering deleted content. Autopsy searches the directories to identify the full path of the file that has allocated the structure.

﻿

Data Unit Analysis
﻿

Data units are where the file content is stored. Autopsy allows the contents of any data unit to be viewed in a variety of formats, including ASCII, hexdump, and strings. The file type is also provided, and Autopsy searches the metadata structures to identify which has allocated the data unit.

﻿

Image Details
﻿

File system details can be viewed, including on-disk layout and times of activity. This mode provides information that is useful during data recovery.

![image](https://github.com/user-attachments/assets/0ee1bd04-09a3-4780-a00f-3c84de306418)


-------

Parse a Forensic Disk Image
In the following lab, read the scenario below, and complete the workflows to parse a forensic disk image. The lab comprises two workflows:

Opening a new case in Autopsy.
Obtaining a file listing through forensic image parsing.
Scenario
﻿

The mission partner has determined that an insider threat information smuggling operation is occurring in their network. They have passed along a forensic image of a system suspected to have been used for the activity. Access the CPT SIFT Workstation, and analyze the image with Autopsy to run basic analysis of the imaged system.

﻿

Open a New Case
﻿

Complete the steps in the following workflow to open a new case in Autopsy.

﻿

Workflow
﻿

1. Open the sift analyst workstation. The login credentials are as follows:

Username: trainee
Password: CyberTraining1!
﻿

2. Open a terminal window.

﻿

3. Launch the Autopsy service with the following command:

trainee@siftworkstation:~$ sudo autopsy
[sudo] password for trainee: CyberTraining1!
﻿

4. Open the Firefox browser, and select the Autopsy bookmark or navigate to the address http://localhost:9999/autopsy.

﻿

5. Select New Case.

﻿

6. Enter the metadata relevant to the case:


Case Number: This field should contain a unique identifier (ID) assigned by a supervisory authority that manages all assigned cases. For this exercise, use the case name CDAH01.
Description: This field is a 32-character field for which a short phrase providing an investigation title is appropriate. (The field is not meant to include copious descriptions of the case.) For this exercise, use the current date and the title Insider Threat.
Investigator Names: In this field, provide the first and last names of the analysts collaborating on the investigation. Figure 16.2-1 provides the example names John Doe and Jane Doe.
﻿

![image](https://github.com/user-attachments/assets/974d2adf-6722-4d9b-9985-dbc696320528)


7. Select New Case when complete.


8. After receiving confirmation that the case is created, select Add Host to add information about a system that is being investigated:

![image](https://github.com/user-attachments/assets/679f4ccd-3937-43ef-90bb-47a706779a09)

9. Add the following metadata for the host being investigated:

Host Name: host_jean_o1
Description: Jean’s Computer
Time zone: <leave blank>
Timeskew Adjustment: 0
Path of Alert Hash Database: <leave blank>
Path of Ignore Hash Database: <leave blank>

10. Select Add Host to move to the next view:

![image](https://github.com/user-attachments/assets/018a2a74-67a9-49f3-a710-865e3f5aee34)

11. Select Add Image:

![image](https://github.com/user-attachments/assets/5b46e58d-dbb2-40b9-8b3a-a3390b67a465)

12. Add the disk image file to analyze. The path for the file is /home/trainee/Desktop/Cases/nps-2008-jean.e0*.
Select Disk as the image file type and Symlink as the method to import the image file into the Autopsy folders, and select Next:

![image](https://github.com/user-attachments/assets/480a1341-61d1-4082-9663-5c23f72f1fc4)


NOTE: The wildcard character (*) is placed at the end of the file path so that Autopsy can retrieve all the image files. This is because EnCase disk image captures number the file extensions of the image sequentially when the image is split into multiple files.

![image](https://github.com/user-attachments/assets/722d2b9f-ddbe-45fe-a047-cc087b80786a)


13. Select Next, and select Add.



When the files are loaded, Autopsy automatically detects the file system type and mount point:


![image](https://github.com/user-attachments/assets/7f85c4b3-072f-4cb2-8414-bf28cd95276c)

Select OK and keep the VM sift open for the next workflow.

----------------------

Obtain a File Listing
Complete the steps in the following workflow to open an analysis view of the image to peruse system files and conduct image parsing to list files.

﻿

Workflow
﻿

1. Select the radio button for NTFS disk volume, and select Analyze. (The NTFS volume, rather than the RAW disk image, is selected, as the NTFS volume is already formatted by Autopsy, making its contents readable by the tool.)

﻿
![image](https://github.com/user-attachments/assets/d36de7ef-831f-458e-97bd-0b15ba6bccdc)


2. Select the File Analysis tab at the top of the UI.




3. Select Expand Directories in the left pane to view the directory listing for the system:


![image](https://github.com/user-attachments/assets/d4b68e0f-8880-4448-949e-fad1431ba227)

![image](https://github.com/user-attachments/assets/73c49b32-0bcb-49d1-b8e0-d1c66e511372)



4. Obtain a file listing for all files in the C: directory (which appears by default) by selecting Generate MD5 List of Files:

![image](https://github.com/user-attachments/assets/ab1a3b99-fa38-4ddc-b31e-0a117e0f37f7)

One benefit of using this tool to generate the file listing is that in the event that a file is identified as an Indicator of Compromise (IOC), the MD5 hash helps to quickly find identical files, regardless of the filename or location used by threat actors. 

![image](https://github.com/user-attachments/assets/9de232f4-7dbe-4b3d-97ef-650598b465fd)


In addition to a file listing of each file in a directory, Autopsy may be used to generate a whole system survey by file type. 


5. Close the MD5 List tab and select the File Type tab.


6. In the left pane, select Sort Files by Type and then OK:


Because this process may require 10 to 30 minutes to complete, the file type analysis has been run in advance for this exercise, and the resulting documents are already prepared in the Cases folder on the desktop. The screenshots below are only for reference, proceed to Step 7.

![image](https://github.com/user-attachments/assets/c8d8ae8b-def7-4cfb-92f5-c01ac3d7325b)

In using this feature, an option exists to exclude some files from the survey and validate the extensions.


If this survey is initiated, the following progress screens indicate the results:


![image](https://github.com/user-attachments/assets/4cdb9fa3-57fb-48ab-8a8e-d8b87bf6d41f)

![image](https://github.com/user-attachments/assets/58481cd2-72c9-46e7-9aae-099af7a16810)


7. Unpack the documents from the Cases folder to the Autopsy folder for this case and host with the following command:
sudo tar -zxvf /home/trainee/Desktop/Cases/filetypes.tar.gz -C /



8. Open a new Firefox browser tab, and enter the following address to view the Hypertext Markup Language (HTML) report of the file types in the system:
file:///var/lib/autopsy/CDAH01/host_jean_o1/output/sorter-vol2/index.html

![image](https://github.com/user-attachments/assets/97ccc9d1-db18-4b21-a0e2-f3aed7fcd330)


Deleted files may be viewed using the File Analysis tab.


Using the above workflows, answer the following questions.


![image](https://github.com/user-attachments/assets/5c62c779-3013-47eb-b6df-5eaebc083abe)

![image](https://github.com/user-attachments/assets/b04ecf9f-c0bf-4e0b-9c79-7ed90d64d4b6)
![image](https://github.com/user-attachments/assets/2458f377-be4b-4ae9-a1c6-efd1aec0a07e)


![image](https://github.com/user-attachments/assets/a8a7e212-8535-4172-b256-c037a0622d2f)

------------------

### CDAH-M16L3-Windows Event Log Analysis ###


Reviewing Windows Event Logs
Accessing Event Logs
﻿

Windows event logs are stored on the same partition as the Windows installation drive. By default, Windows is usually installed on the C:\ drive and the full path to the event logs is C:\Windows\System32\winevt\Logs. Figure 16.3-1 is a view of the directory where the event logs are stored.


![image](https://github.com/user-attachments/assets/3b7c14ea-777c-407d-9260-dc1de6d01595)


Extracting Logs
Windows event logs stored within a forensic image are still in the same directory as listed above, but it takes a few more steps to access them. A forensic image is mounted either through OSFMount or within the Forensic Toolkit (FTK). Both of these tools are free and access the forensic image in a read-only state. FTK can also view the file system of the image without mounting the image, which is useful when looking for deleted files. TFTK provides access to locations that the Windows Operating System (OS) hides by default, which OSFMount does not. For example, the Master File Table (MFT) file $MFT is not visible during a mount, but FTK shows the file. Also, OSFMount does not show files that have been deleted like FTK.

﻿

NOTE: Trainees are not expected to perform the following Mount or FTK Methods. These are performed in the labs later in the lesson.

﻿

Mount Method
﻿

OSFMount requires the path to the forensic image to be able to access the files within it.

﻿

1. Select Mount new, browse to the forensic image, and select Next.

﻿
![image](https://github.com/user-attachments/assets/e19b014b-f943-4e65-983b-887320d7ab94)

2. Select the Windows partition. The Windows partition is typically the largest. In this case, it is Partition #1 and is 58.91GB in size.


![image](https://github.com/user-attachments/assets/3fb42c6c-3029-4b2d-be8a-29a90c9a9e87)


3. Do not make any changes and select Next.


NOTE: OSFMount skips Step 3; the steps go from Step 2 straight to Step 4.

![image](https://github.com/user-attachments/assets/811a0d87-8685-472e-8138-867da414a8d4)

4. Select Mount. OSFMount shows the drive letter assigned to the forensic image. Afterward, browse the log directory F:\Windows\System32\winevt\Logs with Windows Explorer to access the event logs. Copy the files of interest out of the image and stored on the local disk.

![image](https://github.com/user-attachments/assets/4f3968d9-e725-4717-aed8-0cd31a031864)


FTK Method


1. Open AccessData FTK Imager. User Access Control (UAC) appears as this application is being run with administrative privileges. Select Yes.


2. Select Add Evidence > Image File > Next.

![image](https://github.com/user-attachments/assets/bf34fc3c-4b65-4b81-9b76-03de8732a33e)

3. Enter the source path to the forensic image.


![image](https://github.com/user-attachments/assets/984bd483-3ea8-4000-ad81-8807fc643caa)

4. Expand the forensic image by selecting the plus sign (+) next to the image name. Continue expanding until Windows\System32\winevt\Logs is displayed.


![image](https://github.com/user-attachments/assets/0b50d4df-f6c0-4bf7-aa44-2e30d920c68a)


![image](https://github.com/user-attachments/assets/40351e9f-c002-4a88-91d2-c0be2c96b060)

5. Select the log files of interest, right-click and select Export Files, and save the files on the local disk.

![image](https://github.com/user-attachments/assets/e464d46c-82cd-48f6-95cf-a7d809f4f2df)

Another tool, Evtxtract, extracts event logs directly from a forensic image using Python, which is discussed later. The most common method is to use FTK to view the forensic image.


--------------

Tools
The Windows event logs have been extracted from a system and need to be analyzed. Windows event logs are stored in a binary format and require specific tools for them to be read. Prior to Windows Vista, event logs had the file extension .evt. Every version of Windows from Vista to Windows 11 uses the .evtx format. Occasionally Windows Event Viewer requests converting older EVT-formatted event logs to EVTX when analyzing the older format on a current version of Windows. If necessary, the older EVT format can be converted to EVTX using the built-in wevtutil utility. Sample syntax is as follows:

wevtutil export-log <sourcelogfile>.evt <targetlogfile>.evtx /lf 
﻿

The following tools are the most commonly used in the industry and are publicly available for free:

Windows Event Viewer
F-Secure’s Chainsaw
Eric Zimmerman’s EvtxECmd
William Ballenthin’s Python modules evtxtract and python-evtx
﻿

Windows Event Viewer
﻿

The Windows Event Viewer is the default viewer that ships with all versions of Windows. It allows for filtering by event ID, searching for text within the event logs, sorting, and cleanly displaying all information with column headings. The drawback is that it only allows for one event log to be viewed at a time and does not have any additional logic to assist with finding suspicious activity.


![image](https://github.com/user-attachments/assets/8dc94c11-cbae-45f4-9475-a5cf15925cb5)


Chainsaw


Chainsaw was created by the Finnish cyber security company F-Secure. Chainsaw has built-in logic with mapping files written in YAML that can quickly extract items that match custom rules and display them to the analyst. Chainsaw saves cyber defenders hours by analyzing all available event logs at once and generates a report. Chainsaw also dumps all events pertaining to a specific event ID if that is preferred.


Syntax


Search all event logs for activity that matches rules:
chainsaw.exe hunt C:\windows\System32\winevt\Logs -r sigma_rules/ -m mapping_files/sigma-mapping.yml --lateral-all --ignore-errors



Dump all logon events:
chainsaw.exe search C:\windows\System32\winevt\Logs\ -e 4624 –output 4624_events.txt


![image](https://github.com/user-attachments/assets/25a89825-571d-4c2b-a6ec-9a9377fd3ff7)


EvtxECmd


EVTX Explorer (EvtxECmd) was written by Eric Zimmerman at Kroll who also wrote Kroll Artifact Parser and Extractor (KAPE), which is a widely used forensic toolkit. EvtxECmd processes a large number of event logs at once. It has a list of indicators, similar to Chainsaw, that it looks for and writes the most significant events into a spreadsheet for an analyst to review.


Syntax
EvtxECmd.exe -f C:\Windows\System32\winevt\Logs\ --csv "C:\Users\Trainee\Desktop" --csvf MyOutputFile.csv


![image](https://github.com/user-attachments/assets/2cd8ed82-3bd3-4102-8ca5-409204bfced3)

![image](https://github.com/user-attachments/assets/9d6cce31-8e26-49cd-b480-bf01f6408b27)



Python Modules


Willi Ballenthin from Mandiant wrote two Python tools to extract Windows event logs. The module python-evtx is a module that can be imported into Python scripts to convert the binary format that event logs are stored in and output the logs into Extensible Markup Language (XML) or text. Ballenthin also wrote a tool called EvtXtract that carves event logs from a forensic image based on the header of event log files.


Syntax for Evtxtract
"C:\Program Files\Python310\Scripts\evtxtract.exe" E:\winserv.001 > E:\eventlogs\evtx.xml



The python-evtx module requires a script to be written that uses the module before parsing the logs. This is used if there is a need to parse a large number of logs and if only a select few fields need to be exported from a log. This module allows for customization but overall requires the most setup when compared to the other options available.


------------------


Event IDs
This lesson has covered how to extract event logs and access their contents, but to make sense of them, event IDs need to be understood to filter event logs for specific events. There are hundreds of events in each event log file. Microsoft attempts to categorize activity and place it into its own file to limit file sizes and make it easier to find events. Note that some events are in multiple event log files. For example, when a new process is created on the system, the Security event log records it as event ID 4688, whereas Sysmon records it as event ID 1. Table 16.3-1 is a short list of the most common event IDs and logs.

![image](https://github.com/user-attachments/assets/4ec8c949-cb03-415b-82db-7c08fc7a8665)



------------

Deleted Logs
Attackers commonly delete, clear, or overwrite event logs in an attempt to cover their tracks. Depending on the method used by the attacker to perform these actions, it may be possible to recover the deleted event logs. Within FTK, any non-securely deleted file is prefaced with a red X icon before its filename. Armed with this knowledge, it is possible to browse through a forensic image and to look for event logs in the C:\Windows\System32\winevt\Logs directory and the C:\$Recycle.Bin directory to look for deleted files. Once found, right-click on the file of interest, select Export File, and save the file to the local disk. The event log can then be opened by any of the tools previously mentioned.

﻿

The $Recycle.Bin directory contains files that were deleted but were not overwritten. To access this location in FTK, the path is [root]/$Recycle.Bin and the Security Identifier (SID) of the user account that deleted the files. In this case, it is the Administrator account shown here as:

S-1-5-21-3227957547-616921804-3487276839-500
﻿

Within the specific SID directory, there are many deleted event logs present. The names of the files have been changed, but by selecting one of the files and looking at the hex view below the file, it can be seen that the $R513JPG.evtx file is actually the Microsoft-Windows-WMI-Activity%40Operational.evtx event log.


![image](https://github.com/user-attachments/assets/98eaeb1a-782c-478c-9ec2-9e3fbe0a634c)
![image](https://github.com/user-attachments/assets/e39cf0ed-af86-41b5-8eac-3321e484aa59)


-------------

Accessing Windows Event Logs
Scenario
﻿

There is potentially Malicious Cyberspace Activity (MCA) on a Windows server within the network. Events in Elasticsearch correlate to the time of the activity. The server has been taken offline and the associated forensic image has been collected for analysis. The time of the suspicious activity begins on May 26, 2022 @ 16:08:00 and ends on May 26, 2022 @ 16:18:00.

﻿

Workflow
﻿

1. Log in to the win-hunt Virtual Machine (VM) using the following credentials: 

Username: trainee
Password: CyberTraining1!
﻿

2. Open Chrome and select Discover - Elastic.

![image](https://github.com/user-attachments/assets/ba921ac7-7911-461a-a3c9-e9172c0505d8)

3. Select Advanced and Proceed to 199.63.64.92 (unsafe) on the Your connection is not private page.


4. Log in to Elastic using the following credentials
Username: trainee@jdmss.lan
Password: CyberTraining1!



5. Set the Kibana filter dates to:
Start date: May 26, 2022 @ 16:08:00.000End date: May 26, 2022 @ 16:18:00.000


![image](https://github.com/user-attachments/assets/c042d68f-9d52-4f09-8d91-17c2f6852737)


6. Query for the hostname of the device being analyzed to filter the logs:
agent.name:dc01



7. Change the view filter to only see the Windows event logs. In the search box, enter the following:
event.module


![image](https://github.com/user-attachments/assets/9e7d61b4-5573-46fc-b0a9-373b47fc193b)


8. Hover the mouse over the right corner of the Popular box and select Add field as a column. 


![image](https://github.com/user-attachments/assets/cf70b3ee-e63a-482e-95d4-6c5e5337fe03)

9. In the Search field names box, search for the following filters and add them as columns:
event.provider

winlog.channel

winlog.event_id

![image](https://github.com/user-attachments/assets/f7c207e8-8410-491b-b2b5-626dff057402)

NOTE: The winlog.event_id shows a warning icon, which is not a concern. The lab works properly regardless.


It is time to correlate what is available in Elastic to what is in the forensic image. 


10. Minimize Chrome and open AccessData FTK Imager. User Access Control (UAC) appears as this application is being run with administrative privileges. Select Yes.


11. Add the forensic image E:\winserv.001 into FTK Imager.

![image](https://github.com/user-attachments/assets/c093fdcf-f6a4-4c37-ad7a-042cfc0aaafc)


![image](https://github.com/user-attachments/assets/0d04540a-adc0-42c2-93f9-29e29c5ac870)


12. Expand winserv.001 to Partition 2/Windows [NTFS]/[root]/Windows/System32/winevt/Logs.

![image](https://github.com/user-attachments/assets/e2a8335e-b3ea-4c52-b534-a165950121bf)


![image](https://github.com/user-attachments/assets/ffe4ed95-8703-4188-8584-dd5d110ff664)


13. Locate the following logs in the Logs directory as they were present in Elastic:
System

Security

Microsoft-Windows-Sysmon%4Operational.evt

xMicrosoft-Windows-WMI-Activity%4Operational

Microsoft-Windows-TaskScheduler%4Operational

Microsoft-Windows-PowerShell%4Operational


Notice that those specific event logs are not present in the forensic image. This shows a potential Indicator of Compromise (IOC); the attacker attempted to cover their tracks. It also shows the importance of sending logs to Elastic before they are cleared locally.

![image](https://github.com/user-attachments/assets/19d7db0c-ffb1-488e-82f4-a143884b450a)


-----------------------

Recovering Deleted Event Logs
This lab is focused on recovering the five event logs that were identified as deleted in the previous lab. It also covers analyzing those event logs to understand the activity that took place on the forensic image that is being investigated.

﻿

Workflow
﻿

1. Log in to the win-hunt VM using the following credentials: 

Username: trainee
Password: CyberTraining1!
﻿

2. Load the winserv.001 image located on the E:\ drive into FTK Imager.

﻿

The administrator account is the focus. His SID is S-1-5-21-3227957547-616921804-3487276839-500. All deleted event logs end up in that user account Recycle Bin.

﻿

3. Expand the directory tree down to winserv.001/Partition 2/Windows [NTFS]/[root]/$Recycle.Bin/S-1-5-21-3227957547-616921804-3487276839-500. 

﻿

4. Extract the six files listed below by holding CTRL and selecting each.

$RJWWJQK.evtx 131,076 (Security)

$R513JPG.evtx 1,028   (WMI-Activity)

$RYT30BW.evtx 8,260  (Task Scheduler)

$RA714GE.evtx 5,188   (Sysmon)

$RQXN6M8.evtx 15,364  (Powershell)

$R2DJFWL.evtx 14,404  (System)

﻿

The original filenames can be found within FTK by selecting the filename and viewing the hex content in the viewer below the filename.

﻿![image](https://github.com/user-attachments/assets/88675f7a-76f7-413c-84cc-03a46c0072d5)

5. Right-click and choose Export. Save the files to the desktop.


6. Open Event Viewer from the Windows icon by entering Event Viewer and selecting Event Viewer.

![image](https://github.com/user-attachments/assets/960629a0-66f2-4472-b8b1-7a9b0f7c4b73)

7. Select Action > Open Saved Log and add each exported log.


![image](https://github.com/user-attachments/assets/a5ef6db5-6fa4-4850-ac2e-ade55f24eeca)

NOTE: While outside the lab scope, it is worth noting that during an investigation of the event logs, an external tool such as Chainsaw or EvtxECmd is typically used rather than trying to open and search each event log individually.


8. Select $RJWWJQK.evtx. Select Action > Filter Current Log. In the new window, select Logged and Custom Range. In both the From and To drop-down menus, select Events On and choose the dates and times as shown in Figure 16.3-28.

![image](https://github.com/user-attachments/assets/a02575b0-29f7-4a1d-9f75-32c931eab5d2)



9. Open the log $RJWWJQK.evtx (Security.evtx), which shows users that recently attempted to log in to the system. Searching for the recent users on the system is the first thread to pull to know where to look next for additional details. Look for suspicious activity such as a few sequential failed logins followed by a successful one. The successful login provides a timestamp used as a reference point for the events that took place afterward. The event IDs for this type of activity are 4624 and 4625.


NOTE: Ignore the logins from the user trainee as this account is not associated with malicious behavior.


10. Select Action > Filter Current Log. There is a textbox that contains <All Event IDs>. Replace the text with the following and select OK to close the window:
4624,4625



11. Locate the two events where the usernames defaultuser and bob have failed logins followed by a successful login by the administrator account. This is typical of a password spraying attempt followed by the actor eventually finding a successful username/password combination. Focus on the time range of May 26, 2022 from 16:09:21 to 16:17:30.


The next step focuses on investigating suspicious activity that occurred once the actor obtained access to the host.


12. Investigate the following logs and event IDs:


$R2DJFWL.evtx log (System.evtx) and event ID 7045: Indicates a new service was created.


$RA714GE.evtx (Sysmon.evtx) and event ID 11: Indicates a new file being created.


$RYT30BW.evtx (Microsoft-Windows-TaskScheduler%4Operational.evtx) and event ID 129: Indicates a new task being created/registered


$RQXN6M8.evtx (Microsoft-Windows-PowerShell%4Operational.evtx) and event ID 24577: Indicates that a PowerShell script was executed from within the Integrated Scripting Engine (ISE) editor.


$R513JPG.evtx (Microsoft-Windows-WMI-Activity%4Operational.evtx) and event ID 5861: Indicates recent WMI subscriptions.


![image](https://github.com/user-attachments/assets/8419ecfc-d4a1-49d8-8cf0-a17548044e27)


-------------

### CDAH-M17L1-Analyzing Slack Space ###


Introduction to Slack Space
File Systems
﻿

Storage devices such as hard drives that are formatted with New Technology File System (NTFS) for Windows devices or fourth extended filesystem (ext4) for Linux devices, have clusters also known as blocks. Clusters are the smallest item on a disk that contains contiguous sectors that can be allocated to store files.

![image](https://github.com/user-attachments/assets/6ba7d58f-1403-4b09-ba30-5a96227e4872)

The default size of each cluster within these file systems is 4096 bytes (B) or 4 kilobytes (KB). One kilobyte is equal to 1000 bytes in the decimal number system according to the International System of Units (SI). In computing, however, kilobytes use the binary number system instead of decimal. Kilobytes are referred to as kibibytes in binary and are 1024 bytes in size. This is important because the block sizes are all measured in binary format, but almost all public documentation regarding disk space refers to kilobytes instead of kibibytes where a kilobyte is 1000 bytes and a kibibyte is 1024 bytes. A way to think of it is that kilobytes are the logical size, and the kibibyte of 1024 bytes is the physical size on the disk. The table below shows the values of disk sizes and the comparison between the decimal and binary numbering systems.


![image](https://github.com/user-attachments/assets/8daf07c2-1854-4677-bf39-b8014a0aac55)


The cluster size varies depending on the size of the hard drive. For example, as shown in the table below regarding NTFS, the cluster size increases depending on the hard disk size. The table below illustrates the cluster size relative to the volume/disk size. Each file that is written to disk uses the available 4096B (4KB * 1024) to store its data and runs over into another 4096B block if there isn’t enough space in the first block to hold the entire file.


Each file written to disk is assigned an index node (inode) number that is tracked by the file system. The files are stored within blocks/clusters that are also numbered, which enables the file system to quickly locate where the file is on the disk to be able to quickly access the file when it is in use. For example, the block that holds a file could be numbered as 2049, but the inode of a file stored on the block could be 12. They are just numbers used by the filesystem to locate and read the files and have nothing to do with file size. This is demonstrated later in the labs using the tool Autopsy.

![image](https://github.com/user-attachments/assets/d229fb46-f2bd-4be5-9349-4d49f639ecac)


Solid State Drives (SSD) and Hard Disk Drives (HDD) each approach handling slack space differently. SSDs perform wear leveling, as well as garbage collection using a command known as TRIM. These actions are automatically performed by the SSD controller and do not require a manual process started by a user.


The purpose of wear leveling is to ensure that data is written across a disk evenly as opposed to being written in the same set of blocks, which could cause those sections of the disk to wear out and lead the disk to fail. TRIM is used to clean up deleted files by overwriting them to allow for quicker access the next time a file needs to be written to disk. Traditionally on an HDD that does not have TRIM, the area where a new file is to be written needs to be overwritten first, which may not seem like much, but which takes time. SSDs have optimized the action, which leads them to be faster than HDDs. Since SSDs are always performing these actions as they read, write and delete files, they are overwriting and removing slack space from the disk. It is unlikely that the slack space of a file on an SSD would be there for a long time before it would be overwritten. The takeaway is that if an SSD is the source of an investigation, there probably is not any slack space to investigate, but if the image is from an HDD, there is potentially some slack space available.


Slack Space


Disks have three types of space:
Unallocated
Allocated
Slack


Unallocated space is also known as free space. When a file is deleted from the file system, the space becomes unallocated. Allocated space is space that is being used by files on the disk. Slack space is any space that has been allocated due to the size of a cluster, but is not being used by the file that precedes it. If a file is smaller than the size of a cluster, then a section of unused space exists on the disk between the end of the file data and the end of its clusters. For instance, if a text document stored in /home/trainee/file.txt is 7.5KB in size, it takes up 7680B across two blocks and leaves room for 512B of available slack space. The math here is that 7.5KB * 1024 = 7680B and two blocks is 4096B * 2 = 8192B. Subtracting 7680B from 8192B returns 512B of slack space. Figure 17.1-2 illustrates slack space.



![image](https://github.com/user-attachments/assets/abcbe099-b399-4761-be3e-4079f5b6aeb0)


Slack space can contain chunks of previously deleted files that haven’t been overwritten yet or can contain data purposefully hidden there. If a file grows in size or is securely deleted, then the data stored in slack space is overwritten and is no longer accessible. Therefore, slack space is not a reliable place to store information. 


Tools for Reading/Writing Slack Space


Autopsy


Autopsy provides a view of slack space within a forensic image. The Windows version of Autopsy displays all areas of a forensic image that contain slack space by prefacing filenames with -slack. This is an option that needs to be enabled. The Linux version of Autopsy does not have this option, but the hex editor view of a forensic image can see the slack space contents of files. The image below shows an example of Autopsy on Windows and how it labels and identifies files that have slack space.

![image](https://github.com/user-attachments/assets/8b3d94f2-ccc6-4254-af9d-df9eac1a73d8)


Blkls


The command blkls stands for “block list” and is part of The Sleuth Kit (TSK) and can dump the strings of all allocated, unallocated and slack space data found in a forensic image. It is useful for discovering if there is any data hidden in slack space and can then be used in combination with Autopsy by performing a keyword search to find out which file is closest to the slack space.


The command line for reading the contents of slack space with blkls:
blkls -s diskimage.dd



Bmap


Bmap is a Linux tool for reading and writing to and from slack space. The tool was written in 2000, but a variant of it is available on GitHub. This is the type of tool that an attacker would use to hide data within slack space. An example command in Linux to store data in slack space is shown below:
echo "data to be hidden in slack space" |bmap --putslack filename.txt



Slacker


Slacker is an open-source tool available on GitHub and allows for writing and reading from slack space on both Windows and Linux.


Syntax of slacker.exe syntax in Windows:
Slacker.exe -s [file containing data to hide] [filename with available slack space]



Syntax of slacker.sh in Linux:
sudo ./slacker.sh embed [filename with available slack space] [data]



Python


Python can perform both reading and writing of slack space. It is not as easy as Slacker. To be able to use Python, a lot of work has to be done on identifying which file is going to be used, determining the inode of that file and the amount of space that is free at the end of the file. Once all of that is sorted out, it uses the seek, read, and write commands to make changes to the filesystem.

![image](https://github.com/user-attachments/assets/51edd2f5-6d50-4807-9f62-0b9c8bc445a7)


------------

Viewing Slack Data
This lab below demonstrates the process of adding a forensic image into Autopsy and shows how to view slack space within the tool.

﻿

Workflow
﻿

1. Log in to the ubuntu20 VM.

Username: trainee
Password: CyberTraining1!
﻿


2. Open a terminal.

﻿

3.  To start Autopsy, run the following command and enter the trainee password when prompted:

sudo autopsy
﻿

4. Open Autopsy by right-clicking on the Uniform Resource Locator (URL) link and selecting Open Link, as shown in the image below:


![image](https://github.com/user-attachments/assets/3596b605-3df7-4452-a1a6-68841fb480d4)




5. Add a forensic image to analyze in Autopsy by selecting New Case


![image](https://github.com/user-attachments/assets/4a34f370-090a-4d7f-9488-105cd5c987e1)


6. Enter the case name slackspace-analysis and select New Case.

![image](https://github.com/user-attachments/assets/e517a7f8-8ac0-472b-9ff7-f2504a2483cb)

The image being analyzed needs to be named and added to the case. Usually, this would be the host name of a system.


7. Select Add Host to continue

![image](https://github.com/user-attachments/assets/d87635d7-9d02-473a-9c50-11c1240d6d1b)

8. Keep the default selections and select Add Host


![image](https://github.com/user-attachments/assets/b144ec47-866c-4c29-98bf-9fe7f0371496)

9. Select Add Image to continue.


![image](https://github.com/user-attachments/assets/b0a9ad2f-23f9-4a80-be9b-9239919265d3)


10. Select Add Image File.

![image](https://github.com/user-attachments/assets/b90143cf-fb33-4596-9017-4cad43a823a6)

11. In the window Add a New Image, use the following values, and select Next:

Location: /home/trainee/Desktop/suspicious-mod.dd.sda1

Type: Partition

Import Method: Symlink


![image](https://github.com/user-attachments/assets/8e1f26d0-c58d-4051-bc55-807ac593f34d)


12. In the next window, use the default settings and select Add.


![image](https://github.com/user-attachments/assets/61300600-bd86-410f-91bb-04021cd837c5)

13. The screen below shows an image that was loaded successfully. Select OK to continue.


![image](https://github.com/user-attachments/assets/8cf741fc-6c5a-44d6-98a0-b2db80c4c4ad)


14. To view the contents of the image file, select Analyze, as shown below:


![image](https://github.com/user-attachments/assets/9fe11aa0-4612-4d86-adf3-a4775985e1f2)


15. Select File Analysis.


![image](https://github.com/user-attachments/assets/d94b2fa5-ef19-4488-84d6-8e9cbd5fcc2c)

In this view, all the files that are present in the image can be accessed by selecting their filename.


16. Select the file named suspicious-file.txt. In the bottom pane, the contents of the file are displayed.



![image](https://github.com/user-attachments/assets/5ce58ab2-a57f-4052-ba38-8cca64ee4aa7)


17. To view the slack space contents that are not being displayed, select inode 12 on the far right (same line as suspicious-file.txt).


18. Scroll down and select block 2049 to view the raw content hidden in the available space after the file.



![image](https://github.com/user-attachments/assets/3f49bc50-dcc9-459d-b094-44064fe47620)


![image](https://github.com/user-attachments/assets/4624e35f-9fa3-4153-b231-7eced8116e6d)


![image](https://github.com/user-attachments/assets/221896ef-aa8b-4151-9a69-d0a3ac66dcd1)

---------------

Searching Through Slack Space
This second lab focuses on using Autopsy’s keyword search tool to determine where in a forensic image the already identified slack space is located so that it can later on be exported.

﻿

Workflow
﻿

1. Log in to the ubuntu20 VM with the following credentials, if necessary.

Username: trainee
Password: CyberTraining1!
﻿

2. Open a terminal and change directory to the trainee desktop:

cd ~/Desktop
﻿

3. Enter the following command to view all items in slack space using blkls:

blkls -s suspicious-mod.dd.sda1
﻿

Part of the output from step 3 will be used in step 5, below. 

﻿

4. Return to the Autopsy window that was opened in the previous lab and select Keyword Search at the top.


﻿

5. In the search field, enter any set of characters from the output in step 3, for example "h.i.d.d.e.n," then select Search.

﻿

6. Select Ascii and review the result in the right pane, as indicated in the image below:



![image](https://github.com/user-attachments/assets/3b178b46-7bf5-4ed8-b9fe-49f6dd007527)


![image](https://github.com/user-attachments/assets/02a0915d-df84-4c50-9865-feb441f4e1d2)


----------

Exporting Slack Space Content
This lab demonstrates how to export data that has been identified as residing in slack space.

﻿

Workflow
﻿

1. Log in to the ubuntu20 VM with the following credentials, if necessary.

Username: trainee
Password: CyberTraining1!
﻿

2. Return to the Autopsy window that was opened in the previous lab and select File Analysis from the menu at the top.

﻿

3. Open the item that has slack space by selecting 12 on the far right under the Meta column.

﻿

4. Scroll to the bottom and select 2049.

﻿

5. Select Export Contents and make a note of the filename, as shown in the image below:



![image](https://github.com/user-attachments/assets/e1ecf9ea-971e-40d3-bca0-c33c4bd2d071)


6. In a terminal window, read the file that was just downloaded to see that the contents of slack space were exported successfully:
cat /home/trainee/Downloads/vol1-Fragment2049.raw


![image](https://github.com/user-attachments/assets/f365cea0-38b4-4e19-a287-e1127ccd1b71)

-------------------

### CDAH-M17L2-Bootkits ###

MBR Fundamentals
The Boot Process
﻿

Figure 17.2-1 illustrates the generic boot process. This process starts with the Basic Input/Output System (BIOS) loading the MBR during the PC boot. The master boot code locates the active partition of the drive. This partition is known as either the Volume Boot Record (VBR) or the first stage bootloader. The active partition then activates the second stage bootloader and runs the respective bootloader for the installed Operating System (OS) kernel. 

﻿

![image](https://github.com/user-attachments/assets/e79e669a-b082-4e18-a43c-c7ca8dc3ad0b)


Common bootloaders for the various operating systems are listed in Table 17.2-1, below:



![image](https://github.com/user-attachments/assets/4159b60f-c676-4592-8486-8e0c250abcca)

Unified Extensible Firmware Interface (UEFI)


This lesson focuses on the traditional BIOS/MBR boot process described above. However, another option, UEFI, offers better security in modern systems, so it is worth introducing briefly. 


UEFI is a modern mechanism for preventing unauthorized code from executing prior to the boot process. The primary component is the GUID Partition Table (GPT), which replaces the MBR in the boot process. The GPT is responsible for validating the firmware prior to executing the bootloader. If a bootkit is successful in bypassing the firmware validation, the security mechanisms provided by UEFI are rendered useless.


Even with UEFI available, modern computers still support the traditional boot process. The rest of this lesson focuses on the older MBR format for the traditional process. 


The MBR Layout


The MBR is the section of the hard disk that contains the location of the bootloader for the primary OS. Figure 17.2-2, below, illustrates the layout of the MBR, which comprises the following sections:
Master Boot Code (MBC): Contains the first 446 bytes of the MBR (starting with 0). This section locates the OS bootloader within the disk partition table. 
Disk Partition Table: Contains four partitions that each contain 16 bytes, for a total of 64 bytes in the table. Each functioning partition table ends with 0x55AA.
Signature: Contains the "magic number" that indicates that the MBR checksum is valid. This must provide a value of 0x55AA. Any other value indicates the MBR may be corrupt, infected by malware, or unbootable.



![image](https://github.com/user-attachments/assets/60052ace-6c3c-466e-a6a5-fb633a8f9246)


Partition Table Analysis


The partition table starts at byte offset 446 (0x1BE) and continues until byte offset 510 (0x1FE). The partition table entry contains information about the partition boot status, format, its physical location on the drive, and its size. Table 17.2-2, below, displays the byte values of the partition table entries.


![image](https://github.com/user-attachments/assets/c57cd162-c0e9-4f1e-9160-516a59f5ab34)


Methods of MBR Analysis


The information presented above in Table 17.2-2 can be collected and analyzed using a variety of tools, both command line and graphical. On Linux, command line tools such as strings or xxd extract human-readable data from the forensic disk image to include the MBR. The human-readable output of these tools allows a trained analyst to conduct a visual inspection of the data. On Windows, graphical applications such as Autopsy or the Forensic Tool Kit (FTK) analyze a disk image and MBR. These tools provide the most effective methods, but any application that displays the contents of a forensic disk image is also sufficient.


![image](https://github.com/user-attachments/assets/090f5b2e-5c64-4262-8673-d7e40c52222d)

![image](https://github.com/user-attachments/assets/9a61c438-6b9c-4071-8737-334e258d0c21)

![image](https://github.com/user-attachments/assets/2db27a0a-801d-4486-a0bb-7985092e1469)


--------------------



Analyzing Local Disk MBR
Bootkits
﻿

A bootkit is a bootable type of malware that modifies the standard boot process. The common goal for most bootkits is to bypass OS signature validation so that other malware can be installed without bringing attention to the user. Bootkits work below the operating system layer by infecting the Master Boot Record (MBR) or Globally Unique Identifier Partition Table (GPT). Installation typically involves overwriting the portion of the boot code responsible for executing the OS bootloader.

﻿

Bootkits are a type of rootkit. A rootkit is any malware that modifies a running OS. An example of a rootkit modification is hiding network connections and processes. Rootkits may also create hidden directories and entire file systems. Detecting a bootkit is significantly more difficult than detecting a rootkit infection. As an example, when performing dynamic analysis of a bootkit, the PC may not boot at all. Static analysis allows analysts to view the MBR using tools such as FTK Imager on Windows, or by using the Linux utility dd to carve out the MBR for inspection.

﻿

The MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK®) framework identifies bootkits as a pre-OS boot technique with technique ID T1542.003. 

﻿

Analyze a Local Disk MBR
﻿

Load disk images for MBR analysis and pull out various information about the MBR. Observe features of an uninfected MBR.

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) win-hunt with the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Start the application FTK Imager by selecting it from the Windows Start menu.

﻿

3. Load the local disk image by selecting Add All Attached Devices in the File menu.

﻿

FTK Imager loads the physical drive and any logical drives that it detects. 

﻿

4. Load the bottom right pane with the hex dump of the disk image selected by selecting the drive \\.\PHYSICALDRIVE0 from the Evidence Tree pane.

﻿

Figure 17.2-4, below, displays the ASCII hex dump of the MBR.



![image](https://github.com/user-attachments/assets/9f11d6cb-d283-4dd6-8cf0-aac04732ebd2)

![image](https://github.com/user-attachments/assets/55b1e546-b887-4ee9-8f34-e45cf81c9d73)


------------------

Analyze Disk Image MBR
In most cases, an analyst conducting a forensic investigation may uncover a bootkit unintentionally, while analyzing an image with another type of malware, such as ransomware. While it is difficult to definitively claim there is a bootkit in the following lab, it is still worthwhile to identify the differences between the forensic disk image and a clean MBR. For bootkit detections, the more experience an analyst has with viewing MBRs, the more familiar they will be with identifying entries that are out of the ordinary.

﻿

﻿

Analyze the MBR of a Disk Image
﻿

Load a forensic disk image that contains a bootkit. Compare features of the bootkit-infected MBR with the clean MBR from the previous lab. Continue working in the VM win-hunt to complete the following lab. 

﻿

Workflow
﻿

1. Open a second instance of FTK Imager from the Windows Start menu.﻿﻿

﻿

2. Add the image bootkit.bin as an evidence item by navigating to File and selecting Add Evidence Item…﻿

﻿

3. In the window Select Source, select Image File, then select Next. 

﻿

4. On the page Select File, select Browse, then select the file bootkit.bin on the desktop at the path C:\Users|trainee\Desktop\bootkit.bin﻿

﻿

5. Load the bootkit image into the Evidence Tree by selecting Finish.

﻿

The boot code section of the local disk image from the previous lab and the infected disk image from this lab have different sizes. The boot code section of the local disk image stops at offset 0x1BD with no padding. Although the infected disk image also stops at offset 0x1BD, it has 58 bytes of 0x00 padding to ensure that the MBR checksum remains valid. Figure 17.2-5, below, displays the values of offset 0x1FE and 0x1FF.


![image](https://github.com/user-attachments/assets/4cc660ea-5bd9-4301-af7f-f7d54ee13764)


![image](https://github.com/user-attachments/assets/446ac8b7-4d6b-4f35-a6b3-f11912b55dfa)

-------------

More Bootkit Detection Methods
FTK is a great tool for analyzing disk images, but an analyst should not limit themselves to only one capability. Many different tools are also available to effectively discover information from forensic disk images. The following labs introduce two additional options. The first option uses the Linux command line while the second option uses the Windows application Autopsy.

﻿

Analyze with Linux Command Line
﻿

Use the Linux command line to analyze a disk image. 

﻿

﻿
Workflow
﻿

1. Log in to the VM sift using the following credentials:

Username: sansforensics
Password: forensics
﻿

2. Open a terminal window and change the directory to the desktop by entering the following command:

cd Desktop
﻿

3. Use the command xxd to dump the hex values from bootkit.bin to the terminal screen by entering the following command:

xxd bootkit.bin
﻿

﻿

Detect with Autopsy
﻿

Use the tool Autopsy to detect a bootkit. 

﻿

Workflow
﻿

1. Log in to the VM win-hunt with the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Start the application Autopsy 4.19.3 by selecting it from the Windows Start menu.

﻿

3. Create a new case by selecting New Case in the Welcome window.

﻿

4. Define the case settings as follows:

Case Name: Bootkit-Lab
Base Directory: (leave default)
5. Select Next and enter the following information in their respective fields:

Case Number: 12345
Examiner Name: trainee
6. Initialize the database by selecting Finish.

﻿

The dialog window Add Data Source opens after the database finishes initializing.

﻿

7. Select Next in the dialog window and leave the default values as they are.

﻿

8. Select Disk Image or VM File, then select Next.

﻿

9. Use the Browse field to navigate to and select the file bootkit.bin from the Desktop, then select Next.

﻿

10. Select Next and leave the default values as they are.

﻿

NOTE: Autopsy displays an error message after this step. This is expected.

﻿

11. Select Finish to view the new case Bootkit-Lab.

﻿

12. In the Listing pane, double-click bootkit.bin_1 Host, then select the image bootkit.bin. 

﻿

This presents the hex dump in the bottom pane, as displayed in Figure 17.2-6, below:



![image](https://github.com/user-attachments/assets/795935a5-a32f-44c6-af83-a547d8abf47f)


![image](https://github.com/user-attachments/assets/90bfbbda-51f8-4134-a0be-defaf095fee8)


--------------

### CDAH-M17L3-Building a Timeline ###


Timeline Overview
A timeline is a list of events that occurred on a system and the times that they occurred. During a forensic examination, a timeline can be the most valuable tool available to an analyst due to the number of files involved and their organization within the forensic image. A forensic image may comprise thousands of files. In addition, Operating Systems (OS) do not store data in a structure well organized by date; instead, folders and files are nested within other folders. A timeline is helpful when a particular date or time is known or suspected to be associated with malicious activity, as it can filter an entire forensic image to just a few events based on the time range of interest. This greatly reduces the time required for analysis. For example, if 2022-01-01 12:00:00 is the determined date of suspicious activity, a timeline can show all files and events that were created, modified, or deleted at that time across the entire forensic image. Such a focus helps the analyst more efficiently determine the actions of the malicious actor.

﻿

Timeline Types
﻿

Two types of timelines are available during a forensic investigation:

Forensic timeline: A file that contains all dates and actions that occurred within an entire forensic image.
Analysis timeline: The cumulative result of analysis; it includes each important finding, to be used in a forensic report or to illustrate the process of events that occurred. 
﻿Table 17.3-1 provides an example of an analysis timeline:


![image](https://github.com/user-attachments/assets/b09e3f12-b1d9-4dfd-8348-497a69ca406e)

Tools for Creating Timelines
Manually creating a timeline can be quite time consuming, but tools are available that create timelines automatically with supplied parameters. Examples of such tools are Autopsy, KAPE, and Plaso. Plaso is the industry standard for creating forensic timelines, and, in fact, Autopsy and KAPE both require a Plaso plug-in that enables them to automatically create a timeline.

﻿

Autopsy
﻿

The forensic tool Autopsy is available for both Windows and Linux, but its functions differ between the two OSs. The Windows version of Autopsy creates a timeline as part of its ingestion and analysis whenever a forensic image is added into the tool; the Linux version does not. 

﻿

﻿

KAPE
﻿

The forensic tool KAPE runs only on Windows. It can create a timeline from a Windows host in fewer than 5 minutes when it is focused only on the Master File Table (MFT), registry files, and event logs.

﻿

﻿

Plaso
﻿

As stated earlier, Plaso, formerly called log2timeline, is the industry standard for creating timelines of forensic images. Plaso supports analysis of Windows, Linux, macOS, Android, and iOS forensic images. Plaso can parse many files that typically require additional tools to be read. For example, Plaso can read Windows Event Logs, registry files, databases, volume shadow copies, and MFTs. Plaso reads all these files; extracts the metadata of files, dates, and times of events that have occurred; places the output into a .plaso file; and creates a Comma-Separated Values (CSV) file. Plaso is installed on the SIFT Workstation, a collection of incident response and forensic tools, by default. 

﻿

Table 17.3-2 provides descriptions of Plaso’s three main command-line tools, pinfo.py, psteal.py, and psort.py:



![image](https://github.com/user-attachments/assets/adeb7fb1-22ec-422a-96cc-4b73a28ddae4)


The following command creates a timeline from Plaso:
psteal.py --source image.raw -o dynamic -w timeline.csv



The .plaso file is a Structured Query Language (SQL) database that contains more details than the resulting CSV file and, like the CSV file, can be loaded into other tools, including Timesketch, Splunk, Elastic, or any queryable tool, for analysis. However, because the .plaso file is generally larger than the CSV file and may require an hour or more to be indexed (depending on its size), the recommendation is to ingest the CSV file instead. 


Even though CSV files are typically smaller than their corresponding .plaso files, they are often too large to be opened by spreadsheet-processing software. For example, Microsoft Excel can read only about the first 20,000 lines of a 3-Gigabyte (GB) CSV timeline file. Timesketch is the most common tool used for timeline analysis, as it is built strictly for this purpose. Other solutions are to use Eric Zimmerman’s EZViewer tool or Timeline Explorer in Windows or to use the command line to grep through and filter the file in Linux.


Timesketch


Timesketch has seven main parameters on which data can be filtered: Datetime (UTC), message, display_name, parser, source, timestamp_desc, and Timeline name.


![image](https://github.com/user-attachments/assets/9112ab82-af34-4298-a133-801de9af7d39)




Timesketch uses Elasticsearch and allows for queries to quickly filter through the data. Examples of such queries are as follows:
To see all events, enter an asterisk (*) in the search box.
To find all registry events, enter source:REG in the search box.
To find all events that mention the name of a file, enter "filename.txt" in the search box.
To filter out such events as modification times and view a timestamp of a specific type and with a specific event log Identifier (ID), enter timestamp_desc:Creation "4625" in the search box (where the example timestamp type is Creation and example event log ID is 4625).
Time Zones


By default, Plaso generates a timeline in Coordinated Universal Time (UTC), not in the time zone that was in use in the forensic image. The local time zone of the forensic image must be known before beginning analysis. When running Plaso, it is possible to specify in the command which time zone to output the results in. The following examples specify that the timeline’s CSV file should be written in the Eastern time zone.


To create the timeline with the time zone specified, run the following command: 
psteal.py --source image.raw --output-time_zone EST5EDT -o dynamic -w timeline.csv



When reading from a .plaso file in an already created timeline and to convert the timeline to a different time zone and write to a new CSV file, run the following command:
psort.py --output-time_zone EST5EDT timeline.plaso -w timeline.csv



Adding Efficiency


If only a few files or artifacts are of interest in a forensic image, Plaso can be provided with those filenames instead of the whole forensic image, resulting in a much smaller .plaso file and, therefore, more rapid processing times. If, instead, the entire forensic image must have a timeline generated for it but a select date range is known to contain items of interest, the timeline can be minimized for faster analysis.


A timeline can be filtered by the following command. The UTC time must be specified, even if the .plaso file is generated with a different time zone.
psort.py -q filename.plaso "date > '2022-05-26 20:09:00' and date < '2022-05-26 20:18:00'" -w filtered.csv



This command extracts only the dates between those specified to greatly reduce the physical size of the timeline and to contain only events in that range. 


---------------------

Timeline Event Types
Timelines gather multiple files and event information. A timeline can include such actions as the following:

System events

System reboots

Crashes

Log rotations

Service restarts

Software installs

Network connections

System configuration modifications

User activity events

Logon/logoff

Web browsing

File creation/deletion/modification times

Recent files


![image](https://github.com/user-attachments/assets/3bf3d61c-64a9-497b-bcc5-c9b93cffc92c)


---------------------



Create and Filter a Timeline
In the following lab series, create a forensic timeline using the provided Security.evtx file, filter the timeline, and view the results. A single Windows Event Log is used for time efficiency. The log focuses on 2022-05-26 16:09:00 through 2022-05-26 16:18:00 EST.

﻿

Complete the steps in the following workflow to create the timeline and filter it using a spreadsheet-processing application and the command-line tool grep. 

﻿

Workflow
﻿

1. Log in to the Virtual Machine (VM) ubuntu20 using the following credentials:

Username: trainee
Password: CyberTraining1!
﻿

2. Open a Terminal window, and run the following command to change to the directory where the Security.evtx file is located:

cd /home/trainee/Desktop/Lab1



![image](https://github.com/user-attachments/assets/5b5fceb3-e0c4-45e7-a948-163e62547398)

3. Run the following command to create a timeline from the Security.evtx file. This requires approximately 6 minutes.
psteal.py --source Security.evtx --output_time_zone EST5EDT -o dynamic -w security.csv



The result is a .plaso file:


![image](https://github.com/user-attachments/assets/8d508add-4032-480b-9b31-1ee2a742424e)


NOTE: The .plaso file is named according to the date and time the psteal.py command was run. Thus, the .plaso filename in Figure 17.3-2 is not the same as the filename generated during this workflow. 


4. Run the following command to verify creation of the new files and their sizes:
ls -alh




![image](https://github.com/user-attachments/assets/8b213783-e313-4f81-b64b-3a3b30f6a3ad)


Because the .plaso file is a database generated by Plaso that includes all the timeline information, it is much larger than the Security.evtx file. The security.csv file is even larger than the .plaso file, which is uncommon, but for ease of reading the contents, the best timeline file to use is the CSV file.


As stated earlier, using a spreadsheet application for timeline analysis of a CSV file can be difficult. To understand this more fully, open the CSV file in LibreOffice Calc, and attempt a search.


5. Run the following command to view the contents of the security.csv file in LibreOffice Calc. Ignore any errors in terminal and when LibreOffice Calc opens, select OK.
libreoffice.calc security.csv



![image](https://github.com/user-attachments/assets/3072e2ba-6882-4fd8-b8cc-93ae6e8bce09)

6. The security.csv file can be edited, sorted, and modified in LibreOffice Calc. Perform a search for 4625 (failed login attempts), and try to read the events linked to the results. Reading the events is challenging, as the rows are long, and the search term is found in other fields beyond the message field. 


7. Close the file, and return to the Terminal. 


8. Run the following commands to view the date/time range of events in the security.csv file:
head -n 2 security.csv
tail -n 2 security.csv



![image](https://github.com/user-attachments/assets/b9a149e8-3272-45ee-9a49-dc3bd694b50d)


9. The results of the previous command show that the date range in this timeline is 2022-03-27 through the day the timeline is created. (Figure 17.3-5 shows a different end date, as its timeline was created on 2022-07-05.)


10. Run the following command to create a smaller timeline that includes only the window of time during which the malicious activity occurred: 
psort.py -q (plaso file date)-Security.evtx.plaso "date > '2022-05-26 20:09:00' and date < '2022-05-26 20:18:00'" -w filteredsecurity.csv --output_time_zone EST5EDT



NOTE: The EST time window is 16:09 through 16:18, but, by default, Plaso ignores that the .plaso file was output in the EST timezone and reads it back in as UTC. If the times of 16:09 and 16:18 are used, no data is exported.


![image](https://github.com/user-attachments/assets/c60ca6f9-b5d0-4fba-b725-3fdb69ba2050)

11. Run the following command to filter the log for failed and successful logins during the new time window:

cat filteredsecurity.csv |egrep -v "'trainee'|ANONYMOUS|DC01\\$"|egrep "4624|4625"


![image](https://github.com/user-attachments/assets/059ad555-4001-439e-aae3-cc259cd324f8)


Six events are found: four for failed logins and two for successful logins. In this timeline view, it is difficult to determine why the same user had two failures when they attempted to log in only once. The reason is that Plaso shows both when the security log was last modified and when it was created. Another filter would need to be added to the grep to remove the creation logs.


As stated earlier, the tool Timesketch is built strictly for timeline analysis. Complete the steps in the following workflow to filter a timeline and view the results using Timesketch.


Workflow 


1. Open a Terminal, and run the following commands. Enter the trainee password CyberTraining1! when prompted.

cd /home/trainee/Desktop/


sudo ./StartTimesketch.sh


![image](https://github.com/user-attachments/assets/89dcd605-f4e1-459b-9754-4321d6b0fb99)

2. Open Firefox, and browse to localhost.


3. Log in to Timesketch with the following credentials:

Username: trainee
Password: CyberTraining1!




4. Select New Investigation, and name it securitylog.



5. Select filteredsecurity.csv as the file to upload to Timesketch:


![image](https://github.com/user-attachments/assets/d22d0c11-c91b-4de2-8e76-a309f6e6c133)


6. Once the Name fields are populated, select Upload:



![image](https://github.com/user-attachments/assets/12578a40-0122-41e5-96bf-27c9d699b272)

The page reloads and shows that the timeline is being indexed; that is, it is being read into Timesketch. This requires approximately 30 seconds.


7. Once the screen no longer displays Indexing in progress, select Begin to explore your data:


![image](https://github.com/user-attachments/assets/54044e1e-eadb-4d83-9dd8-52595e4fb536)

8. Initially, no results are displayed. To verify that the data was loaded into Timesketch correctly, enter an asterisk (*) in the search box, and enter:


![image](https://github.com/user-attachments/assets/39f80cdc-10b9-4ea6-b9b9-eb48bc2e3b0b)

Each event highlighted in a given color (orange in the screenshots) can be selected to view more details and to see all the fields that are populated. To see the most useful information without the need to select each event, change the filter to show more columns than the standard Datetime and message fields.


9. Select Customize columns, and add the columns display_name, parser, source, and timestamp_desc. The columns must be added one at a time. 


10. Search through the events for the two suspicious failed login attempts by entering "4625" !message:"trainee" timestamp_desc:"Creation Time" in the search field:



![image](https://github.com/user-attachments/assets/3ddbb45f-120e-4e67-bd0e-495ab94f34ee)



-----------------------














































































































































































































































































