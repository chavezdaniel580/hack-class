########## M1 L1 ############
######### Intel-Driven Threat Hunting ###########

This lesson explains the six distinct steps of the CPT OP with regard to threat hunting:
Objectives, Effects, Guidance
Terrain Identification and Prioritization 
Capability Analysis and Force Allocation
Orders Production and Dissemination
Tactical Planning and Mission Execution
Assessment

![image](https://github.com/user-attachments/assets/fe9aebca-9858-41fa-843c-3258e69d7a17)

-----------------------------------------------------------------------------------------------------------------------
Policies, Procedures, and Regulations 

Another critical component of the CPT OP are the policies, procedures, and regulations that leadership and governing bodies establish for hunt missions. There are numerous additional guidelines that govern the CPT. However, the following two Titles of the United States Code are the most noteworthy:

Title 10. Concerns military operations and provides the legal basis for the roles, missions, and organization of each of the services as well as the Department of Defense (DoD).

Title 50. Concerns intelligence organizations and provides guidance for how to conduct intelligence-gathering efforts. Also provides governance for other national defense activities.

Step 1: Objectives, Effects, and Guidance
![image](https://github.com/user-attachments/assets/8a3c841f-8eae-4db2-be2a-024549315d31)

Step 2: Terrain Identification and Prioritization
![image](https://github.com/user-attachments/assets/293bce66-d0ca-4139-ad61-af054577cda4)

Step 3: Capability Analysis and Force Allocation
![image](https://github.com/user-attachments/assets/c0f8369a-8763-4c59-8449-d047d8e40bb5)

Step 4: Orders Production and Dissemination
![image](https://github.com/user-attachments/assets/9d95853d-72da-47cf-ba5e-d51c4af9ad67)

Step 5: Tactical Planning and Mission Execution
![image](https://github.com/user-attachments/assets/80ecb239-64d8-493a-a16c-6e5c67e6b261)

Step 6: Assessment
![image](https://github.com/user-attachments/assets/b63f14b4-449a-48a2-b75a-da54670a77eb)

------------------------------------------------------------------------------------------
Cyber Threat Hunting

CTH is the process of actively searching information systems to identify and stop malicious cyberspace activity. The term “hunting” refers only to internal defensive measures that require maneuver within the defended network to identify, locate, and eradicate an advanced, persistent threat. A primary component of threat hunting is based on detecting TTPs. 

CTH Kill Chain

The Start. Search for MCA by filtering out legitimate or expected activity on the network.
Refinement. Find suspicious activity. This triggers a deeper investigation and increases search efforts. 
Discovery. Discover the root cause of the malicious behavior. 
Response. Calculate and assess the attack. Remediate the threat based on this information.
Continuous Improvement. Update defenses to prevent future attacks that use the same TTPs discovered during the hunt. 

![image](https://github.com/user-attachments/assets/a9654baa-53fd-466d-8b41-ead98a5d78a1)

What is NOT CTH

CTH starts before any threat has been found. On the other hand, practices such as incident forensics or incident response occur after identifying an incident or compromise. The aim of CTH is to illuminate an adversary before a known incident. This requires analyzing the current environment and its conditions to identify any evidence of intrusion or compromise before any are known to exist.

-------------------------------------------------------------------------------------

CTH Methodologies

-Analytics-driven

The analytics-driven methodology leverages data and analytics. This methodology applies complex queries and algorithms to data sets, often using software  automation. A key distinction with the analytics methodology is that it does not require physical access to local machines, networks, or systems. CTH analysts   using the analytics-driven methodology gather data artifacts consisting of sensor alerts, system logs, and network traffic. Combining knowledge of data artifacts   with knowledge of automated analysis capabilities allows the analysts to develop a picture of the network terrain.

-Situational awareness-driven

The situational awareness-driven methodology leverages an advanced understanding of a particular cyberspace terrain to detect anomalous activity. Similar to the analytics methodology, situational awareness does not require physical access to local systems. Data artifacts pertaining to the operating environment are critical to this methodology. CTH analysts examine data artifacts over time in order to understand system normality and detect outliers in behavior. This often leads to discovering potential MCA.

-Intelligence-driven

The intelligence-driven methodology leverages timely, accurate, mature Cyberspace Threat Intelligence (CTI) to detect advanced cyberspace threats. The intelligence-driven methodology requires physical access to local systems.

-------------------------------------------------------------------------------------

Cyber Threat Intelligence Overview

Analysts using the intelligence-driven methodology leverage CTI. CTI is information that has been analyzed to aid an organization in identifying, assessing, monitoring, and responding to cyber threats. Organizations generally produce various types of CTI, which they can share internally for CTH. Information may also be derived externally, from outside of the organization. Examples of CTI include:

Indicators (system artifacts or observables associated with an attack)
TTPs
Security alerts
Threat intelligence reports
Recommended security tool configurations

CTI can trigger a hunt operation by warning of an imminent or already-realized cyber attack, or by reporting on new indicators or adversaries that were recently seen in the wild. 

Types of CTI 

Organizations develop different types of CTI, depending on who is receiving the information and what details it includes. The three categories of CTI include the following:

Strategic. Broad, general information that provides high-level threats and activities in a non-technical delivery.

Tactical. TTP outlines for a technical delivery that explains how the adversary may attempt to attack the network. 

Operational. Purely technical information about specific attacks, experiences, or campaigns that provides actionable information regarding activities that have been previously identified.

CTI Sources

CTI is derived from both internal and external sources. Internal refers to CTI collected from within the network or organization where the hunt operation is occurring. Internal CTI typically includes artifacts such as network event logs, IP Addresses, or records of past incident responses. External CTI refers to CTI collected from sources outside of (or "external" to) the network or organization where the hunt operation is occurring. External CTI typically includes artifacts such as those found on the open internet or technical sources (such as MITRE ATT&CK). A key benefit of external CTI is that organizations can leverage the collective knowledge, experience, and capabilities from the community to gain a more complete understanding of the threats the organization may face. 

-------------------------------------------------------------------------------------

IOCs

As defined by the CWP an IOC is, “a forensic artifact observed on a computer network or in a computer operating system which indicates an intrusion.” IOCs change and can take on a wide variety of topics and forms. Some common IOCs include the following:

Unexpected network traffic (inbound or outbound)
Unusual internet protocol (IP) addresses
Connections to strange geographic areas
Increased activity by a privileged user
Increased volume of data transmission

TTPs

TTPs are a chain, or sequence, of actions taken by the adversary during their actions or campaign. There is a wide variety of TTPs, however, some common TTPs include using a specific malware variant, attack tool, delivery mechanism (such as phishing), or exploit.

TTPs are located at the top of the pyramid. According to Bianco, “at the apex are the TTPs. When you detect and respond at this level, you are operating directly on adversary behaviors, not against their tools.” 

 ![image](https://github.com/user-attachments/assets/cc916015-64a7-4c1d-b782-537e99772e7d)
 
-------------------------------------------------------------------------------------

######### M1 L2 ########
########## Developing a Hunt Hypothesis ###########

What is Threat Hunting?

hreat hunting is the proactive and iterative search through networks, endpoints, or datasets to detect unknown malicious, suspicious, or anomalous activities that have not been detected by existing automated tools. Successful threat hunting requires an understanding of adversary activity. The Lockheed Martin Cyber Kill Chain is an analytic framework that breaks down the seven phases that a threat follows to achieve an objective, in an attack against an ally network. The attachment Cyberspace Threat Hunting explains the seven phases in greater detail. The phases of the Cyber Kill Chain include the following:

Reconnaissance. The threat collects information on the potential target before any attack actually happens. The threat may still be choosing a target in this phase.
Weaponization. The threat creates a malicious payload to exploit the targeted friendly network. 
Delivery. The threat delivers the malicious payload to the target victim by email or other means. 
Exploitation. The threat exploits a vulnerability identified earlier in order to execute the malicious payload. 
Installation. The threat installs malware onto the victim's network.
Command and Control. The threat creates a Command and Control (C2) channel to continue communication and operations of the installed malware and manipulation of the victim's system. 
Actions on Objectives. The threat performs the steps necessary to achieve its goals within the friendly network.    

What is NOT Threat Hunting

There are a few clear lines between threat hunting and other cybersecurity tasks, such as incident response. Some organizations may be organized such that threat hunting and incident response are done by the same set of personnel. However, each activity has its unique traits and goals that differentiate it from one another. Incident response is the organization's process to investigate a known or suspected cybersecurity incident. The following tasks are not considered part of threat hunting tasks. Instead, they are often conducted in parallel with threat hunting or may be initiated by threat hunting.

Incident response of a reported compromise. The goal of threat hunting is to identify evidence of unknown or unreported Malicious Cyberspace Activity (MCA) that may indicate a compromise or intrusion.

Installing tools and waiting for alerts. Threat hunting requires proactive analysis and data of adversary Tactics, Techniques, and Procedures (TTP) in order to identify MCA.

Reporting on incidents or intrusions. An incident response team provides in-depth analysis and reporting on an identified intrusion. Threat hunting identifies MCA prior to a known incident.

Incident forensics. This is performed by an incident response team after suspected MCA has been identified.

-------------------------------------------------------------------------------------

What is a Hunt Hypothesis?

A good hunt hypothesis accomplishes the following goals:
Direct analysts towards potential analysis methods.
Propose what attacker activity might look like when found.
Identify likely sources of evidence to hunt within.
Provide a path for analysts to follow to prove or disprove the hypothesis.


-------------------------------------------------------------------------------------

Tactics, Techniques, and Procedures (TTP)

T1589.001 Gather Victim Identity Information: Credentials
FARMCHASER has made use of victim organizations' account credentials by using methods such as phishing for information. They have been known to use compromised credentials in order to access sensitive information. 


T1212 Exploitation for Credential Access
FARMCHASER has also been known to exploit software vulnerabilities in order to collect victims' credentials. They tend to target Kerberos in order to gain domain user permissions on a system.


T1136.001 Create Account: Local Account
T1136.002 Create Account: Domain Account
FARMCHASER has created both local machine accounts and domain accounts in order to maintain persistence within an environment.


T1098 Account Manipulation
FARMCHASER has added, compromised, or maliciously created accounts to privileged security groups in order to maintain elevated access to victim networks.


T1567.002 Exfiltration Over Web Service: Exfiltration to Cloud Storage
FARMCHASER has used cloud storage services such as Dropbox or OneDrive to exfiltrate data over the internet.


T1039 Data from Network Shared Drive
FARMCHASER often searches through network shares on computers that they have compromised to find files of interest. Sensitive data that is found is collected in a central network location prior to exfiltration.


T1005 Data from Local System
FARMCHASER tends to also search local file systems or databases for sensitive files. 


T1114 Email Collection
FARMCHASER has targeted user email to collect sensitive information. The email subjects typically contain words such as payment, invoice, or urgent. 

-------------------------------------------------------------------------------------

Possible Hypotheses
There are multiple hypotheses that can be made from the FARMCHASER threat intel brief and TTPs. Some possible hypotheses that could have been created include the following: 


FARMCHASER uses compromised credentials to access sensitive information.
FARMCHASER may create new user accounts within Active Directory (AD).
FARMCHASER may grant permissions to user accounts by adding them to the local Administrators security group.
FARMCHASER may grant permissions to user accounts by adding them to the Domain Admins or Backup Operators AD groups.
Malware is exfiltrating sensitive data to the internet from at least one of the domain controllers.
Malware is exfiltrating sensitive data to the internet from at least one of the servers responsible for the storage of that data.
FARMCHASER accesses sensitive data from servers by pivoting from systems defined in the tactical KT-C.
A local secondary system is connecting to the domain controller to gain access to sensitive information.

 
-------------------------------------------------------------------------------------
Identifying and Collecting Data for Hunting

A CPT identifies the key tasks to meet the goals of the hunt operation when creating their tactical plan. For hunting operations, these key tasks include high-level hunt topics that can be broken down into individual hunts. In terms of collecting data from these data sources, a CPT must be prepared to adapt to a wide array of situations. No set plan can be established for collecting data from an environment, due to the variety of data sources available and the differences between networks. 


There are multiple different ways a CPT can collect data from data sources. A CPT could gain access to a pre-existing data source owned by the local network operators or could ask local administrators to configure a pre-existing stream to send data into the CPT's systems. A CPT could also gather data themselves by configuring a network tap or collecting the data directly from the endpoints if possible. A CPT should be familiar with the different types of data sources and security-related data that can exist within an environment. This allows the CPT to make informed decisions about which data sources are the most valuable during a hunt.


The following are broad categories of the different types of logs that an analyst could use during a hunt:
Host
Network
Security Appliance
Application

Host Logs

Each Operating System (OS) generates its own host logs. A wide variety of different host logs are available, but not all of them are security-focused. Additionally, different OSs contain different types of host logs, and CPT analysts that are performing a host log investigation must learn to use and examine different sources, types, and qualities of logs that each OS generates. 


The following are examples of some of the events that an OS generates that can be useful in a hunt:
A process that was started or stopped
A network connection that was attempted and failed
Multiple failed user logon attempts
An unknown device that was plugged into a system
Changes to system settings
Registry additions or modifications

Network Logs


Network logs are generated by software or devices that are connected to the network. They contain information about a connection such as its source, destination, associated ports, and the amount of data being transferred. Some network logs are generated as part of normal OS activity and may be accessed in the same way the host logs are accessed. Other, more advanced network logs are generated by networking appliances such as routers, firewalls, or proxy devices. 


Security Appliance Logs      


Security appliance logs are logs that are generated by a security appliance such as an intrusion detection system (IDS), anti-virus scanning devices, or content-filtering devices. These logs are typically related to potential malware or an IDS that has detected network traffic that patterns a potential attack since the goal of most security appliances is to prevent or detect MCA. 


Application Logs


Application logs are any logs that are generated by an individual application. Not all applications generate logs, and not all application logs are useful to an application. However, application logs can be useful to analysts in order to gain additional information on an attack, or when a specific application is exploited during an attack. Application logs can also be useful to analysts as a source of evidence or to fill potential visibility gaps in an investigation.

-------------------------------------------------------------------------------------

########### M1 L3 ##############
################ Surveying the Attack Surface ####################



![image](https://github.com/user-attachments/assets/3166acdd-5643-4d62-8b0f-0f589b507c10)


---------------------------------------------------------------------
Pre-Authentication Brute Force Logs


The process of brute-forcing these accounts leaves some forensic residue in the logs. These authentication failures are not logged with a normal event ID 4625: An account failed to log on. Instead, they produce an event ID 4771 which is only on the DC. This event ID is described below:


Event ID: 4771, Kerberos pre-authentication failed
Result Code: 0x18 KDC_ERR_PREAUTH_FAILED
Bad password
Result Code: 0x6 KDC_ERR_C_PRINCIPAL_UNKNOWN
Kerberos produces an error if the username is incorrect. Attackers can leverage this to guess usernames.

Defenders should monitor the following with this event log and attack:
High-value accounts, such as domain admins
Off-hours logs
Inactive accounts
Client Address field is outside the internal range
Large volume of logs
Incorrect pre-authentication type for the network
If only smartcards are allowed within the network (pre-authentication type 15) and the 4771 log shows a failure with pre-authentication type 2, then something is trying to use a password.




Golden Ticket Logs


Logging associated with a Golden Ticket is an exploit technique, but not directly due to a flaw in Kerberos. The tools executing this attack do not work exactly the same way that the native windows systems work. This creates anomalies within the logging. Below is a snapshot of the event logs associated with this attack and some notable features. The main point of this data is that hacking tools tend to leave odd entries within logs that will be inconsistent with how the legitimate system tools create logs.


Event ID: 4769, A Kerberos service ticket was requested
Location: Domain controller
Notable activity is a TGS being requested without a preceding TGT 

Event ID: 4627, Group membership information
Location: workstation/Domain controller	

Event ID: 4624, An account was successfully logged on
Location: workstation/Domain controller
Field: Account Domain may be the Fully Qualified Domain Name (FQDN) when it normally is the short domain name
Field: IpAddress may indicate the compromised host

Event ID: 4672, Admin Logon
Location: workstation
Field: Account Domain may be blank when it normally is the short domain name

Event ID: 4634, Account Logoff
Location: workstation
Field: Account Domain may be blank when it normally is the short domain name

---------------------------------------------------------------------
########## M1 L4 ############
############# Log Aggregation and Parsing ############








---------------------------------------------------------------------

########## M2 L2 ############
############# Splunk Refresher ############









---------------------------------------------------------------------

########## M2 L3 ############
############# Options for Endpoint ############








---------------------------------------------------------------------

########## M2 L4 ############
############# Options for the Network ############








----------------------------------------------------------------------

########## M2 L5 ############
############# Windows Event Monitoring ############


Configuring a robust logging solution comprises more than just configuring the subcategories in the audit policy. There are several powerful ways to get more robust logging out of a Windows system. These ways also allow more effective log tuning to produce the data sources required to help analysts identify threat actors. The next few sections of this lesson introduce the logging options available in the following tools:
Native WindowsSysmonPowerShell specific options
Native Windows Logging Configuration Options


The security backbone of a Windows network starts with the native Windows logging options. The temptation is to enable all logging options, however excessive logging has additional costs that hamper proper defense. There are two locations on a system that allow malware to persist after a reboot. These are the file system and the registry.


File System Logging


File system changes create logs with the Event ID 4663: An attempt was made to access an object. This requires the following subcategories to be enabled:
Audit File SystemAudit Kernel ObjectAudit RegistryAudit Removable Storage
Registry Logging


The registry houses Windows configuration information and a significant amount of forensic data. Hundreds, if not thousands, of registry changes happen every minute. While logging registry changes create useful data, they create as much, if not more, unusable data.






Sysmon Events
Event ID 1: Process creation
Event ID 2: A process changed a file creation time
Event ID 3: Network connection
Event ID 4: Sysmon service state changed
Event ID 5: Process terminated
Event ID 6: Driver loaded
Event ID 7: Image loaded
Event ID 8: CreateRemoteThread
Event ID 9: RawAccessRead
Event ID 10: ProcessAccess
Event ID 11: FileCreate
Event ID 12: RegistryEvent (Object create and delete)
Event ID 13: RegistryEvent (Value Set)
Event ID 14: RegistryEvent (Key and Value Rename)
Event ID 15: FileCreateStreamHash
Event ID 16: ServiceConfigurationChange
Event ID 17: PipeEvent (Pipe Created)
Event ID 18: PipeEvent (Pipe Connected)
Event ID 19: WmiEvent (WmiEventFilter activity detected)
Event ID 20: WmiEvent (WmiEventConsumer activity detected)
Event ID 21: WmiEvent (WmiEventConsumerToFilter activity detected)
Event ID 22: DNSEvent (DNS query)
Event ID 23: FileDelete (File Delete archived)
Event ID 24: ClipboardChange (New content in the clipboard)
Event ID 25: ProcessTampering (Process image change)
Event ID 26: FileDeleteDetected (File Delete logged)


![image](https://github.com/user-attachments/assets/fec25dd1-28d7-4c5a-8e35-ab4ce6f9db81)


Critical


The following events should be enabled because they each have unique advantages and manageable false positives. If the event creates a lot of noise, it would still be possible to configure Sysmon to reduce the noise. In the table, these events are marked with a red icon:
Event ID 1: Process creation
Event ID 2: A process changed a file creation time
Event ID 4: Sysmon service state changed
Event ID 6: Driver loaded
Event ID 7: Image loaded
Event ID 9: RawAccessRead
Event ID 15: FileCreateStreamHash
Event ID 16: ServiceConfigurationChange
Event ID 17: PipeEvent (Pipe Created)
Event ID 18: PipeEvent (Pipe Connected)

Overlapping


The events marked with a yellow icon in the table are recommendations for events to enable if they’re not already addressed by other systems. Within a production network, these events cause excessive logs that do not provide much benefit. However, in a controlled lab setting, these events are useful for investigations:
Event ID 3: Network connection
Event ID 5: Process terminated
Event ID 22: DNSEvent (DNS query)


![image](https://github.com/user-attachments/assets/5a733338-eaa3-4eec-9e69-fae2549fc76f)


As another example, Sysmon Event ID 5: Process terminated provides only the process Globally Unique Identifier (GUID) over the equivalent native Windows log. The native logging event 4689: A process has exited provides the process's exit code, which Sysmon does not provide. Figure 2.5-5 lists this comparison between this Sysmon and Windows events details.


![image](https://github.com/user-attachments/assets/d410f8c2-dbf1-44a6-83a7-a553831fd1db)


Threat-Specific


Some Sysmon events should be enabled for specific threats. The table uses a blue icon to identify these items. Each of the following events is best enabled only during very specific situations. They each require effort to tune properly and effectively. 
Event ID 8: CreateRemoteThread
Event ID 10: ProcessAccess
Event ID 11: FileCreate
Event ID 12: RegistryEvent (Object create and delete)
Event ID 13: RegistryEvent (Value Set)
Event ID 14: RegistryEvent (Key and Value Rename)
Event ID 19: WmiEvent (WmiEventFilter activity detected)
Event ID 20: WmiEvent (WmiEventConsumer activity detected)
Event ID 21: WmiEvent (WmiEventConsumerToFilter activity detected)
Event ID 23: FileDelete (File Delete archived)
Event ID 24: ClipboardChange (New content in the clipboard)
Event ID 25: ProcessTampering (Process image change)
Event ID 26: FileDeleteDetected (File Delete logged)


Extensive Filtering


The following event logs require extensive filtering. The two ways to filter are by inclusion or by exclusion. Include-based filtering only logs events that are explicitly defined. Exclude-based filtering logs all events.
Event ID 1: Process creation
Event ID 5: Process terminated
Event ID 11: FileCreate
Event ID 12: RegistryEvent (Object create and delete)
Event ID 13: RegistryEvent (Value Set)
Event ID 14: RegistryEvent (Key and Value Rename)
Event ID 22: DNSEvent (DNS query)

PowerShell Logging Options
PowerShell auditing is incredibly useful for a defender. PowerShell scripts are not normally executed by users, yet are frequently leveraged to execute most Windows exploitation techniques. PowerShell is not just a scripting language, it has the same power as a compiled binary. PowerShell is so integral to Windows exploitations, Microsoft released a patch to add additional logging capabilities in an effort to combat hackers. PowerShell logs contain information regarding PowerShell operations, such as starting and stopping the application, cmdlets used, and files accessed. PowerShell logs may be accessed in a variety of channels, such as directly within a PowerShell session or within the C:\Windows\System32\winevt\Logs directory. PowerShell logging does not work like other native Windows logging categories. It is verbose enough that Sysmon created specific events for PowerShell. Examples of useful Windows Event IDs are as follows:﻿﻿

4688: A new process has been created: New PowerShell commands create the following event when the subcategory Audit Process Creation is configured.

400: Engine state is changed from None to Available: Details when the PowerShell EngineState has started.

800: Pipeline execution details for command line: Write-Host Test: Details the pipeline execution information of a command executed by PowerShell.

Enhanced PowerShell Logging
﻿

Although Microsoft designed PowerShell as a useful tool for administrators, it became a prized tool for hackers, as well. PowerShell works on the Microsoft .NET framework, which borrows its design pattern from the programming language Java. The Java language design minimizes compile times and allows software to work on various types of processors. This makes PowerShell more than just a command-line administration tool. The Java-based design of the .NET framework enables PowerShell to have the exact same capabilities of compiled software, but without requiring a binary on the system.

﻿

The hacking world rapidly adopted PowerShell-based exploitation techniques due to these capabilities. Microsoft responded by adding enhanced PowerShell logging features. Windows 10 has enhanced PowerShell logging natively. Older versions of Windows may need updates to provide enhanced PowerShell logging. This layered approach means that the configuration of PowerShell logging is non-conventional and is not configured the same as other logging. The enhanced PowerShell logging introduced in 2015 has three configurable logging capabilities:

Module logging

Script block logging

Transcription logging

Module Logging
﻿

PowerShell Module Logging records the commands executed and portions of the scripts, but does not deobfuscate all code. This means attackers can create code that is intentionally obscure and confusing. To enable module logging, make the following changes to the registry:

HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\ModuleLogging
EnableModuleLogging = 1
﻿

This enables logging for the following Event ID:

4103: Executing Pipeline

﻿

Script Block Logging
﻿

Script block logging logs PowerShell scripts as they are executing within the PowerShell engine. This deobfuscates any PowerShell scripts. Prior to this feature, attackers would create scripts that appeared either benign or unintelligible, then the script would change itself just prior to execution. With script block logging enabled, the entire script is logged after it is processed. This shows the deobfuscated code to defenders. To enable script block logging, make the following changes to the registry:

HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
EnableScriptBlockLogging = 1
﻿

This enables logging for the following Event ID:

4104: Execute a Remote Command

﻿

Transcription Logging
﻿

Transcription logging makes a record for every PowerShell session, including all input and output with timestamps. This is displayed at the command line terminal. To enable transcription logging, make the following changes to the registry:

HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\Transcription\
EnableInvocationHeader = 1
EnableTranscripting = 1
OutputDirectory = <path_to_directory>
﻿

This enables logging of the shell's transcript to the configured output directory. 


erberos Review


Kerberos is a domain authentication protocol that is commonly used within Windows domains. The two functions of Kerberos is to authenticate the user, then grant tickets based on permissions. A previous lesson explored Kerberos in greater detail. 


Figure 2.5-6 illustrates the three typical steps to authenticate and request access to a service using Kerberos. The steps are as follows:
Request and Receive TGT: A user authenticates by requesting a ticket-granting-ticket (TGT) from the Domain Controller (DC) which acts as the Key Distribution Center (KDC).
Request and Receive Service Ticket: User requests access to a resource by requesting a Service Ticket, referred to as a Ticket Granting Service (TGS).
Request Access to Resource: User requests the resource from the Application Service by sending the TGS.


![image](https://github.com/user-attachments/assets/ea07e7bb-c7a6-4902-b094-5312fd8eb9f9)


Expected Kerberos Logs


Each step of the Kerberos protocol is expected to create specific logs during normal operation. Recognizing which logs are expected helps defenders discern normal activity from unusual and possibly malicious activity. Each logging event listed below occurs in the DC.


Step 1: Request and Receive TGT


Requesting the TGT (AS_REQ)


The aim of the first step in the protocol, as illustrated in Figure 2.5-7, is for the user’s workstation to obtain the TGT by sending the DC an Authentication Service Request (AS_REQ). The default setup for a domain requires pre-authentication. Pre-authentication requires the AS_REQ to have a timestamp encrypted by the user's password. When the DC receives the TGT request, it verifies the timestamp with its own time to ensure that it is a valid time within the past few minutes. This is why, if the time is off on a workstation, it may not be able to authenticate to the domain. The DC returns the TGT, which includes additional session information that is encrypted with the user's password.


![image](https://github.com/user-attachments/assets/5712008a-cfa4-4b26-9305-da194e706b7b)


Disabling pre-authentication allows anyone to request a TGT for any user. The TGT response reveals that the session key used for the next step is encrypted by the user's password hash.


Expected Logging
Event ID: 4768, A Kerberos authentication ticket (TGT) was requested. 
Event Type: Failure, if the request fails.


Receiving the TGT (AS_REP)


For Kerberos to grant tickets based on permissions, Windows adds a Privilege Attribute Certificate (PAC) to the TGT. In Linux environments, this field is blank. The PAC includes the user's IDs as well as group memberships. This section is signed by the domain's Kerberos account on the DC: krbtgt.


Expected Logging
Event ID: 4768, A Kerberos authentication ticket (TGT) was requested.
Event Type: Success, when a TGT is returned.


Step 2: Request and Receive Service Ticket


Requesting the TGS (TGS_REQ)


After the TGT is issued, the user is authenticated to the domain. To gain access to a resource within the domain, the user's account needs to request a service ticket. This request requires the session key that was encrypted by the user's password hash from the previous step, as well as the TGT. Figure 2.5-8 illustrates this step.


![image](https://github.com/user-attachments/assets/4f3f31ee-7869-43f5-83af-4d8395fe1d5f)


Expected Logging
Event ID: 4769, A Kerberos service ticket was requested. 
Event Type: Failure, when a TGS request fails.


Receiving the TGS (TGS_REP)


The TGS includes a new session key for the service which is encrypted by the previous session key. The TGS is encrypted with the application server key so that it can be presented to the application service, in the next step, with the username and timestamp encrypted by the new session key.


Expected Logging
Event ID: 4769, A Kerberos service ticket was requested. 
Event Type: Success, when a TGS is returned.

Event ID: 4770, A Kerberos service ticket was renewed. 
Event Type: Only successful when the TGS is renewed.


Step 3: Request Access to the Resource


The final step, as illustrated in Figure 2.5-9, is the user's workstation presenting the TGS from step two to the application server for the resource. This step includes optional mutual authentication and an optional PAC check. The PAC check is discussed below.


![image](https://github.com/user-attachments/assets/e3eb968d-9a6b-408b-a2fd-2df646d8ee0b)


Checking the PAC (optional)


Going back and having the application server verify the PAC sounds foolproof, but there are several important caveats that do not prevent any Kerberos-based attacks at this point. 


Make the following changes to the registry to enable this option:
HKLM/SYSTEM/CurrentControlSetControl/Lsa/KerberosParameters/
ValidateKdcPacSignature = 1



This option appears to provide no additional security. It is unclear the exact circumstances when Windows enforces PAC checking. Windows released a confusing statement about PAC checking in an official blog post describing the conditions when Windows would not check the PAC. What is clear is the only exploit that has manipulated a PAC was patched in 2014. Even with that patch removed and PAC checking enabled, security researchers have demonstrated successfully exploiting a DC with the silver ticket attack.


The event 4768 is when a TGT is requested. There is never a situation where a TGS can be used without a TGT being requested from that system.


. Search for all systems through which the user iker.mckay submitted a TGT request by entering the following:
winlog.event_id: 4768 AND winlog.event_data.TargetUserName: iker.mckay



The following search query identified all systems that requested a TGS (event 4769) for the user iker.mckay in Step 7:
winlog.event_id: 4769 AND winlog.event_data.TargetUserName: iker.mckay





3. Change the working directory to the trainee's desktop by entering the following command:
PS C:\Windows\system32> cd C:\Users\trainee\Desktop



NOTE: If the PowerShell terminal does not have administrative privileges, some log sources are not searchable by the executed commands. These privileges are necessary for this lab.


4. Declare the start time Mar 2, 2022 @ 16:00:00 as a variable by entering the following command:
PS C:\Users\trainee\Desktop> $start = "2022-03-02 4:00:00 PM"



5. Declare the end time Mar 2, 2022 @ 16:20:00 as a variable by entering the following command: 
PS C:\Users\trainee\Desktop> $end = "2022-03-02 4:20:00 PM"



6. Search for Windows PowerShell commands that happened between the selected times from the Windows_PowerShell.evtx file by entering the following command:
PS C:\Users\trainee\Desktop> Get-WinEvent -FilterHashTable @{path="Windows_PowerShell.evtx"; StartTime=$start; EndTime=$end}


Search for mimikatz across the Windows PowerShell log by entering the following command:
PS C:\Users\trainee\Desktop> Get-WinEvent -FilterHashTable @{path="Windows_PowerShell.evtx"; StartTime=$start; EndTime=$end} | Where-Object {$_.Message -Match ".*mimikatz.*"}



The final set of curly brackets in the command in Step 7 uses the notation $_ to declare a temporary variable for the item in the list. This means the function Where-Object is iterating over each item in the list and putting its value into that temporary variable. 


In this context the function Where-Object filters the results based on where the data is that matches the regular expression.


8. Search for mimikatz across all the event logs by entering the following command:
PS C:\Users\trainee\Desktop> Get-WinEvent -FilterHashTable @{path="*.evtx"; StartTime=$start; EndTime=$end} | Where-Object {$_.Message -Match ".*mimikatz.*"}


########## M3 L1 ############
############# Recognizing Reconnaissance ############


![image](https://github.com/user-attachments/assets/0380bd90-f18b-4fe3-8998-36104b814ba1)

![Uploading image.png…]()



